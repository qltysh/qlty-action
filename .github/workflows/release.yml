name: Release
on:
  workflow_dispatch:
    inputs:
      increment:
        description: "How to increment version (use 'version' to specify version)"
        required: true
        type: choice
        default: minor
        options:
          - major
          - minor
          - patch
          - version
      version:
        description: "The full version to release (first choose 'version' from the 'increment' dropdown)"
        required: false
        type: string
permissions:
  contents: write
jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.QLTY_APP_ID }}
          private-key: ${{ secrets.QLTY_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Git config
        run: |
          git config user.name "qlty-bot[bot]"
          git config user.email "qlty-bot[bot]@users.noreply.github.com"

      - name: Determine version
        id: version
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./coverage/package.json').version")
          echo "Current version: $CURRENT_VERSION"

          # Determine new version based on input
          if [ "${{ inputs.increment }}" == "version" ]; then
            if [ -z "${{ inputs.version }}" ]; then
              echo "Error: Version must be specified when increment is 'version'"
              exit 1
            fi
            NEW_VERSION="${{ inputs.version }}"
          else
            # Parse current version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            case "${{ inputs.increment }}" in
              major)
                NEW_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
                ;;
              patch)
                NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
                ;;
              *)
                echo "Error: Invalid increment type"
                exit 1
                ;;
            esac
          fi

          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "major_version=$(echo $NEW_VERSION | cut -d. -f1)" >> "$GITHUB_OUTPUT"

      - name: Validate CHANGELOG.md
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Checking for version $VERSION in CHANGELOG.md"

          # Check if version exists in CHANGELOG.md
          if ! grep -q "^## v${VERSION}" CHANGELOG.md; then
            echo "Error: Version v${VERSION} not found in CHANGELOG.md"
            echo "Please add a changelog entry for v${VERSION} before releasing"
            exit 1
          fi

          echo "Found changelog entry for v${VERSION}"

      - name: Extract changelog for version
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Extract the changelog section for this version
          # Start from the version header and continue until the next version header or end of file
          CHANGELOG_CONTENT=$(awk "/^## v${VERSION}/{flag=1; next} /^## v[0-9]/{flag=0} flag" CHANGELOG.md)

          if [ -z "$CHANGELOG_CONTENT" ]; then
            echo "Warning: No changelog content found for v${VERSION}"
            CHANGELOG_CONTENT="Release v${VERSION}"
          fi

          # Write to file to preserve formatting
          echo "$CHANGELOG_CONTENT" > changelog_content.txt

          echo "Extracted changelog content:"
          cat changelog_content.txt

      - name: Update package.json versions
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update all package.json files
          for package_file in coverage/package.json fmt/package.json; do
            if [ -f "$package_file" ]; then
              echo "Updating version in $package_file to $VERSION"
              node -e "
                const fs = require('fs');
                const pkg = JSON.parse(fs.readFileSync('$package_file', 'utf8'));
                pkg.version = '$VERSION';
                fs.writeFileSync('$package_file', JSON.stringify(pkg, null, 2) + '\\n');
              "
            fi
          done

          # Show the changes
          git diff coverage/package.json fmt/package.json || true

      - name: Commit version changes
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          git add coverage/package.json fmt/package.json
          git commit -m "Release v${VERSION}"

          echo "Committed version changes"

      - name: Create and push tags
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          MAJOR_VERSION="${{ steps.version.outputs.major_version }}"

          # Create version tag
          git tag -a "v${VERSION}" -m "Release v${VERSION}"
          echo "Created tag v${VERSION}"

          # Force update major version tag to point to this commit
          git tag -fa "v${MAJOR_VERSION}" -m "Release v${VERSION}"
          echo "Created/updated major version tag v${MAJOR_VERSION}"

          # Push commit and tags
          git push origin main
          git push origin "v${VERSION}"
          git push origin "v${MAJOR_VERSION}" --force

          echo "Pushed tags to origin"

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        with:
          tag_name: v${{ steps.version.outputs.version }}
          release_name: v${{ steps.version.outputs.version }}
          body_path: changelog_content.txt
          draft: false
          prerelease: false
