"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger2 = getGlobal("diag");
  if (!logger2) {
    return;
  }
  args.unshift(namespace);
  return logger2[funcName].apply(logger2, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger2) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger2 = logger2 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger2[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger2);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger2 = getGlobal("diag");
            if (!logger2)
              return;
            return logger2[funcName].apply(logger2, __spreadArray2([], __read2(args), false));
          };
        }
        var self = this;
        var setLogger = function(logger2, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger2 === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger2);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values2, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read3(_a, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values2(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context3 = new BaseContext2(self._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self.deleteValue = function(key) {
          var context3 = new BaseContext2(self._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context3, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context3, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context3, target) {
        return this._getContextManager().bind(context3, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context3) {
  return context3.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context3, span) {
  return context3.setValue(SPAN_KEY, span);
}
function deleteSpan(context3) {
  return context3.deleteValue(SPAN_KEY);
}
function setSpanContext(context3, spanContext) {
  return setSpan(context3, new NonRecordingSpan(spanContext));
}
function getSpanContext(context3) {
  var _a;
  return (_a = getSpan(context3)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context3) {
        if (context3 === void 0) {
          context3 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context3 && getSpanContext(context3);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context3) {
        return this._getTracer().startSpan(name, options, context3);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision3) {
      SamplingDecision3[SamplingDecision3["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision3[SamplingDecision3["RECORD"] = 1] = "RECORD";
      SamplingDecision3[SamplingDecision3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
        return context3;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context3) {
  return context3.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context3, baggage) {
  return context3.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context3) {
  return context3.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracingSuppressed = exports2.unsuppressTracing = exports2.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY2 = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing3(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY2, true);
    }
    exports2.suppressTracing = suppressTracing3;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY2);
    }
    exports2.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed2(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY2) === true;
    }
    exports2.isTracingSuppressed = isTracingSuppressed2;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports2.BAGGAGE_HEADER = exports2.BAGGAGE_ITEMS_SEPARATOR = exports2.BAGGAGE_PROPERTIES_SEPARATOR = exports2.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports2.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports2.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports2.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports2.BAGGAGE_HEADER = "baggage";
    exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseKeyPairsIntoRecord = exports2.parsePairKeyValue = exports2.getKeyPairs = exports2.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports2.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports2.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports2.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports2.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var constants_1 = require_constants();
    var utils_1 = require_utils();
    var W3CBaggagePropagator2 = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports2.W3CBaggagePropagator = W3CBaggagePropagator2;
  }
});

// node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports2.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAttributeValue = exports2.isAttributeKey = exports2.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports2.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports2.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports2.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports2.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalErrorHandler = exports2.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports2.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a) {
      }
    }
    exports2.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports2.TracesSamplerValues || (exports2.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseEnvironment = exports2.DEFAULT_ENVIRONMENT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS",
      "OTEL_SEMCONV_STABILITY_OPT_IN"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports2.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
      OTEL_SEMCONV_STABILITY_OPT_IN: []
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] === "undefined") {
        return;
      }
      const value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment, values, min = -Infinity, max = Infinity) {
      if (typeof values[name] !== "undefined") {
        const value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min) {
            environment[name] = min;
          } else if (value > max) {
            environment[name] = max;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v) => v.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      const value = values[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values) {
      const environment = {};
      for (const env in exports2.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment, values);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              const value = values[key];
              if (typeof value !== "undefined" && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }
    exports2.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnvWithoutDefaults = exports2.getEnv = void 0;
    var environment_1 = require_environment();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports2.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports2.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        const hi = intValue(hexStr.charCodeAt(i));
        const lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports2.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports2.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        }
        for (let i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.otperformance = void 0;
    var perf_hooks_1 = require("perf_hooks");
    exports2.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/core/build/src/version.js
var require_version = __commonJS({
  "node_modules/@opentelemetry/core/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.30.1";
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap(values) {
  var res = {};
  var len = values.length;
  for (var lp = 0; lp < len; lp++) {
    var val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils3 = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN, TMP_DB_SYSTEM, TMP_DB_CONNECTION_STRING, TMP_DB_USER, TMP_DB_JDBC_DRIVER_CLASSNAME, TMP_DB_NAME, TMP_DB_STATEMENT, TMP_DB_OPERATION, TMP_DB_MSSQL_INSTANCE_NAME, TMP_DB_CASSANDRA_KEYSPACE, TMP_DB_CASSANDRA_PAGE_SIZE, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, TMP_DB_CASSANDRA_TABLE, TMP_DB_CASSANDRA_IDEMPOTENCE, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, TMP_DB_CASSANDRA_COORDINATOR_ID, TMP_DB_CASSANDRA_COORDINATOR_DC, TMP_DB_HBASE_NAMESPACE, TMP_DB_REDIS_DATABASE_INDEX, TMP_DB_MONGODB_COLLECTION, TMP_DB_SQL_TABLE, TMP_EXCEPTION_TYPE, TMP_EXCEPTION_MESSAGE, TMP_EXCEPTION_STACKTRACE, TMP_EXCEPTION_ESCAPED, TMP_FAAS_TRIGGER, TMP_FAAS_EXECUTION, TMP_FAAS_DOCUMENT_COLLECTION, TMP_FAAS_DOCUMENT_OPERATION, TMP_FAAS_DOCUMENT_TIME, TMP_FAAS_DOCUMENT_NAME, TMP_FAAS_TIME, TMP_FAAS_CRON, TMP_FAAS_COLDSTART, TMP_FAAS_INVOKED_NAME, TMP_FAAS_INVOKED_PROVIDER, TMP_FAAS_INVOKED_REGION, TMP_NET_TRANSPORT, TMP_NET_PEER_IP, TMP_NET_PEER_PORT, TMP_NET_PEER_NAME, TMP_NET_HOST_IP, TMP_NET_HOST_PORT, TMP_NET_HOST_NAME, TMP_NET_HOST_CONNECTION_TYPE, TMP_NET_HOST_CONNECTION_SUBTYPE, TMP_NET_HOST_CARRIER_NAME, TMP_NET_HOST_CARRIER_MCC, TMP_NET_HOST_CARRIER_MNC, TMP_NET_HOST_CARRIER_ICC, TMP_PEER_SERVICE, TMP_ENDUSER_ID, TMP_ENDUSER_ROLE, TMP_ENDUSER_SCOPE, TMP_THREAD_ID, TMP_THREAD_NAME, TMP_CODE_FUNCTION, TMP_CODE_NAMESPACE, TMP_CODE_FILEPATH, TMP_CODE_LINENO, TMP_HTTP_METHOD, TMP_HTTP_URL, TMP_HTTP_TARGET, TMP_HTTP_HOST, TMP_HTTP_SCHEME, TMP_HTTP_STATUS_CODE, TMP_HTTP_FLAVOR, TMP_HTTP_USER_AGENT, TMP_HTTP_REQUEST_CONTENT_LENGTH, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_RESPONSE_CONTENT_LENGTH, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_SERVER_NAME, TMP_HTTP_ROUTE, TMP_HTTP_CLIENT_IP, TMP_AWS_DYNAMODB_TABLE_NAMES, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, TMP_AWS_DYNAMODB_CONSISTENT_READ, TMP_AWS_DYNAMODB_PROJECTION, TMP_AWS_DYNAMODB_LIMIT, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, TMP_AWS_DYNAMODB_INDEX_NAME, TMP_AWS_DYNAMODB_SELECT, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, TMP_AWS_DYNAMODB_TABLE_COUNT, TMP_AWS_DYNAMODB_SCAN_FORWARD, TMP_AWS_DYNAMODB_SEGMENT, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, TMP_AWS_DYNAMODB_COUNT, TMP_AWS_DYNAMODB_SCANNED_COUNT, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, TMP_MESSAGING_SYSTEM, TMP_MESSAGING_DESTINATION, TMP_MESSAGING_DESTINATION_KIND, TMP_MESSAGING_TEMP_DESTINATION, TMP_MESSAGING_PROTOCOL, TMP_MESSAGING_PROTOCOL_VERSION, TMP_MESSAGING_URL, TMP_MESSAGING_MESSAGE_ID, TMP_MESSAGING_CONVERSATION_ID, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, TMP_MESSAGING_OPERATION, TMP_MESSAGING_CONSUMER_ID, TMP_MESSAGING_RABBITMQ_ROUTING_KEY, TMP_MESSAGING_KAFKA_MESSAGE_KEY, TMP_MESSAGING_KAFKA_CONSUMER_GROUP, TMP_MESSAGING_KAFKA_CLIENT_ID, TMP_MESSAGING_KAFKA_PARTITION, TMP_MESSAGING_KAFKA_TOMBSTONE, TMP_RPC_SYSTEM, TMP_RPC_SERVICE, TMP_RPC_METHOD, TMP_RPC_GRPC_STATUS_CODE, TMP_RPC_JSONRPC_VERSION, TMP_RPC_JSONRPC_REQUEST_ID, TMP_RPC_JSONRPC_ERROR_CODE, TMP_RPC_JSONRPC_ERROR_MESSAGE, TMP_MESSAGE_TYPE, TMP_MESSAGE_ID, TMP_MESSAGE_COMPRESSED_SIZE, TMP_MESSAGE_UNCOMPRESSED_SIZE, SEMATTRS_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING, SEMATTRS_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME, SEMATTRS_DB_STATEMENT, SEMATTRS_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME, SEMATTRS_FAAS_CRON, SEMATTRS_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT, SEMATTRS_NET_PEER_IP, SEMATTRS_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME, SEMATTRS_NET_HOST_IP, SEMATTRS_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE, SEMATTRS_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE, SEMATTRS_THREAD_ID, SEMATTRS_THREAD_NAME, SEMATTRS_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH, SEMATTRS_CODE_LINENO, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM, SEMATTRS_RPC_SERVICE, SEMATTRS_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes, TMP_DBSYSTEMVALUES_OTHER_SQL, TMP_DBSYSTEMVALUES_MSSQL, TMP_DBSYSTEMVALUES_MYSQL, TMP_DBSYSTEMVALUES_ORACLE, TMP_DBSYSTEMVALUES_DB2, TMP_DBSYSTEMVALUES_POSTGRESQL, TMP_DBSYSTEMVALUES_REDSHIFT, TMP_DBSYSTEMVALUES_HIVE, TMP_DBSYSTEMVALUES_CLOUDSCAPE, TMP_DBSYSTEMVALUES_HSQLDB, TMP_DBSYSTEMVALUES_PROGRESS, TMP_DBSYSTEMVALUES_MAXDB, TMP_DBSYSTEMVALUES_HANADB, TMP_DBSYSTEMVALUES_INGRES, TMP_DBSYSTEMVALUES_FIRSTSQL, TMP_DBSYSTEMVALUES_EDB, TMP_DBSYSTEMVALUES_CACHE, TMP_DBSYSTEMVALUES_ADABAS, TMP_DBSYSTEMVALUES_FIREBIRD, TMP_DBSYSTEMVALUES_DERBY, TMP_DBSYSTEMVALUES_FILEMAKER, TMP_DBSYSTEMVALUES_INFORMIX, TMP_DBSYSTEMVALUES_INSTANTDB, TMP_DBSYSTEMVALUES_INTERBASE, TMP_DBSYSTEMVALUES_MARIADB, TMP_DBSYSTEMVALUES_NETEZZA, TMP_DBSYSTEMVALUES_PERVASIVE, TMP_DBSYSTEMVALUES_POINTBASE, TMP_DBSYSTEMVALUES_SQLITE, TMP_DBSYSTEMVALUES_SYBASE, TMP_DBSYSTEMVALUES_TERADATA, TMP_DBSYSTEMVALUES_VERTICA, TMP_DBSYSTEMVALUES_H2, TMP_DBSYSTEMVALUES_COLDFUSION, TMP_DBSYSTEMVALUES_CASSANDRA, TMP_DBSYSTEMVALUES_HBASE, TMP_DBSYSTEMVALUES_MONGODB, TMP_DBSYSTEMVALUES_REDIS, TMP_DBSYSTEMVALUES_COUCHBASE, TMP_DBSYSTEMVALUES_COUCHDB, TMP_DBSYSTEMVALUES_COSMOSDB, TMP_DBSYSTEMVALUES_DYNAMODB, TMP_DBSYSTEMVALUES_NEO4J, TMP_DBSYSTEMVALUES_GEODE, TMP_DBSYSTEMVALUES_ELASTICSEARCH, TMP_DBSYSTEMVALUES_MEMCACHED, TMP_DBSYSTEMVALUES_COCKROACHDB, DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB, DbSystemValues, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues, TMP_FAASTRIGGERVALUES_DATASOURCE, TMP_FAASTRIGGERVALUES_HTTP, TMP_FAASTRIGGERVALUES_PUBSUB, TMP_FAASTRIGGERVALUES_TIMER, TMP_FAASTRIGGERVALUES_OTHER, FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER, FaasTriggerValues, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, TMP_FAASINVOKEDPROVIDERVALUES_AWS, TMP_FAASINVOKEDPROVIDERVALUES_AZURE, TMP_FAASINVOKEDPROVIDERVALUES_GCP, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues, TMP_NETTRANSPORTVALUES_IP_TCP, TMP_NETTRANSPORTVALUES_IP_UDP, TMP_NETTRANSPORTVALUES_IP, TMP_NETTRANSPORTVALUES_UNIX, TMP_NETTRANSPORTVALUES_PIPE, TMP_NETTRANSPORTVALUES_INPROC, TMP_NETTRANSPORTVALUES_OTHER, NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER, NetTransportValues, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues, TMP_HTTPFLAVORVALUES_HTTP_1_0, TMP_HTTPFLAVORVALUES_HTTP_1_1, TMP_HTTPFLAVORVALUES_HTTP_2_0, TMP_HTTPFLAVORVALUES_SPDY, TMP_HTTPFLAVORVALUES_QUIC, HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC, HttpFlavorValues, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues, TMP_MESSAGINGOPERATIONVALUES_RECEIVE, TMP_MESSAGINGOPERATIONVALUES_PROCESS, MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues, TMP_RPCGRPCSTATUSCODEVALUES_OK, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues, TMP_MESSAGETYPEVALUES_SENT, TMP_MESSAGETYPEVALUES_RECEIVED, MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED, MessageTypeValues;
var init_SemanticAttributes = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils3();
    TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM = "db.system";
    TMP_DB_CONNECTION_STRING = "db.connection_string";
    TMP_DB_USER = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
    TMP_DB_NAME = "db.name";
    TMP_DB_STATEMENT = "db.statement";
    TMP_DB_OPERATION = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
    TMP_DB_SQL_TABLE = "db.sql.table";
    TMP_EXCEPTION_TYPE = "exception.type";
    TMP_EXCEPTION_MESSAGE = "exception.message";
    TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED = "exception.escaped";
    TMP_FAAS_TRIGGER = "faas.trigger";
    TMP_FAAS_EXECUTION = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
    TMP_FAAS_TIME = "faas.time";
    TMP_FAAS_CRON = "faas.cron";
    TMP_FAAS_COLDSTART = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
    TMP_NET_TRANSPORT = "net.transport";
    TMP_NET_PEER_IP = "net.peer.ip";
    TMP_NET_PEER_PORT = "net.peer.port";
    TMP_NET_PEER_NAME = "net.peer.name";
    TMP_NET_HOST_IP = "net.host.ip";
    TMP_NET_HOST_PORT = "net.host.port";
    TMP_NET_HOST_NAME = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
    TMP_PEER_SERVICE = "peer.service";
    TMP_ENDUSER_ID = "enduser.id";
    TMP_ENDUSER_ROLE = "enduser.role";
    TMP_ENDUSER_SCOPE = "enduser.scope";
    TMP_THREAD_ID = "thread.id";
    TMP_THREAD_NAME = "thread.name";
    TMP_CODE_FUNCTION = "code.function";
    TMP_CODE_NAMESPACE = "code.namespace";
    TMP_CODE_FILEPATH = "code.filepath";
    TMP_CODE_LINENO = "code.lineno";
    TMP_HTTP_METHOD = "http.method";
    TMP_HTTP_URL = "http.url";
    TMP_HTTP_TARGET = "http.target";
    TMP_HTTP_HOST = "http.host";
    TMP_HTTP_SCHEME = "http.scheme";
    TMP_HTTP_STATUS_CODE = "http.status_code";
    TMP_HTTP_FLAVOR = "http.flavor";
    TMP_HTTP_USER_AGENT = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME = "http.server_name";
    TMP_HTTP_ROUTE = "http.route";
    TMP_HTTP_CLIENT_IP = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM = "messaging.system";
    TMP_MESSAGING_DESTINATION = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
    TMP_MESSAGING_URL = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM = "rpc.system";
    TMP_RPC_SERVICE = "rpc.service";
    TMP_RPC_METHOD = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE = "message.type";
    TMP_MESSAGE_ID = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
    SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
    SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
    SEMATTRS_DB_USER = TMP_DB_USER;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
    SEMATTRS_DB_NAME = TMP_DB_NAME;
    SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
    SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
    SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
    SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
    SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
    SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
    SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
    SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
    SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
    SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
    SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
    SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
    SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
    SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
    SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
    SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
    SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
    SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
    SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
    SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
    SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
    SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
    SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
    SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
    SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
    SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
    SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
    SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
    SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
    SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
    SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
    SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
    SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
    SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
    SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
    SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
    SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
    SEMATTRS_THREAD_ID = TMP_THREAD_ID;
    SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
    SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
    SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
    SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
    SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
    SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
    SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
    SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
    SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
    SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
    SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
    SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
    SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
    SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
    SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
    SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
    SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
    SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
    SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
    SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
    SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
    SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
    SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
    SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
    SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
    SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
    SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
    SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
    SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
    SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
    SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
    SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
    SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
    SemanticAttributes = /* @__PURE__ */ createConstMap([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE = "oracle";
    TMP_DBSYSTEMVALUES_DB2 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
    TMP_DBSYSTEMVALUES_HIVE = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS = "progress";
    TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
    TMP_DBSYSTEMVALUES_EDB = "edb";
    TMP_DBSYSTEMVALUES_CACHE = "cache";
    TMP_DBSYSTEMVALUES_ADABAS = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
    TMP_DBSYSTEMVALUES_DERBY = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA = "vertica";
    TMP_DBSYSTEMVALUES_H2 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
    DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
    DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
    DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
    DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
    DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
    DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
    DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
    DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
    DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
    DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
    DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
    DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
    DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
    DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
    DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
    DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
    DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
    DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
    DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
    DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
    DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
    DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
    DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
    DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
    DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
    DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
    DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
    DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
    DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
    DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
    DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
    DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
    DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
    DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
    DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
    DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
    DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
    DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
    DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
    DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
    DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
    DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
    DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
    DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
    DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
    DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
    DbSystemValues = /* @__PURE__ */ createConstMap([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
    DbCassandraConsistencyLevelValues = /* @__PURE__ */ createConstMap([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER = "timer";
    TMP_FAASTRIGGERVALUES_OTHER = "other";
    FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
    FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
    FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
    FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
    FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
    FaasTriggerValues = /* @__PURE__ */ createConstMap([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
    FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
    FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
    FaasDocumentOperationValues = /* @__PURE__ */ createConstMap([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
    FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
    FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
    FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
    FaasInvokedProviderValues = /* @__PURE__ */ createConstMap([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP = "ip";
    TMP_NETTRANSPORTVALUES_UNIX = "unix";
    TMP_NETTRANSPORTVALUES_PIPE = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER = "other";
    NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
    NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
    NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
    NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
    NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
    NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
    NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
    NetTransportValues = /* @__PURE__ */ createConstMap([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
    NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
    NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
    NetHostConnectionTypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
    NetHostConnectionSubtypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
    HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
    HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
    HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
    HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
    HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
    MessagingDestinationKindValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
    MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
    MessagingOperationValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
    RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
    RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
    RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
    RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
    RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    };
    TMP_MESSAGETYPEVALUES_SENT = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
    MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
    MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
    MessageTypeValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace2 = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes();
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER, TMP_CLOUD_ACCOUNT_ID, TMP_CLOUD_REGION, TMP_CLOUD_AVAILABILITY_ZONE, TMP_CLOUD_PLATFORM, TMP_AWS_ECS_CONTAINER_ARN, TMP_AWS_ECS_CLUSTER_ARN, TMP_AWS_ECS_LAUNCHTYPE, TMP_AWS_ECS_TASK_ARN, TMP_AWS_ECS_TASK_FAMILY, TMP_AWS_ECS_TASK_REVISION, TMP_AWS_EKS_CLUSTER_ARN, TMP_AWS_LOG_GROUP_NAMES, TMP_AWS_LOG_GROUP_ARNS, TMP_AWS_LOG_STREAM_NAMES, TMP_AWS_LOG_STREAM_ARNS, TMP_CONTAINER_NAME, TMP_CONTAINER_ID, TMP_CONTAINER_RUNTIME, TMP_CONTAINER_IMAGE_NAME, TMP_CONTAINER_IMAGE_TAG, TMP_DEPLOYMENT_ENVIRONMENT, TMP_DEVICE_ID, TMP_DEVICE_MODEL_IDENTIFIER, TMP_DEVICE_MODEL_NAME, TMP_FAAS_NAME, TMP_FAAS_ID, TMP_FAAS_VERSION, TMP_FAAS_INSTANCE, TMP_FAAS_MAX_MEMORY, TMP_HOST_ID, TMP_HOST_NAME, TMP_HOST_TYPE, TMP_HOST_ARCH, TMP_HOST_IMAGE_NAME, TMP_HOST_IMAGE_ID, TMP_HOST_IMAGE_VERSION, TMP_K8S_CLUSTER_NAME, TMP_K8S_NODE_NAME, TMP_K8S_NODE_UID, TMP_K8S_NAMESPACE_NAME, TMP_K8S_POD_UID, TMP_K8S_POD_NAME, TMP_K8S_CONTAINER_NAME, TMP_K8S_REPLICASET_UID, TMP_K8S_REPLICASET_NAME, TMP_K8S_DEPLOYMENT_UID, TMP_K8S_DEPLOYMENT_NAME, TMP_K8S_STATEFULSET_UID, TMP_K8S_STATEFULSET_NAME, TMP_K8S_DAEMONSET_UID, TMP_K8S_DAEMONSET_NAME, TMP_K8S_JOB_UID, TMP_K8S_JOB_NAME, TMP_K8S_CRONJOB_UID, TMP_K8S_CRONJOB_NAME, TMP_OS_TYPE, TMP_OS_DESCRIPTION, TMP_OS_NAME, TMP_OS_VERSION, TMP_PROCESS_PID, TMP_PROCESS_EXECUTABLE_NAME, TMP_PROCESS_EXECUTABLE_PATH, TMP_PROCESS_COMMAND, TMP_PROCESS_COMMAND_LINE, TMP_PROCESS_COMMAND_ARGS, TMP_PROCESS_OWNER, TMP_PROCESS_RUNTIME_NAME, TMP_PROCESS_RUNTIME_VERSION, TMP_PROCESS_RUNTIME_DESCRIPTION, TMP_SERVICE_NAME, TMP_SERVICE_NAMESPACE, TMP_SERVICE_INSTANCE_ID, TMP_SERVICE_VERSION, TMP_TELEMETRY_SDK_NAME, TMP_TELEMETRY_SDK_LANGUAGE, TMP_TELEMETRY_SDK_VERSION, TMP_TELEMETRY_AUTO_VERSION, TMP_WEBENGINE_NAME, TMP_WEBENGINE_VERSION, TMP_WEBENGINE_DESCRIPTION, SEMRESATTRS_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME, SEMRESATTRS_FAAS_ID, SEMRESATTRS_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID, SEMRESATTRS_HOST_NAME, SEMRESATTRS_HOST_TYPE, SEMRESATTRS_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION, SEMRESATTRS_OS_NAME, SEMRESATTRS_OS_VERSION, SEMRESATTRS_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION, SemanticResourceAttributes, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, TMP_CLOUDPROVIDERVALUES_AWS, TMP_CLOUDPROVIDERVALUES_AZURE, TMP_CLOUDPROVIDERVALUES_GCP, CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP, CloudProviderValues, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, TMP_CLOUDPLATFORMVALUES_AWS_EC2, TMP_CLOUDPLATFORMVALUES_AWS_ECS, TMP_CLOUDPLATFORMVALUES_AWS_EKS, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, TMP_CLOUDPLATFORMVALUES_AZURE_VM, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, TMP_CLOUDPLATFORMVALUES_AZURE_AKS, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues, TMP_AWSECSLAUNCHTYPEVALUES_EC2, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues, TMP_HOSTARCHVALUES_AMD64, TMP_HOSTARCHVALUES_ARM32, TMP_HOSTARCHVALUES_ARM64, TMP_HOSTARCHVALUES_IA64, TMP_HOSTARCHVALUES_PPC32, TMP_HOSTARCHVALUES_PPC64, TMP_HOSTARCHVALUES_X86, HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86, HostArchValues, TMP_OSTYPEVALUES_WINDOWS, TMP_OSTYPEVALUES_LINUX, TMP_OSTYPEVALUES_DARWIN, TMP_OSTYPEVALUES_FREEBSD, TMP_OSTYPEVALUES_NETBSD, TMP_OSTYPEVALUES_OPENBSD, TMP_OSTYPEVALUES_DRAGONFLYBSD, TMP_OSTYPEVALUES_HPUX, TMP_OSTYPEVALUES_AIX, TMP_OSTYPEVALUES_SOLARIS, TMP_OSTYPEVALUES_Z_OS, OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS, OsTypeValues, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues;
var init_SemanticResourceAttributes = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils3();
    TMP_CLOUD_PROVIDER = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
    TMP_CLOUD_REGION = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
    TMP_CONTAINER_NAME = "container.name";
    TMP_CONTAINER_ID = "container.id";
    TMP_CONTAINER_RUNTIME = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
    TMP_DEVICE_ID = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME = "device.model.name";
    TMP_FAAS_NAME = "faas.name";
    TMP_FAAS_ID = "faas.id";
    TMP_FAAS_VERSION = "faas.version";
    TMP_FAAS_INSTANCE = "faas.instance";
    TMP_FAAS_MAX_MEMORY = "faas.max_memory";
    TMP_HOST_ID = "host.id";
    TMP_HOST_NAME = "host.name";
    TMP_HOST_TYPE = "host.type";
    TMP_HOST_ARCH = "host.arch";
    TMP_HOST_IMAGE_NAME = "host.image.name";
    TMP_HOST_IMAGE_ID = "host.image.id";
    TMP_HOST_IMAGE_VERSION = "host.image.version";
    TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
    TMP_K8S_NODE_NAME = "k8s.node.name";
    TMP_K8S_NODE_UID = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
    TMP_K8S_POD_UID = "k8s.pod.uid";
    TMP_K8S_POD_NAME = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME = "k8s.container.name";
    TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
    TMP_K8S_JOB_UID = "k8s.job.uid";
    TMP_K8S_JOB_NAME = "k8s.job.name";
    TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
    TMP_OS_TYPE = "os.type";
    TMP_OS_DESCRIPTION = "os.description";
    TMP_OS_NAME = "os.name";
    TMP_OS_VERSION = "os.version";
    TMP_PROCESS_PID = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
    TMP_PROCESS_COMMAND = "process.command";
    TMP_PROCESS_COMMAND_LINE = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS = "process.command_args";
    TMP_PROCESS_OWNER = "process.owner";
    TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
    TMP_SERVICE_NAME = "service.name";
    TMP_SERVICE_NAMESPACE = "service.namespace";
    TMP_SERVICE_INSTANCE_ID = "service.instance.id";
    TMP_SERVICE_VERSION = "service.version";
    TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
    TMP_WEBENGINE_NAME = "webengine.name";
    TMP_WEBENGINE_VERSION = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
    SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
    SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
    SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
    SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
    SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
    SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
    SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
    SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
    SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
    SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
    SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
    SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
    SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
    SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
    SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
    SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
    SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
    SEMRESATTRS_HOST_ID = TMP_HOST_ID;
    SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
    SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
    SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
    SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
    SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
    SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
    SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
    SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
    SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
    SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
    SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
    SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
    SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
    SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
    SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
    SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
    SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
    SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
    SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
    SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
    SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
    SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
    SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
    SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
    SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
    SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
    SEMRESATTRS_OS_NAME = TMP_OS_NAME;
    SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
    SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
    SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
    SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
    SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
    SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
    SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
    SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
    SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
    SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
    SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
    SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
    SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
    SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
    SemanticResourceAttributes = /* @__PURE__ */ createConstMap([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
    CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
    CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
    CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
    CloudProviderValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
    CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
    CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
    CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
    CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
    CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
    CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
    CloudPlatformValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
    AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
    AwsEcsLaunchtypeValues = /* @__PURE__ */ createConstMap([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]);
    TMP_HOSTARCHVALUES_AMD64 = "amd64";
    TMP_HOSTARCHVALUES_ARM32 = "arm32";
    TMP_HOSTARCHVALUES_ARM64 = "arm64";
    TMP_HOSTARCHVALUES_IA64 = "ia64";
    TMP_HOSTARCHVALUES_PPC32 = "ppc32";
    TMP_HOSTARCHVALUES_PPC64 = "ppc64";
    TMP_HOSTARCHVALUES_X86 = "x86";
    HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
    HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
    HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
    HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
    HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
    HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
    HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
    HostArchValues = /* @__PURE__ */ createConstMap([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]);
    TMP_OSTYPEVALUES_WINDOWS = "windows";
    TMP_OSTYPEVALUES_LINUX = "linux";
    TMP_OSTYPEVALUES_DARWIN = "darwin";
    TMP_OSTYPEVALUES_FREEBSD = "freebsd";
    TMP_OSTYPEVALUES_NETBSD = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX = "hpux";
    TMP_OSTYPEVALUES_AIX = "aix";
    TMP_OSTYPEVALUES_SOLARIS = "solaris";
    TMP_OSTYPEVALUES_Z_OS = "z_os";
    OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
    OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
    OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
    OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
    OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
    OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
    OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
    OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
    OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
    OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
    OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
    OsTypeValues = /* @__PURE__ */ createConstMap([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
    TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
    TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
    TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
    TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
    TelemetrySdkLanguageValues = /* @__PURE__ */ createConstMap([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes();
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED, ATTR_TELEMETRY_SDK_LANGUAGE, TELEMETRY_SDK_LANGUAGE_VALUE_CPP, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG, TELEMETRY_SDK_LANGUAGE_VALUE_GO, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS, TELEMETRY_SDK_LANGUAGE_VALUE_PHP, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY, TELEMETRY_SDK_LANGUAGE_VALUE_RUST, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED, ATTR_ASPNETCORE_RATE_LIMITING_POLICY, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS, ATTR_CLIENT_ADDRESS, ATTR_CLIENT_PORT, ATTR_ERROR_TYPE, ERROR_TYPE_VALUE_OTHER, ATTR_EXCEPTION_ESCAPED, ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_TYPE, ATTR_HTTP_REQUEST_HEADER, ATTR_HTTP_REQUEST_METHOD, HTTP_REQUEST_METHOD_VALUE_OTHER, HTTP_REQUEST_METHOD_VALUE_CONNECT, HTTP_REQUEST_METHOD_VALUE_DELETE, HTTP_REQUEST_METHOD_VALUE_GET, HTTP_REQUEST_METHOD_VALUE_HEAD, HTTP_REQUEST_METHOD_VALUE_OPTIONS, HTTP_REQUEST_METHOD_VALUE_PATCH, HTTP_REQUEST_METHOD_VALUE_POST, HTTP_REQUEST_METHOD_VALUE_PUT, HTTP_REQUEST_METHOD_VALUE_TRACE, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_REQUEST_RESEND_COUNT, ATTR_HTTP_RESPONSE_HEADER, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_HTTP_ROUTE, ATTR_JVM_GC_ACTION, ATTR_JVM_GC_NAME, ATTR_JVM_MEMORY_POOL_NAME, ATTR_JVM_MEMORY_TYPE, JVM_MEMORY_TYPE_VALUE_HEAP, JVM_MEMORY_TYPE_VALUE_NON_HEAP, ATTR_JVM_THREAD_DAEMON, ATTR_JVM_THREAD_STATE, JVM_THREAD_STATE_VALUE_BLOCKED, JVM_THREAD_STATE_VALUE_NEW, JVM_THREAD_STATE_VALUE_RUNNABLE, JVM_THREAD_STATE_VALUE_TERMINATED, JVM_THREAD_STATE_VALUE_TIMED_WAITING, JVM_THREAD_STATE_VALUE_WAITING, ATTR_NETWORK_LOCAL_ADDRESS, ATTR_NETWORK_LOCAL_PORT, ATTR_NETWORK_PEER_ADDRESS, ATTR_NETWORK_PEER_PORT, ATTR_NETWORK_PROTOCOL_NAME, ATTR_NETWORK_PROTOCOL_VERSION, ATTR_NETWORK_TRANSPORT, NETWORK_TRANSPORT_VALUE_PIPE, NETWORK_TRANSPORT_VALUE_QUIC, NETWORK_TRANSPORT_VALUE_TCP, NETWORK_TRANSPORT_VALUE_UDP, NETWORK_TRANSPORT_VALUE_UNIX, ATTR_NETWORK_TYPE, NETWORK_TYPE_VALUE_IPV4, NETWORK_TYPE_VALUE_IPV6, ATTR_OTEL_SCOPE_NAME, ATTR_OTEL_SCOPE_VERSION, ATTR_OTEL_STATUS_CODE, OTEL_STATUS_CODE_VALUE_ERROR, OTEL_STATUS_CODE_VALUE_OK, ATTR_OTEL_STATUS_DESCRIPTION, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION, ATTR_SIGNALR_CONNECTION_STATUS, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT, ATTR_SIGNALR_TRANSPORT, SIGNALR_TRANSPORT_VALUE_LONG_POLLING, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS, ATTR_URL_FRAGMENT, ATTR_URL_FULL, ATTR_URL_PATH, ATTR_URL_QUERY, ATTR_URL_SCHEME, ATTR_USER_AGENT_ORIGINAL;
var init_stable_attributes = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
    ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
    ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
    ATTR_CLIENT_ADDRESS = "client.address";
    ATTR_CLIENT_PORT = "client.port";
    ATTR_ERROR_TYPE = "error.type";
    ERROR_TYPE_VALUE_OTHER = "_OTHER";
    ATTR_EXCEPTION_ESCAPED = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE = "exception.message";
    ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE = "exception.type";
    ATTR_HTTP_REQUEST_HEADER = function(key) {
      return "http.request.header." + key;
    };
    ATTR_HTTP_REQUEST_METHOD = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER = function(key) {
      return "http.response.header." + key;
    };
    ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
    ATTR_HTTP_ROUTE = "http.route";
    ATTR_JVM_GC_ACTION = "jvm.gc.action";
    ATTR_JVM_GC_NAME = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
    ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
    JVM_THREAD_STATE_VALUE_NEW = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
    ATTR_NETWORK_PEER_PORT = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC = "quic";
    NETWORK_TRANSPORT_VALUE_TCP = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX = "unix";
    ATTR_NETWORK_TYPE = "network.type";
    NETWORK_TYPE_VALUE_IPV4 = "ipv4";
    NETWORK_TYPE_VALUE_IPV6 = "ipv6";
    ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
    ATTR_SERVER_ADDRESS = "server.address";
    ATTR_SERVER_PORT = "server.port";
    ATTR_SERVICE_NAME = "service.name";
    ATTR_SERVICE_VERSION = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
    ATTR_SIGNALR_TRANSPORT = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
    ATTR_URL_FRAGMENT = "url.fragment";
    ATTR_URL_FULL = "url.full";
    ATTR_URL_PATH = "url.path";
    ATTR_URL_QUERY = "url.query";
    ATTR_URL_SCHEME = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS, METRIC_HTTP_CLIENT_REQUEST_DURATION, METRIC_HTTP_SERVER_REQUEST_DURATION, METRIC_JVM_CLASS_COUNT, METRIC_JVM_CLASS_LOADED, METRIC_JVM_CLASS_UNLOADED, METRIC_JVM_CPU_COUNT, METRIC_JVM_CPU_RECENT_UTILIZATION, METRIC_JVM_CPU_TIME, METRIC_JVM_GC_DURATION, METRIC_JVM_MEMORY_COMMITTED, METRIC_JVM_MEMORY_LIMIT, METRIC_JVM_MEMORY_USED, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC, METRIC_JVM_THREAD_COUNT, METRIC_KESTREL_ACTIVE_CONNECTIONS, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES, METRIC_KESTREL_CONNECTION_DURATION, METRIC_KESTREL_QUEUED_CONNECTIONS, METRIC_KESTREL_QUEUED_REQUESTS, METRIC_KESTREL_REJECTED_CONNECTIONS, METRIC_KESTREL_TLS_HANDSHAKE_DURATION, METRIC_KESTREL_UPGRADED_CONNECTIONS, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS, METRIC_SIGNALR_SERVER_CONNECTION_DURATION;
var init_stable_metrics = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
    METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
  }
});

// node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT,
  ATTR_URL_FULL: () => ATTR_URL_FULL,
  ATTR_URL_PATH: () => ATTR_URL_PATH,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC2,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC2,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP,
  CloudPlatformValues: () => CloudPlatformValues,
  CloudProviderValues: () => CloudProviderValues,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB2,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H2,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues,
  DbSystemValues: () => DbSystemValues,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues,
  FaasTriggerValues: () => FaasTriggerValues,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD64,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM32,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM64,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA64,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC32,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC64,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X86,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_0,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_1,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_0,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE,
  HostArchValues: () => HostArchValues,
  HttpFlavorValues: () => HttpFlavorValues,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION,
  MessageTypeValues: () => MessageTypeValues,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues,
  MessagingOperationValues: () => MessagingOperationValues,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV4,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV6,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues,
  NetTransportValues: () => NetTransportValues,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK,
  OsTypeValues: () => OsTypeValues,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS,
  SemanticAttributes: () => SemanticAttributes,
  SemanticResourceAttributes: () => SemanticResourceAttributes,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues
});
var init_esm2 = __esm({
  "node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace2();
    init_resource();
    init_stable_attributes();
    init_stable_metrics();
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDK_INFO = void 0;
    var version_1 = require_version();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    exports2.SDK_INFO = {
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports2.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = exports2.SDK_INFO = exports2.otperformance = exports2.RandomIdGenerator = exports2.hexToBase64 = exports2._globalThis = exports2.getEnv = exports2.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment2();
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    var globalThis_1 = require_globalThis();
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return globalThis_1._globalThis;
    } });
    var hex_to_base64_1 = require_hex_to_base64();
    Object.defineProperty(exports2, "hexToBase64", { enumerable: true, get: function() {
      return hex_to_base64_1.hexToBase64;
    } });
    var RandomIdGenerator_1 = require_RandomIdGenerator();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return RandomIdGenerator_1.RandomIdGenerator;
    } });
    var performance_1 = require_performance();
    Object.defineProperty(exports2, "otperformance", { enumerable: true, get: function() {
      return performance_1.otperformance;
    } });
    var sdk_info_1 = require_sdk_info();
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: true, get: function() {
      return sdk_info_1.SDK_INFO;
    } });
    var timer_util_1 = require_timer_util();
    Object.defineProperty(exports2, "unrefTimer", { enumerable: true, get: function() {
      return timer_util_1.unrefTimer;
    } });
  }
});

// node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = exports2.otperformance = exports2.hexToBase64 = exports2.getEnvWithoutDefaults = exports2.getEnv = exports2._globalThis = exports2.SDK_INFO = exports2.RandomIdGenerator = void 0;
    var node_1 = require_node();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return node_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: true, get: function() {
      return node_1.SDK_INFO;
    } });
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return node_1._globalThis;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return node_1.getEnv;
    } });
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return node_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "hexToBase64", { enumerable: true, get: function() {
      return node_1.hexToBase64;
    } });
    Object.defineProperty(exports2, "otperformance", { enumerable: true, get: function() {
      return node_1.otperformance;
    } });
    Object.defineProperty(exports2, "unrefTimer", { enumerable: true, get: function() {
      return node_1.unrefTimer;
    } });
  }
});

// node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addHrTimes = exports2.isTimeInput = exports2.isTimeInputHrTime = exports2.hrTimeToMicroseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToNanoseconds = exports2.hrTimeToTimeStamp = exports2.hrTimeDuration = exports2.timeInputToHrTime = exports2.hrTime = exports2.getTimeOrigin = exports2.millisToHrTime = void 0;
    var platform_1 = require_platform();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports2.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports2.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports2.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports2.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports2.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substring(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports2.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports2.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports2.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports2.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports2.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports2.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports2.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports2.ExportResultCode || (exports2.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config2 = {}) {
        var _a;
        this._propagators = (_a = config2.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports2.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports2.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports2.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceState = void 0;
    var validators_1 = require_validators();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState2 = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceState = TraceState2;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CTraceContextPropagator = exports2.parseTraceParent = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var TraceState_1 = require_TraceState();
    exports2.TRACE_PARENT_HEADER = "traceparent";
    exports2.TRACE_STATE_HEADER = "tracestate";
    var VERSION5 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports2.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION5}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports2.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports2.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports2.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports2.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports2.TRACE_PARENT_HEADER, exports2.TRACE_STATE_HEADER];
      }
    };
    exports2.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.setRPCMetadata = exports2.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType2;
    (function(RPCType3) {
      RPCType3["HTTP"] = "http";
    })(RPCType2 = exports2.RPCType || (exports2.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports2.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports2.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata2(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports2.getRPCMetadata = getRPCMetadata2;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    var ParentBasedSampler = class {
      constructor(config2) {
        var _a, _b, _c, _d;
        this._root = config2.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config2.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config2.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          const pos = i * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports2.isPlainObject = isPlainObject2;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      const result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lodash_merge_1 = require_lodash_merge();
    var MAX_LEVEL = 20;
    function merge2(...args) {
      let result = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    exports2.merge = merge2;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive2(one) || isPrimitive2(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (let i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            const twoValue = two[key];
            if (isPrimitive2(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              const obj1 = result[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        const info = arr[i];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive2(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive2(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callWithTimeout = exports2.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUrlIgnored = exports2.urlMatches = void 0;
    function urlMatches(url2, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url2 === urlToMatch;
      } else {
        return !!url2.match(urlToMatch);
      }
    }
    exports2.urlMatches = urlMatches;
    function isUrlIgnored(url2, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url2, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports2.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWrapped = void 0;
    function isWrapped3(func) {
      return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
    }
    exports2.isWrapped = isWrapped3;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve2, reject) => {
          this._resolve = resolve2;
          this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BindOnceFuture = void 0;
    var promise_1 = require_promise();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports2.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve2) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve2(result);
          });
        });
      });
    }
    exports2._export = _export;
  }
});

// node_modules/@opentelemetry/core/build/src/index.js
var require_src = __commonJS({
  "node_modules/@opentelemetry/core/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.TraceState = exports2.unsuppressTracing = exports2.suppressTracing = exports2.isTracingSuppressed = exports2.TraceIdRatioBasedSampler = exports2.ParentBasedSampler = exports2.AlwaysOnSampler = exports2.AlwaysOffSampler = exports2.setRPCMetadata = exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.RPCType = exports2.parseTraceParent = exports2.W3CTraceContextPropagator = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = exports2.CompositePropagator = exports2.unrefTimer = exports2.otperformance = exports2.hexToBase64 = exports2.getEnvWithoutDefaults = exports2.getEnv = exports2._globalThis = exports2.SDK_INFO = exports2.RandomIdGenerator = exports2.baggageUtils = exports2.ExportResultCode = exports2.hexToBinary = exports2.timeInputToHrTime = exports2.millisToHrTime = exports2.isTimeInputHrTime = exports2.isTimeInput = exports2.hrTimeToTimeStamp = exports2.hrTimeToNanoseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToMicroseconds = exports2.hrTimeDuration = exports2.hrTime = exports2.getTimeOrigin = exports2.addHrTimes = exports2.loggingErrorHandler = exports2.setGlobalErrorHandler = exports2.globalErrorHandler = exports2.sanitizeAttributes = exports2.isAttributeValue = exports2.isAttributeKey = exports2.AnchoredClock = exports2.W3CBaggagePropagator = void 0;
    exports2.internal = exports2.VERSION = exports2.BindOnceFuture = exports2.isWrapped = exports2.urlMatches = exports2.isUrlIgnored = exports2.callWithTimeout = exports2.TimeoutError = exports2.TracesSamplerValues = exports2.merge = exports2.parseEnvironment = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ENVIRONMENT = void 0;
    var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
    Object.defineProperty(exports2, "W3CBaggagePropagator", { enumerable: true, get: function() {
      return W3CBaggagePropagator_1.W3CBaggagePropagator;
    } });
    var anchored_clock_1 = require_anchored_clock();
    Object.defineProperty(exports2, "AnchoredClock", { enumerable: true, get: function() {
      return anchored_clock_1.AnchoredClock;
    } });
    var attributes_1 = require_attributes();
    Object.defineProperty(exports2, "isAttributeKey", { enumerable: true, get: function() {
      return attributes_1.isAttributeKey;
    } });
    Object.defineProperty(exports2, "isAttributeValue", { enumerable: true, get: function() {
      return attributes_1.isAttributeValue;
    } });
    Object.defineProperty(exports2, "sanitizeAttributes", { enumerable: true, get: function() {
      return attributes_1.sanitizeAttributes;
    } });
    var global_error_handler_1 = require_global_error_handler();
    Object.defineProperty(exports2, "globalErrorHandler", { enumerable: true, get: function() {
      return global_error_handler_1.globalErrorHandler;
    } });
    Object.defineProperty(exports2, "setGlobalErrorHandler", { enumerable: true, get: function() {
      return global_error_handler_1.setGlobalErrorHandler;
    } });
    var logging_error_handler_1 = require_logging_error_handler();
    Object.defineProperty(exports2, "loggingErrorHandler", { enumerable: true, get: function() {
      return logging_error_handler_1.loggingErrorHandler;
    } });
    var time_1 = require_time();
    Object.defineProperty(exports2, "addHrTimes", { enumerable: true, get: function() {
      return time_1.addHrTimes;
    } });
    Object.defineProperty(exports2, "getTimeOrigin", { enumerable: true, get: function() {
      return time_1.getTimeOrigin;
    } });
    Object.defineProperty(exports2, "hrTime", { enumerable: true, get: function() {
      return time_1.hrTime;
    } });
    Object.defineProperty(exports2, "hrTimeDuration", { enumerable: true, get: function() {
      return time_1.hrTimeDuration;
    } });
    Object.defineProperty(exports2, "hrTimeToMicroseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToMicroseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToMilliseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToMilliseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToNanoseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToNanoseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToTimeStamp", { enumerable: true, get: function() {
      return time_1.hrTimeToTimeStamp;
    } });
    Object.defineProperty(exports2, "isTimeInput", { enumerable: true, get: function() {
      return time_1.isTimeInput;
    } });
    Object.defineProperty(exports2, "isTimeInputHrTime", { enumerable: true, get: function() {
      return time_1.isTimeInputHrTime;
    } });
    Object.defineProperty(exports2, "millisToHrTime", { enumerable: true, get: function() {
      return time_1.millisToHrTime;
    } });
    Object.defineProperty(exports2, "timeInputToHrTime", { enumerable: true, get: function() {
      return time_1.timeInputToHrTime;
    } });
    var hex_to_binary_1 = require_hex_to_binary();
    Object.defineProperty(exports2, "hexToBinary", { enumerable: true, get: function() {
      return hex_to_binary_1.hexToBinary;
    } });
    var ExportResult_1 = require_ExportResult();
    Object.defineProperty(exports2, "ExportResultCode", { enumerable: true, get: function() {
      return ExportResult_1.ExportResultCode;
    } });
    var utils_1 = require_utils();
    exports2.baggageUtils = {
      getKeyPairs: utils_1.getKeyPairs,
      serializeKeyPairs: utils_1.serializeKeyPairs,
      parseKeyPairsIntoRecord: utils_1.parseKeyPairsIntoRecord,
      parsePairKeyValue: utils_1.parsePairKeyValue
    };
    var platform_1 = require_platform();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return platform_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: true, get: function() {
      return platform_1.SDK_INFO;
    } });
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return platform_1._globalThis;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return platform_1.getEnv;
    } });
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return platform_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "hexToBase64", { enumerable: true, get: function() {
      return platform_1.hexToBase64;
    } });
    Object.defineProperty(exports2, "otperformance", { enumerable: true, get: function() {
      return platform_1.otperformance;
    } });
    Object.defineProperty(exports2, "unrefTimer", { enumerable: true, get: function() {
      return platform_1.unrefTimer;
    } });
    var composite_1 = require_composite();
    Object.defineProperty(exports2, "CompositePropagator", { enumerable: true, get: function() {
      return composite_1.CompositePropagator;
    } });
    var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
    Object.defineProperty(exports2, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
    } });
    Object.defineProperty(exports2, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
    } });
    Object.defineProperty(exports2, "W3CTraceContextPropagator", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
    } });
    Object.defineProperty(exports2, "parseTraceParent", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.parseTraceParent;
    } });
    var rpc_metadata_1 = require_rpc_metadata();
    Object.defineProperty(exports2, "RPCType", { enumerable: true, get: function() {
      return rpc_metadata_1.RPCType;
    } });
    Object.defineProperty(exports2, "deleteRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.deleteRPCMetadata;
    } });
    Object.defineProperty(exports2, "getRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.getRPCMetadata;
    } });
    Object.defineProperty(exports2, "setRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.setRPCMetadata;
    } });
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    Object.defineProperty(exports2, "AlwaysOffSampler", { enumerable: true, get: function() {
      return AlwaysOffSampler_1.AlwaysOffSampler;
    } });
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    Object.defineProperty(exports2, "AlwaysOnSampler", { enumerable: true, get: function() {
      return AlwaysOnSampler_1.AlwaysOnSampler;
    } });
    var ParentBasedSampler_1 = require_ParentBasedSampler();
    Object.defineProperty(exports2, "ParentBasedSampler", { enumerable: true, get: function() {
      return ParentBasedSampler_1.ParentBasedSampler;
    } });
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
    Object.defineProperty(exports2, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
      return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
    } });
    var suppress_tracing_1 = require_suppress_tracing();
    Object.defineProperty(exports2, "isTracingSuppressed", { enumerable: true, get: function() {
      return suppress_tracing_1.isTracingSuppressed;
    } });
    Object.defineProperty(exports2, "suppressTracing", { enumerable: true, get: function() {
      return suppress_tracing_1.suppressTracing;
    } });
    Object.defineProperty(exports2, "unsuppressTracing", { enumerable: true, get: function() {
      return suppress_tracing_1.unsuppressTracing;
    } });
    var TraceState_1 = require_TraceState();
    Object.defineProperty(exports2, "TraceState", { enumerable: true, get: function() {
      return TraceState_1.TraceState;
    } });
    var environment_1 = require_environment();
    Object.defineProperty(exports2, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_ENVIRONMENT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ENVIRONMENT;
    } });
    Object.defineProperty(exports2, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "parseEnvironment", { enumerable: true, get: function() {
      return environment_1.parseEnvironment;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var sampling_1 = require_sampling();
    Object.defineProperty(exports2, "TracesSamplerValues", { enumerable: true, get: function() {
      return sampling_1.TracesSamplerValues;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    Object.defineProperty(exports2, "callWithTimeout", { enumerable: true, get: function() {
      return timeout_1.callWithTimeout;
    } });
    var url_1 = require_url();
    Object.defineProperty(exports2, "isUrlIgnored", { enumerable: true, get: function() {
      return url_1.isUrlIgnored;
    } });
    Object.defineProperty(exports2, "urlMatches", { enumerable: true, get: function() {
      return url_1.urlMatches;
    } });
    var wrap_1 = require_wrap();
    Object.defineProperty(exports2, "isWrapped", { enumerable: true, get: function() {
      return wrap_1.isWrapped;
    } });
    var callback_1 = require_callback();
    Object.defineProperty(exports2, "BindOnceFuture", { enumerable: true, get: function() {
      return callback_1.BindOnceFuture;
    } });
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var exporter_1 = require_exporter();
    exports2.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug3;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug3 = require_debug();
    exports2 = module2.exports = {};
    var re2 = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug3(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug3 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re2, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug3("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug3("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug3("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug3("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release2, identifier, identifierBase) {
        if (release2.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release2) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release2}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release2, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release2, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major2 = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major2;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re2, t } = require_re();
    var coerce2 = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major2 = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major2}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce2;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug3("hyphen replace", range);
        range = range.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
        debug3("comparator trim", range);
        range = range.replace(re2[t.TILDETRIM], tildeTrimReplace);
        debug3("tilde trim", range);
        range = range.replace(re2[t.CARETTRIM], caretTrimReplace);
        debug3("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug3("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t.COMPARATORLOOSE]);
          });
        }
        debug3("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug3 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug3("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug3("caret", comp);
      comp = replaceTildes(comp, options);
      debug3("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug3("xrange", comp);
      comp = replaceStars(comp, options);
      debug3("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug3("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug3("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug3("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug3("caret", comp, options);
      const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug3("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug3("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug3("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug3("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug3("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug3("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug3("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug3("replaceStars", comp, options);
      return comp.trim().replace(re2[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug3("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug3(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug3("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug3("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug3("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t } = require_re();
    var cmp = require_cmp();
    var debug3 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major2 = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major: major2,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@opentelemetry/instrumentation-http/build/src/version.js
var require_version2 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-http/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "0.57.2";
  }
});

// node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SeverityNumber = void 0;
    var SeverityNumber;
    (function(SeverityNumber2) {
      SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
      SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
      SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
      SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
      SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
      SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
      SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
      SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
      SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
      SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
      SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
      SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
      SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
      SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
      SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
      SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
      SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
      SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
      SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
      SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
      SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
      SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
      SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
      SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
      SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
    })(SeverityNumber = exports2.SeverityNumber || (exports2.SeverityNumber = {}));
  }
});

// node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOOP_LOGGER = exports2.NoopLogger = void 0;
    var NoopLogger = class {
      emit(_logRecord) {
      }
    };
    exports2.NoopLogger = NoopLogger;
    exports2.NOOP_LOGGER = new NoopLogger();
  }
});

// node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOOP_LOGGER_PROVIDER = exports2.NoopLoggerProvider = void 0;
    var NoopLogger_1 = require_NoopLogger();
    var NoopLoggerProvider = class {
      getLogger(_name, _version, _options) {
        return new NoopLogger_1.NoopLogger();
      }
    };
    exports2.NoopLoggerProvider = NoopLoggerProvider;
    exports2.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();
  }
});

// node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js
var require_ProxyLogger = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyLogger = void 0;
    var NoopLogger_1 = require_NoopLogger();
    var ProxyLogger = class {
      constructor(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      /**
       * Emit a log record. This method should only be used by log appenders.
       *
       * @param logRecord
       */
      emit(logRecord) {
        this._getLogger().emit(logRecord);
      }
      /**
       * Try to get a logger from the proxy logger provider.
       * If the proxy logger provider has no delegate, return a noop logger.
       */
      _getLogger() {
        if (this._delegate) {
          return this._delegate;
        }
        const logger2 = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger2) {
          return NoopLogger_1.NOOP_LOGGER;
        }
        this._delegate = logger2;
        return this._delegate;
      }
    };
    exports2.ProxyLogger = ProxyLogger;
  }
});

// node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js
var require_ProxyLoggerProvider = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyLoggerProvider = void 0;
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    var ProxyLogger_1 = require_ProxyLogger();
    var ProxyLoggerProvider = class {
      getLogger(name, version, options) {
        var _a;
        return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger_1.ProxyLogger(this, name, version, options);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
      }
      /**
       * Set the delegate logger provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateLogger(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
      }
    };
    exports2.ProxyLoggerProvider = ProxyLoggerProvider;
  }
});

// node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    var globalThis_1 = require_globalThis2();
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return globalThis_1._globalThis;
    } });
  }
});

// node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform2 = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    var node_1 = require_node2();
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return node_1._globalThis;
    } });
  }
});

// node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.API_BACKWARDS_COMPATIBILITY_VERSION = exports2.makeGetter = exports2._global = exports2.GLOBAL_LOGS_API_KEY = void 0;
    var platform_1 = require_platform2();
    exports2.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
    exports2._global = platform_1._globalThis;
    function makeGetter(requiredVersion, instance, fallback) {
      return (version) => version === requiredVersion ? instance : fallback;
    }
    exports2.makeGetter = makeGetter;
    exports2.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
  }
});

// node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/api/logs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogsAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
    var LogsAPI = class _LogsAPI {
      constructor() {
        this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider();
      }
      static getInstance() {
        if (!this._instance) {
          this._instance = new _LogsAPI();
        }
        return this._instance;
      }
      setGlobalLoggerProvider(provider) {
        if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
          return this.getLoggerProvider();
        }
        global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
      }
      /**
       * Returns the global logger provider.
       *
       * @returns LoggerProvider
       */
      getLoggerProvider() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
      }
      /**
       * Returns a logger from the global logger provider.
       *
       * @returns Logger
       */
      getLogger(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
      }
      /** Remove the global logger provider */
      disable() {
        delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider();
      }
    };
    exports2.LogsAPI = LogsAPI;
  }
});

// node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@opentelemetry/api-logs/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logs = exports2.ProxyLoggerProvider = exports2.ProxyLogger = exports2.NoopLoggerProvider = exports2.NOOP_LOGGER_PROVIDER = exports2.NoopLogger = exports2.NOOP_LOGGER = exports2.SeverityNumber = void 0;
    var LogRecord_1 = require_LogRecord();
    Object.defineProperty(exports2, "SeverityNumber", { enumerable: true, get: function() {
      return LogRecord_1.SeverityNumber;
    } });
    var NoopLogger_1 = require_NoopLogger();
    Object.defineProperty(exports2, "NOOP_LOGGER", { enumerable: true, get: function() {
      return NoopLogger_1.NOOP_LOGGER;
    } });
    Object.defineProperty(exports2, "NoopLogger", { enumerable: true, get: function() {
      return NoopLogger_1.NoopLogger;
    } });
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    Object.defineProperty(exports2, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
      return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    } });
    Object.defineProperty(exports2, "NoopLoggerProvider", { enumerable: true, get: function() {
      return NoopLoggerProvider_1.NoopLoggerProvider;
    } });
    var ProxyLogger_1 = require_ProxyLogger();
    Object.defineProperty(exports2, "ProxyLogger", { enumerable: true, get: function() {
      return ProxyLogger_1.ProxyLogger;
    } });
    var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
    Object.defineProperty(exports2, "ProxyLoggerProvider", { enumerable: true, get: function() {
      return ProxyLoggerProvider_1.ProxyLoggerProvider;
    } });
    var logs_1 = require_logs();
    exports2.logs = logs_1.LogsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.disableInstrumentations = exports2.enableInstrumentations = void 0;
    function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
      for (let i = 0, j = instrumentations.length; i < j; i++) {
        const instrumentation = instrumentations[i];
        if (tracerProvider) {
          instrumentation.setTracerProvider(tracerProvider);
        }
        if (meterProvider) {
          instrumentation.setMeterProvider(meterProvider);
        }
        if (loggerProvider && instrumentation.setLoggerProvider) {
          instrumentation.setLoggerProvider(loggerProvider);
        }
        if (!instrumentation.getConfig().enabled) {
          instrumentation.enable();
        }
      }
    }
    exports2.enableInstrumentations = enableInstrumentations;
    function disableInstrumentations(instrumentations) {
      instrumentations.forEach((instrumentation) => instrumentation.disable());
    }
    exports2.disableInstrumentations = disableInstrumentations;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerInstrumentations = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var api_logs_1 = require_src2();
    var autoLoaderUtils_1 = require_autoLoaderUtils();
    function registerInstrumentations3(options) {
      var _a, _b;
      const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
      const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
      const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
      const instrumentations = (_b = (_a = options.instrumentations) === null || _a === void 0 ? void 0 : _a.flat()) !== null && _b !== void 0 ? _b : [];
      (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
      return () => {
        (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
      };
    }
    exports2.registerInstrumentations = registerInstrumentations3;
  }
});

// node_modules/shimmer/index.js
var require_shimmer = __commonJS({
  "node_modules/shimmer/index.js"(exports2, module2) {
    "use strict";
    function isFunction(funktion) {
      return typeof funktion === "function";
    }
    var logger2 = console.error.bind(console);
    function defineProperty2(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function shimmer(options) {
      if (options && options.logger) {
        if (!isFunction(options.logger)) logger2("new logger isn't a function, not replacing");
        else logger2 = options.logger;
      }
    }
    function wrap(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger2("no original function " + name + " to wrap");
        return;
      }
      if (!wrapper) {
        logger2("no wrapper function");
        logger2(new Error().stack);
        return;
      }
      if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
        logger2("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty2(wrapped, "__original", original);
      defineProperty2(wrapped, "__unwrap", function() {
        if (nodule[name] === wrapped) defineProperty2(nodule, name, original);
      });
      defineProperty2(wrapped, "__wrapped", true);
      defineProperty2(nodule, name, wrapped);
      return wrapped;
    }
    function massWrap(nodules, names, wrapper) {
      if (!nodules) {
        logger2("must provide one or more modules to patch");
        logger2(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger2("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          wrap(nodule, name, wrapper);
        });
      });
    }
    function unwrap(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger2("no function to unwrap.");
        logger2(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger2("no original to unwrap to -- has " + name + " already been unwrapped?");
      } else {
        return nodule[name].__unwrap();
      }
    }
    function massUnwrap(nodules, names) {
      if (!nodules) {
        logger2("must provide one or more modules to patch");
        logger2(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger2("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          unwrap(nodule, name);
        });
      });
    }
    shimmer.wrap = wrap;
    shimmer.massWrap = massWrap;
    shimmer.unwrap = unwrap;
    shimmer.massUnwrap = massUnwrap;
    module2.exports = shimmer;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstrumentationAbstract = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var api_logs_1 = require_src2();
    var shimmer = require_shimmer();
    var InstrumentationAbstract = class {
      constructor(instrumentationName, instrumentationVersion, config2) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this._config = {};
        this._wrap = shimmer.wrap;
        this._unwrap = shimmer.unwrap;
        this._massWrap = shimmer.massWrap;
        this._massUnwrap = shimmer.massUnwrap;
        this.setConfig(config2);
        this._diag = api_1.diag.createComponentLogger({
          namespace: instrumentationName
        });
        this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
        this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
        this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
      }
      /* Returns meter */
      get meter() {
        return this._meter;
      }
      /**
       * Sets MeterProvider to this plugin
       * @param meterProvider
       */
      setMeterProvider(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
      }
      /* Returns logger */
      get logger() {
        return this._logger;
      }
      /**
       * Sets LoggerProvider to this plugin
       * @param loggerProvider
       */
      setLoggerProvider(loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
      }
      /**
       * @experimental
       *
       * Get module definitions defined by {@link init}.
       * This can be used for experimental compile-time instrumentation.
       *
       * @returns an array of {@link InstrumentationModuleDefinition}
       */
      getModuleDefinitions() {
        var _a;
        const initResult = (_a = this.init()) !== null && _a !== void 0 ? _a : [];
        if (!Array.isArray(initResult)) {
          return [initResult];
        }
        return initResult;
      }
      /**
       * Sets the new metric instruments with the current Meter.
       */
      _updateMetricInstruments() {
        return;
      }
      /* Returns InstrumentationConfig */
      getConfig() {
        return this._config;
      }
      /**
       * Sets InstrumentationConfig to this plugin
       * @param config
       */
      setConfig(config2) {
        this._config = Object.assign({ enabled: true }, config2);
      }
      /**
       * Sets TraceProvider to this plugin
       * @param tracerProvider
       */
      setTracerProvider(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
      }
      /* Returns tracer */
      get tracer() {
        return this._tracer;
      }
      /**
       * Execute span customization hook, if configured, and log any errors.
       * Any semantics of the trigger and info are defined by the specific instrumentation.
       * @param hookHandler The optional hook handler which the user has configured via instrumentation config
       * @param triggerName The name of the trigger for executing the hook for logging purposes
       * @param span The span to which the hook should be applied
       * @param info The info object to be passed to the hook, with useful data the hook may use
       */
      _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
        if (!hookHandler) {
          return;
        }
        try {
          hookHandler(span, info);
        } catch (e) {
          this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e);
        }
      }
    };
    exports2.InstrumentationAbstract = InstrumentationAbstract;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os4 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os4.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util3 = require("util");
    exports2.init = init2;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug3) {
      debug3.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug3.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  "node_modules/module-details-from-path/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    module2.exports = function(file) {
      var segments = file.split(path.sep);
      var index = segments.lastIndexOf("node_modules");
      if (index === -1) return;
      if (!segments[index + 1]) return;
      var scoped = segments[index + 1][0] === "@";
      var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
      var offset = scoped ? 3 : 2;
      return {
        name,
        basedir: segments.slice(0, index + offset).join(path.sep),
        path: segments.slice(index + offset).join(path.sep)
      };
    };
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os4 = require("os");
    module2.exports = os4.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe2 = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix2 = {};
    function posixSplitPath(filename) {
      return splitPathRe2.exec(filename).slice(1);
    }
    posix2.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix2.parse;
    module2.exports.posix = posix2.parse;
    module2.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      "node:sqlite": [">= 22.13 && < 23", ">= 23.4"],
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve2(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2) cb(err2);
          else init2(realStart);
        }
      );
      var res;
      function init2(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2) cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function onfile(err2, m, pkg) {
        if (err2) cb(err2);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3) cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0) return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg) onpkg(null, pkg);
          else loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2) return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r) return load(
                [""].concat(extensions.slice()),
                path.resolve(dir, r),
                pkg
              );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2) return cb2(err2);
            if (ex) return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/") return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex) return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3) cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2) return cb2(err2);
            if (!ex) return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3) return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4) return cb2(err4);
                  if (m) return cb2(null, m, pkg2);
                  if (!pkg2) return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5) return cb2(err5);
                    if (n) return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0) return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2) return cb2(err2);
          if (!isdir2) return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2) return cb2(err2);
          if (m) return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2) return cb2(err2);
          if (n) return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      "node:sqlite": ">= 23.4",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core4 = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core4[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module2.exports = core4;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync2, pkgfile) {
      var body = readFileSync2(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync2 = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync2, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync2, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2) return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2) return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2) return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2) return n2;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// node_modules/require-in-the-middle/package.json
var require_package = __commonJS({
  "node_modules/require-in-the-middle/package.json"(exports2, module2) {
    module2.exports = {
      name: "require-in-the-middle",
      version: "7.5.2",
      description: "Module to hook into the Node.js require function",
      main: "index.js",
      types: "types/index.d.ts",
      dependencies: {
        debug: "^4.3.5",
        "module-details-from-path": "^1.0.3",
        resolve: "^1.22.8"
      },
      devDependencies: {
        "@babel/core": "^7.9.0",
        "@babel/preset-env": "^7.9.5",
        "@babel/preset-typescript": "^7.9.0",
        "@babel/register": "^7.9.0",
        "ipp-printer": "^1.0.0",
        patterns: "^1.0.3",
        roundround: "^0.2.0",
        semver: "^6.3.0",
        standard: "^14.3.1",
        tape: "^4.11.0"
      },
      scripts: {
        test: "npm run test:lint && npm run test:tape && npm run test:babel",
        "test:lint": "standard",
        "test:tape": "tape test/*.js",
        "test:babel": "node test/babel/babel-register.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/nodejs/require-in-the-middle.git"
      },
      keywords: [
        "require",
        "hook",
        "shim",
        "shimmer",
        "shimming",
        "patch",
        "monkey",
        "monkeypatch",
        "module",
        "load"
      ],
      files: [
        "types"
      ],
      author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
      license: "MIT",
      bugs: {
        url: "https://github.com/nodejs/require-in-the-middle/issues"
      },
      homepage: "https://github.com/nodejs/require-in-the-middle#readme",
      engines: {
        node: ">=8.6.0"
      }
    };
  }
});

// node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS({
  "node_modules/require-in-the-middle/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var Module = require("module");
    var debug3 = require_src3()("require-in-the-middle");
    var moduleDetailsFromPath = require_module_details_from_path();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    var builtinModules;
    var isCore;
    if (Module.isBuiltin) {
      isCore = Module.isBuiltin;
    } else if (Module.builtinModules) {
      isCore = (moduleName) => {
        if (moduleName.startsWith("node:")) {
          return true;
        }
        if (builtinModules === void 0) {
          builtinModules = new Set(Module.builtinModules);
        }
        return builtinModules.has(moduleName);
      };
    } else {
      const _resolve2 = require_resolve();
      const [major2, minor] = process.versions.node.split(".").map(Number);
      if (major2 === 8 && minor < 8) {
        isCore = (moduleName) => {
          if (moduleName === "http2") {
            return true;
          }
          return !!_resolve2.core[moduleName];
        };
      } else {
        isCore = (moduleName) => {
          return !!_resolve2.core[moduleName];
        };
      }
    }
    var _resolve;
    function resolve2(moduleName, basedir) {
      if (!_resolve) {
        if (require.resolve && require.resolve.paths) {
          _resolve = function(moduleName2, basedir2) {
            return require.resolve(moduleName2, { paths: [basedir2] });
          };
        } else {
          const resolve3 = require_resolve();
          _resolve = function(moduleName2, basedir2) {
            return resolve3.sync(moduleName2, { basedir: basedir2 });
          };
        }
      }
      return _resolve(moduleName, basedir);
    }
    var normalize2 = /([/\\]index)?(\.js)?$/;
    var ExportsCache = class {
      constructor() {
        this._localCache = /* @__PURE__ */ new Map();
        this._kRitmExports = Symbol("RitmExports");
      }
      has(filename, isBuiltin2) {
        if (this._localCache.has(filename)) {
          return true;
        } else if (!isBuiltin2) {
          const mod = require.cache[filename];
          return !!(mod && this._kRitmExports in mod);
        } else {
          return false;
        }
      }
      get(filename, isBuiltin2) {
        const cachedExports = this._localCache.get(filename);
        if (cachedExports !== void 0) {
          return cachedExports;
        } else if (!isBuiltin2) {
          const mod = require.cache[filename];
          return mod && mod[this._kRitmExports];
        }
      }
      set(filename, exports3, isBuiltin2) {
        if (isBuiltin2) {
          this._localCache.set(filename, exports3);
        } else if (filename in require.cache) {
          require.cache[filename][this._kRitmExports] = exports3;
        } else {
          debug3('non-core module is unexpectedly not in require.cache: "%s"', filename);
          this._localCache.set(filename, exports3);
        }
      }
    };
    function Hook(modules, options, onrequire) {
      if (this instanceof Hook === false) return new Hook(modules, options, onrequire);
      if (typeof modules === "function") {
        onrequire = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        onrequire = options;
        options = null;
      }
      if (typeof Module._resolveFilename !== "function") {
        console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
        console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package().bugs.url);
        return;
      }
      this._cache = new ExportsCache();
      this._unhooked = false;
      this._origRequire = Module.prototype.require;
      const self = this;
      const patching = /* @__PURE__ */ new Set();
      const internals = options ? options.internals === true : false;
      const hasWhitelist = Array.isArray(modules);
      debug3("registering require hook");
      this._require = Module.prototype.require = function(id) {
        if (self._unhooked === true) {
          debug3("ignoring require call - module is soft-unhooked");
          return self._origRequire.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, false);
      };
      if (typeof process.getBuiltinModule === "function") {
        this._origGetBuiltinModule = process.getBuiltinModule;
        this._getBuiltinModule = process.getBuiltinModule = function(id) {
          if (self._unhooked === true) {
            debug3("ignoring process.getBuiltinModule call - module is soft-unhooked");
            return self._origGetBuiltinModule.apply(this, arguments);
          }
          return patchedRequire.call(this, arguments, true);
        };
      }
      function patchedRequire(args, coreOnly) {
        const id = args[0];
        const core4 = isCore(id);
        let filename;
        if (core4) {
          filename = id;
          if (id.startsWith("node:")) {
            const idWithoutPrefix = id.slice(5);
            if (isCore(idWithoutPrefix)) {
              filename = idWithoutPrefix;
            }
          }
        } else if (coreOnly) {
          debug3("call to process.getBuiltinModule with unknown built-in id");
          return self._origGetBuiltinModule.apply(this, args);
        } else {
          try {
            filename = Module._resolveFilename(id, this);
          } catch (resolveErr) {
            debug3('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
            return self._origRequire.apply(this, args);
          }
        }
        let moduleName, basedir;
        debug3("processing %s module require('%s'): %s", core4 === true ? "core" : "non-core", id, filename);
        if (self._cache.has(filename, core4) === true) {
          debug3("returning already patched cached module: %s", filename);
          return self._cache.get(filename, core4);
        }
        const isPatching = patching.has(filename);
        if (isPatching === false) {
          patching.add(filename);
        }
        const exports3 = coreOnly ? self._origGetBuiltinModule.apply(this, args) : self._origRequire.apply(this, args);
        if (isPatching === true) {
          debug3("module is in the process of being patched already - ignoring: %s", filename);
          return exports3;
        }
        patching.delete(filename);
        if (core4 === true) {
          if (hasWhitelist === true && modules.includes(filename) === false) {
            debug3("ignoring core module not on whitelist: %s", filename);
            return exports3;
          }
          moduleName = filename;
        } else if (hasWhitelist === true && modules.includes(filename)) {
          const parsedPath = path.parse(filename);
          moduleName = parsedPath.name;
          basedir = parsedPath.dir;
        } else {
          const stat = moduleDetailsFromPath(filename);
          if (stat === void 0) {
            debug3("could not parse filename: %s", filename);
            return exports3;
          }
          moduleName = stat.name;
          basedir = stat.basedir;
          const fullModuleName = resolveModuleName(stat);
          debug3("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
          let matchFound = false;
          if (hasWhitelist) {
            if (!id.startsWith(".") && modules.includes(id)) {
              moduleName = id;
              matchFound = true;
            }
            if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
              return exports3;
            }
            if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
              moduleName = fullModuleName;
              matchFound = true;
            }
          }
          if (!matchFound) {
            let res;
            try {
              res = resolve2(moduleName, basedir);
            } catch (e) {
              debug3("could not resolve module: %s", moduleName);
              self._cache.set(filename, exports3, core4);
              return exports3;
            }
            if (res !== filename) {
              if (internals === true) {
                moduleName = moduleName + path.sep + path.relative(basedir, filename);
                debug3("preparing to process require of internal file: %s", moduleName);
              } else {
                debug3("ignoring require of non-main module file: %s", res);
                self._cache.set(filename, exports3, core4);
                return exports3;
              }
            }
          }
        }
        self._cache.set(filename, exports3, core4);
        debug3("calling require hook: %s", moduleName);
        const patchedExports = onrequire(exports3, moduleName, basedir);
        self._cache.set(filename, patchedExports, core4);
        debug3("returning module: %s", moduleName);
        return patchedExports;
      }
    }
    Hook.prototype.unhook = function() {
      this._unhooked = true;
      if (this._require === Module.prototype.require) {
        Module.prototype.require = this._origRequire;
        debug3("require unhook successful");
      } else {
        debug3("require unhook unsuccessful");
      }
      if (process.getBuiltinModule !== void 0) {
        if (this._getBuiltinModule === process.getBuiltinModule) {
          process.getBuiltinModule = this._origGetBuiltinModule;
          debug3("process.getBuiltinModule unhook successful");
        } else {
          debug3("process.getBuiltinModule unhook unsuccessful");
        }
      }
    };
    function resolveModuleName(stat) {
      const normalizedPath = path.sep !== "/" ? stat.path.split(path.sep).join("/") : stat.path;
      return path.posix.join(stat.name, normalizedPath).replace(normalize2, "");
    }
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModuleNameTrie = exports2.ModuleNameSeparator = void 0;
    exports2.ModuleNameSeparator = "/";
    var ModuleNameTrieNode = class {
      constructor() {
        this.hooks = [];
        this.children = /* @__PURE__ */ new Map();
      }
    };
    var ModuleNameTrie = class {
      constructor() {
        this._trie = new ModuleNameTrieNode();
        this._counter = 0;
      }
      /**
       * Insert a module hook into the trie
       *
       * @param {Hooked} hook Hook
       */
      insert(hook) {
        let trieNode = this._trie;
        for (const moduleNamePart of hook.moduleName.split(exports2.ModuleNameSeparator)) {
          let nextNode = trieNode.children.get(moduleNamePart);
          if (!nextNode) {
            nextNode = new ModuleNameTrieNode();
            trieNode.children.set(moduleNamePart, nextNode);
          }
          trieNode = nextNode;
        }
        trieNode.hooks.push({ hook, insertedId: this._counter++ });
      }
      /**
       * Search for matching hooks in the trie
       *
       * @param {string} moduleName Module name
       * @param {boolean} maintainInsertionOrder Whether to return the results in insertion order
       * @param {boolean} fullOnly Whether to return only full matches
       * @returns {Hooked[]} Matching hooks
       */
      search(moduleName, { maintainInsertionOrder, fullOnly } = {}) {
        let trieNode = this._trie;
        const results = [];
        let foundFull = true;
        for (const moduleNamePart of moduleName.split(exports2.ModuleNameSeparator)) {
          const nextNode = trieNode.children.get(moduleNamePart);
          if (!nextNode) {
            foundFull = false;
            break;
          }
          if (!fullOnly) {
            results.push(...nextNode.hooks);
          }
          trieNode = nextNode;
        }
        if (fullOnly && foundFull) {
          results.push(...trieNode.hooks);
        }
        if (results.length === 0) {
          return [];
        }
        if (results.length === 1) {
          return [results[0].hook];
        }
        if (maintainInsertionOrder) {
          results.sort((a, b) => a.insertedId - b.insertedId);
        }
        return results.map(({ hook }) => hook);
      }
    };
    exports2.ModuleNameTrie = ModuleNameTrie;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequireInTheMiddleSingleton = void 0;
    var require_in_the_middle_1 = require_require_in_the_middle();
    var path = require("path");
    var ModuleNameTrie_1 = require_ModuleNameTrie();
    var isMocha = [
      "afterEach",
      "after",
      "beforeEach",
      "before",
      "describe",
      "it"
    ].every((fn) => {
      return typeof global[fn] === "function";
    });
    var RequireInTheMiddleSingleton = class _RequireInTheMiddleSingleton {
      constructor() {
        this._moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie();
        this._initialize();
      }
      _initialize() {
        new require_in_the_middle_1.Hook(
          // Intercept all `require` calls; we will filter the matching ones below
          null,
          { internals: true },
          (exports3, name, basedir) => {
            const normalizedModuleName = normalizePathSeparators(name);
            const matches = this._moduleNameTrie.search(normalizedModuleName, {
              maintainInsertionOrder: true,
              // For core modules (e.g. `fs`), do not match on sub-paths (e.g. `fs/promises').
              // This matches the behavior of `require-in-the-middle`.
              // `basedir` is always `undefined` for core modules.
              fullOnly: basedir === void 0
            });
            for (const { onRequire } of matches) {
              exports3 = onRequire(exports3, name, basedir);
            }
            return exports3;
          }
        );
      }
      /**
       * Register a hook with `require-in-the-middle`
       *
       * @param {string} moduleName Module name
       * @param {OnRequireFn} onRequire Hook function
       * @returns {Hooked} Registered hook
       */
      register(moduleName, onRequire) {
        const hooked = { moduleName, onRequire };
        this._moduleNameTrie.insert(hooked);
        return hooked;
      }
      /**
       * Get the `RequireInTheMiddleSingleton` singleton
       *
       * @returns {RequireInTheMiddleSingleton} Singleton of `RequireInTheMiddleSingleton`
       */
      static getInstance() {
        var _a;
        if (isMocha)
          return new _RequireInTheMiddleSingleton();
        return this._instance = (_a = this._instance) !== null && _a !== void 0 ? _a : new _RequireInTheMiddleSingleton();
      }
    };
    exports2.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
    function normalizePathSeparators(moduleNameOrPath) {
      return path.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
    }
  }
});

// node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  "node_modules/import-in-the-middle/lib/register.js"(exports2) {
    var importHooks = [];
    var setters = /* @__PURE__ */ new WeakMap();
    var getters = /* @__PURE__ */ new WeakMap();
    var specifiers = /* @__PURE__ */ new Map();
    var toHook = [];
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value);
      },
      get(target, name) {
        if (name === Symbol.toStringTag) {
          return "Module";
        }
        const getter = getters.get(target)[name];
        if (typeof getter === "function") {
          return getter();
        }
      },
      defineProperty(target, property, descriptor) {
        if (!("value" in descriptor)) {
          throw new Error("Getters/setters are not supported for exports property descriptors.");
        }
        return setters.get(target)[property](descriptor.value);
      }
    };
    function register(name, namespace, set, get, specifier) {
      specifiers.set(name, specifier);
      setters.set(namespace, set);
      getters.set(namespace, get);
      const proxy = new Proxy(namespace, proxyHandler);
      importHooks.forEach((hook) => hook(name, proxy));
      toHook.push([name, proxy]);
    }
    exports2.register = register;
    exports2.importHooks = importHooks;
    exports2.specifiers = specifiers;
    exports2.toHook = toHook;
  }
});

// node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  "node_modules/import-in-the-middle/index.js"(exports2, module2) {
    var path = require("path");
    var parse = require_module_details_from_path();
    var { fileURLToPath } = require("url");
    var { MessageChannel } = require("worker_threads");
    var {
      importHooks,
      specifiers,
      toHook
    } = require_register();
    function addHook(hook) {
      importHooks.push(hook);
      toHook.forEach(([name, namespace]) => hook(name, namespace));
    }
    function removeHook(hook) {
      const index = importHooks.indexOf(hook);
      if (index > -1) {
        importHooks.splice(index, 1);
      }
    }
    function callHookFn(hookFn, namespace, name, baseDir) {
      const newDefault = hookFn(namespace, name, baseDir);
      if (newDefault && newDefault !== namespace) {
        namespace.default = newDefault;
      }
    }
    var sendModulesToLoader;
    function createAddHookMessageChannel2() {
      const { port1, port2 } = new MessageChannel();
      let pendingAckCount = 0;
      let resolveFn;
      sendModulesToLoader = (modules) => {
        pendingAckCount++;
        port1.postMessage(modules);
      };
      port1.on("message", () => {
        pendingAckCount--;
        if (resolveFn && pendingAckCount <= 0) {
          resolveFn();
        }
      }).unref();
      function waitForAllMessagesAcknowledged() {
        const timer = setInterval(() => {
        }, 1e3);
        const promise = new Promise((resolve2) => {
          resolveFn = resolve2;
        }).then(() => {
          clearInterval(timer);
        });
        if (pendingAckCount === 0) {
          resolveFn();
        }
        return promise;
      }
      const addHookMessagePort = port2;
      const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
      return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
    }
    function Hook(modules, options, hookFn) {
      if (this instanceof Hook === false) return new Hook(modules, options, hookFn);
      if (typeof modules === "function") {
        hookFn = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        hookFn = options;
        options = null;
      }
      const internals = options ? options.internals === true : false;
      if (sendModulesToLoader && Array.isArray(modules)) {
        sendModulesToLoader(modules);
      }
      this._iitmHook = (name, namespace) => {
        const filename = name;
        const isBuiltin2 = name.startsWith("node:");
        let baseDir;
        if (isBuiltin2) {
          name = name.replace(/^node:/, "");
        } else {
          if (name.startsWith("file://")) {
            try {
              name = fileURLToPath(name);
            } catch (e) {
            }
          }
          const details = parse(name);
          if (details) {
            name = details.name;
            baseDir = details.basedir;
          }
        }
        if (modules) {
          for (const moduleName of modules) {
            if (moduleName === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
                } else {
                  if (!baseDir.endsWith(specifiers.get(filename))) continue;
                }
              }
              callHookFn(hookFn, namespace, name, baseDir);
            }
          }
        } else {
          callHookFn(hookFn, namespace, name, baseDir);
        }
      };
      addHook(this._iitmHook);
    }
    Hook.prototype.unhook = function() {
      removeHook(this._iitmHook);
    };
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.addHook = addHook;
    module2.exports.removeHook = removeHook;
    module2.exports.createAddHookMessageChannel = createAddHookMessageChannel2;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWrapped = exports2.safeExecuteInTheMiddleAsync = exports2.safeExecuteInTheMiddle = void 0;
    function safeExecuteInTheMiddle2(execute, onFinish, preventThrowingError) {
      let error;
      let result;
      try {
        result = execute();
      } catch (e) {
        error = e;
      } finally {
        onFinish(error, result);
        if (error && !preventThrowingError) {
          throw error;
        }
        return result;
      }
    }
    exports2.safeExecuteInTheMiddle = safeExecuteInTheMiddle2;
    async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
      let error;
      let result;
      try {
        result = await execute();
      } catch (e) {
        error = e;
      } finally {
        onFinish(error, result);
        if (error && !preventThrowingError) {
          throw error;
        }
        return result;
      }
    }
    exports2.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
    function isWrapped3(func) {
      return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
    }
    exports2.isWrapped = isWrapped3;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation2 = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstrumentationBase = void 0;
    var path = require("path");
    var util_1 = require("util");
    var semver_1 = require_semver2();
    var shimmer_1 = require_shimmer();
    var instrumentation_1 = require_instrumentation();
    var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton();
    var import_in_the_middle_1 = require_import_in_the_middle();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var require_in_the_middle_1 = require_require_in_the_middle();
    var fs_1 = require("fs");
    var utils_1 = require_utils2();
    var InstrumentationBase6 = class extends instrumentation_1.InstrumentationAbstract {
      constructor(instrumentationName, instrumentationVersion, config2) {
        super(instrumentationName, instrumentationVersion, config2);
        this._hooks = [];
        this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
        this._enabled = false;
        this._wrap = (moduleExports, name, wrapper) => {
          if ((0, utils_1.isWrapped)(moduleExports[name])) {
            this._unwrap(moduleExports, name);
          }
          if (!util_1.types.isProxy(moduleExports)) {
            return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
          } else {
            const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
            Object.defineProperty(moduleExports, name, {
              value: wrapped
            });
            return wrapped;
          }
        };
        this._unwrap = (moduleExports, name) => {
          if (!util_1.types.isProxy(moduleExports)) {
            return (0, shimmer_1.unwrap)(moduleExports, name);
          } else {
            return Object.defineProperty(moduleExports, name, {
              value: moduleExports[name]
            });
          }
        };
        this._massWrap = (moduleExportsArray, names, wrapper) => {
          if (!moduleExportsArray) {
            api_1.diag.error("must provide one or more modules to patch");
            return;
          } else if (!Array.isArray(moduleExportsArray)) {
            moduleExportsArray = [moduleExportsArray];
          }
          if (!(names && Array.isArray(names))) {
            api_1.diag.error("must provide one or more functions to wrap on modules");
            return;
          }
          moduleExportsArray.forEach((moduleExports) => {
            names.forEach((name) => {
              this._wrap(moduleExports, name, wrapper);
            });
          });
        };
        this._massUnwrap = (moduleExportsArray, names) => {
          if (!moduleExportsArray) {
            api_1.diag.error("must provide one or more modules to patch");
            return;
          } else if (!Array.isArray(moduleExportsArray)) {
            moduleExportsArray = [moduleExportsArray];
          }
          if (!(names && Array.isArray(names))) {
            api_1.diag.error("must provide one or more functions to wrap on modules");
            return;
          }
          moduleExportsArray.forEach((moduleExports) => {
            names.forEach((name) => {
              this._unwrap(moduleExports, name);
            });
          });
        };
        let modules = this.init();
        if (modules && !Array.isArray(modules)) {
          modules = [modules];
        }
        this._modules = modules || [];
        if (this._config.enabled) {
          this.enable();
        }
      }
      _warnOnPreloadedModules() {
        this._modules.forEach((module3) => {
          const { name } = module3;
          try {
            const resolvedModule = require.resolve(name);
            if (require.cache[resolvedModule]) {
              this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
            }
          } catch (_a) {
          }
        });
      }
      _extractPackageVersion(baseDir) {
        try {
          const json = (0, fs_1.readFileSync)(path.join(baseDir, "package.json"), {
            encoding: "utf8"
          });
          const version = JSON.parse(json).version;
          return typeof version === "string" ? version : void 0;
        } catch (error) {
          api_1.diag.warn("Failed extracting version", baseDir);
        }
        return void 0;
      }
      _onRequire(module3, exports3, name, baseDir) {
        var _a;
        if (!baseDir) {
          if (typeof module3.patch === "function") {
            module3.moduleExports = exports3;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
                module: module3.name
              });
              return module3.patch(exports3);
            }
          }
          return exports3;
        }
        const version = this._extractPackageVersion(baseDir);
        module3.moduleVersion = version;
        if (module3.name === name) {
          if (isSupported(module3.supportedVersions, version, module3.includePrerelease)) {
            if (typeof module3.patch === "function") {
              module3.moduleExports = exports3;
              if (this._enabled) {
                this._diag.debug("Applying instrumentation patch for module on require hook", {
                  module: module3.name,
                  version: module3.moduleVersion,
                  baseDir
                });
                return module3.patch(exports3, module3.moduleVersion);
              }
            }
          }
          return exports3;
        }
        const files = (_a = module3.files) !== null && _a !== void 0 ? _a : [];
        const normalizedName = path.normalize(name);
        const supportedFileInstrumentations = files.filter((f) => f.name === normalizedName).filter((f) => isSupported(f.supportedVersions, version, module3.includePrerelease));
        return supportedFileInstrumentations.reduce((patchedExports, file) => {
          file.moduleExports = patchedExports;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
              module: module3.name,
              version: module3.moduleVersion,
              fileName: file.name,
              baseDir
            });
            return file.patch(patchedExports, module3.moduleVersion);
          }
          return patchedExports;
        }, exports3);
      }
      enable() {
        if (this._enabled) {
          return;
        }
        this._enabled = true;
        if (this._hooks.length > 0) {
          for (const module3 of this._modules) {
            if (typeof module3.patch === "function" && module3.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
                module: module3.name,
                version: module3.moduleVersion
              });
              module3.patch(module3.moduleExports, module3.moduleVersion);
            }
            for (const file of module3.files) {
              if (file.moduleExports) {
                this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                  module: module3.name,
                  version: module3.moduleVersion,
                  fileName: file.name
                });
                file.patch(file.moduleExports, module3.moduleVersion);
              }
            }
          }
          return;
        }
        this._warnOnPreloadedModules();
        for (const module3 of this._modules) {
          const hookFn = (exports3, name, baseDir) => {
            if (!baseDir && path.isAbsolute(name)) {
              const parsedPath = path.parse(name);
              name = parsedPath.name;
              baseDir = parsedPath.dir;
            }
            return this._onRequire(module3, exports3, name, baseDir);
          };
          const onRequire = (exports3, name, baseDir) => {
            return this._onRequire(module3, exports3, name, baseDir);
          };
          const hook = path.isAbsolute(module3.name) ? new require_in_the_middle_1.Hook([module3.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module3.name, onRequire);
          this._hooks.push(hook);
          const esmHook = new import_in_the_middle_1.Hook([module3.name], { internals: false }, hookFn);
          this._hooks.push(esmHook);
        }
      }
      disable() {
        if (!this._enabled) {
          return;
        }
        this._enabled = false;
        for (const module3 of this._modules) {
          if (typeof module3.unpatch === "function" && module3.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
              module: module3.name,
              version: module3.moduleVersion
            });
            module3.unpatch(module3.moduleExports, module3.moduleVersion);
          }
          for (const file of module3.files) {
            if (file.moduleExports) {
              this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
                module: module3.name,
                version: module3.moduleVersion,
                fileName: file.name
              });
              file.unpatch(file.moduleExports, module3.moduleVersion);
            }
          }
        }
      }
      isEnabled() {
        return this._enabled;
      }
    };
    exports2.InstrumentationBase = InstrumentationBase6;
    function isSupported(supportedVersions, version, includePrerelease) {
      if (typeof version === "undefined") {
        return supportedVersions.includes("*");
      }
      return supportedVersions.some((supportedVersion) => {
        return (0, semver_1.satisfies)(version, supportedVersion, { includePrerelease });
      });
    }
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalize = void 0;
    var path_1 = require("path");
    Object.defineProperty(exports2, "normalize", { enumerable: true, get: function() {
      return path_1.normalize;
    } });
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalize = exports2.InstrumentationBase = void 0;
    var instrumentation_1 = require_instrumentation2();
    Object.defineProperty(exports2, "InstrumentationBase", { enumerable: true, get: function() {
      return instrumentation_1.InstrumentationBase;
    } });
    var normalize_1 = require_normalize();
    Object.defineProperty(exports2, "normalize", { enumerable: true, get: function() {
      return normalize_1.normalize;
    } });
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalize = exports2.InstrumentationBase = void 0;
    var node_1 = require_node4();
    Object.defineProperty(exports2, "InstrumentationBase", { enumerable: true, get: function() {
      return node_1.InstrumentationBase;
    } });
    Object.defineProperty(exports2, "normalize", { enumerable: true, get: function() {
      return node_1.normalize;
    } });
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstrumentationNodeModuleDefinition = void 0;
    var InstrumentationNodeModuleDefinition5 = class {
      constructor(name, supportedVersions, patch, unpatch, files) {
        this.name = name;
        this.supportedVersions = supportedVersions;
        this.patch = patch;
        this.unpatch = unpatch;
        this.files = files || [];
      }
    };
    exports2.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition5;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstrumentationNodeModuleFile = void 0;
    var index_1 = require_platform3();
    var InstrumentationNodeModuleFile = class {
      constructor(name, supportedVersions, patch, unpatch) {
        this.supportedVersions = supportedVersions;
        this.patch = patch;
        this.unpatch = unpatch;
        this.name = (0, index_1.normalize)(name);
      }
    };
    exports2.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile;
  }
});

// node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeExecuteInTheMiddleAsync = exports2.safeExecuteInTheMiddle = exports2.isWrapped = exports2.InstrumentationNodeModuleFile = exports2.InstrumentationNodeModuleDefinition = exports2.InstrumentationBase = exports2.registerInstrumentations = void 0;
    var autoLoader_1 = require_autoLoader();
    Object.defineProperty(exports2, "registerInstrumentations", { enumerable: true, get: function() {
      return autoLoader_1.registerInstrumentations;
    } });
    var index_1 = require_platform3();
    Object.defineProperty(exports2, "InstrumentationBase", { enumerable: true, get: function() {
      return index_1.InstrumentationBase;
    } });
    var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition();
    Object.defineProperty(exports2, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
      return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
    } });
    var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile();
    Object.defineProperty(exports2, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
      return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
    } });
    var utils_1 = require_utils2();
    Object.defineProperty(exports2, "isWrapped", { enumerable: true, get: function() {
      return utils_1.isWrapped;
    } });
    Object.defineProperty(exports2, "safeExecuteInTheMiddle", { enumerable: true, get: function() {
      return utils_1.safeExecuteInTheMiddle;
    } });
    Object.defineProperty(exports2, "safeExecuteInTheMiddleAsync", { enumerable: true, get: function() {
      return utils_1.safeExecuteInTheMiddleAsync;
    } });
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap2(values) {
  var res = {};
  var len = values.length;
  for (var lp = 0; lp < len; lp++) {
    var val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils4 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN2, TMP_DB_SYSTEM2, TMP_DB_CONNECTION_STRING2, TMP_DB_USER2, TMP_DB_JDBC_DRIVER_CLASSNAME2, TMP_DB_NAME2, TMP_DB_STATEMENT2, TMP_DB_OPERATION2, TMP_DB_MSSQL_INSTANCE_NAME2, TMP_DB_CASSANDRA_KEYSPACE2, TMP_DB_CASSANDRA_PAGE_SIZE2, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2, TMP_DB_CASSANDRA_TABLE2, TMP_DB_CASSANDRA_IDEMPOTENCE2, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2, TMP_DB_CASSANDRA_COORDINATOR_ID2, TMP_DB_CASSANDRA_COORDINATOR_DC2, TMP_DB_HBASE_NAMESPACE2, TMP_DB_REDIS_DATABASE_INDEX2, TMP_DB_MONGODB_COLLECTION2, TMP_DB_SQL_TABLE2, TMP_EXCEPTION_TYPE2, TMP_EXCEPTION_MESSAGE2, TMP_EXCEPTION_STACKTRACE2, TMP_EXCEPTION_ESCAPED2, TMP_FAAS_TRIGGER2, TMP_FAAS_EXECUTION2, TMP_FAAS_DOCUMENT_COLLECTION2, TMP_FAAS_DOCUMENT_OPERATION2, TMP_FAAS_DOCUMENT_TIME2, TMP_FAAS_DOCUMENT_NAME2, TMP_FAAS_TIME2, TMP_FAAS_CRON2, TMP_FAAS_COLDSTART2, TMP_FAAS_INVOKED_NAME2, TMP_FAAS_INVOKED_PROVIDER2, TMP_FAAS_INVOKED_REGION2, TMP_NET_TRANSPORT2, TMP_NET_PEER_IP2, TMP_NET_PEER_PORT2, TMP_NET_PEER_NAME2, TMP_NET_HOST_IP2, TMP_NET_HOST_PORT2, TMP_NET_HOST_NAME2, TMP_NET_HOST_CONNECTION_TYPE2, TMP_NET_HOST_CONNECTION_SUBTYPE2, TMP_NET_HOST_CARRIER_NAME2, TMP_NET_HOST_CARRIER_MCC2, TMP_NET_HOST_CARRIER_MNC2, TMP_NET_HOST_CARRIER_ICC2, TMP_PEER_SERVICE2, TMP_ENDUSER_ID2, TMP_ENDUSER_ROLE2, TMP_ENDUSER_SCOPE2, TMP_THREAD_ID2, TMP_THREAD_NAME2, TMP_CODE_FUNCTION2, TMP_CODE_NAMESPACE2, TMP_CODE_FILEPATH2, TMP_CODE_LINENO2, TMP_HTTP_METHOD2, TMP_HTTP_URL2, TMP_HTTP_TARGET2, TMP_HTTP_HOST2, TMP_HTTP_SCHEME2, TMP_HTTP_STATUS_CODE2, TMP_HTTP_FLAVOR2, TMP_HTTP_USER_AGENT2, TMP_HTTP_REQUEST_CONTENT_LENGTH2, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2, TMP_HTTP_RESPONSE_CONTENT_LENGTH2, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2, TMP_HTTP_SERVER_NAME2, TMP_HTTP_ROUTE2, TMP_HTTP_CLIENT_IP2, TMP_AWS_DYNAMODB_TABLE_NAMES2, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2, TMP_AWS_DYNAMODB_CONSISTENT_READ2, TMP_AWS_DYNAMODB_PROJECTION2, TMP_AWS_DYNAMODB_LIMIT2, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2, TMP_AWS_DYNAMODB_INDEX_NAME2, TMP_AWS_DYNAMODB_SELECT2, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2, TMP_AWS_DYNAMODB_TABLE_COUNT2, TMP_AWS_DYNAMODB_SCAN_FORWARD2, TMP_AWS_DYNAMODB_SEGMENT2, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2, TMP_AWS_DYNAMODB_COUNT2, TMP_AWS_DYNAMODB_SCANNED_COUNT2, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2, TMP_MESSAGING_SYSTEM2, TMP_MESSAGING_DESTINATION2, TMP_MESSAGING_DESTINATION_KIND2, TMP_MESSAGING_TEMP_DESTINATION2, TMP_MESSAGING_PROTOCOL2, TMP_MESSAGING_PROTOCOL_VERSION2, TMP_MESSAGING_URL2, TMP_MESSAGING_MESSAGE_ID2, TMP_MESSAGING_CONVERSATION_ID2, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2, TMP_MESSAGING_OPERATION2, TMP_MESSAGING_CONSUMER_ID2, TMP_MESSAGING_RABBITMQ_ROUTING_KEY2, TMP_MESSAGING_KAFKA_MESSAGE_KEY2, TMP_MESSAGING_KAFKA_CONSUMER_GROUP2, TMP_MESSAGING_KAFKA_CLIENT_ID2, TMP_MESSAGING_KAFKA_PARTITION2, TMP_MESSAGING_KAFKA_TOMBSTONE2, TMP_RPC_SYSTEM2, TMP_RPC_SERVICE2, TMP_RPC_METHOD2, TMP_RPC_GRPC_STATUS_CODE2, TMP_RPC_JSONRPC_VERSION2, TMP_RPC_JSONRPC_REQUEST_ID2, TMP_RPC_JSONRPC_ERROR_CODE2, TMP_RPC_JSONRPC_ERROR_MESSAGE2, TMP_MESSAGE_TYPE2, TMP_MESSAGE_ID2, TMP_MESSAGE_COMPRESSED_SIZE2, TMP_MESSAGE_UNCOMPRESSED_SIZE2, SEMATTRS_AWS_LAMBDA_INVOKED_ARN2, SEMATTRS_DB_SYSTEM2, SEMATTRS_DB_CONNECTION_STRING2, SEMATTRS_DB_USER2, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME2, SEMATTRS_DB_NAME2, SEMATTRS_DB_STATEMENT2, SEMATTRS_DB_OPERATION2, SEMATTRS_DB_MSSQL_INSTANCE_NAME2, SEMATTRS_DB_CASSANDRA_KEYSPACE2, SEMATTRS_DB_CASSANDRA_PAGE_SIZE2, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL2, SEMATTRS_DB_CASSANDRA_TABLE2, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE2, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID2, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC2, SEMATTRS_DB_HBASE_NAMESPACE2, SEMATTRS_DB_REDIS_DATABASE_INDEX2, SEMATTRS_DB_MONGODB_COLLECTION2, SEMATTRS_DB_SQL_TABLE2, SEMATTRS_EXCEPTION_TYPE2, SEMATTRS_EXCEPTION_MESSAGE2, SEMATTRS_EXCEPTION_STACKTRACE2, SEMATTRS_EXCEPTION_ESCAPED2, SEMATTRS_FAAS_TRIGGER2, SEMATTRS_FAAS_EXECUTION2, SEMATTRS_FAAS_DOCUMENT_COLLECTION2, SEMATTRS_FAAS_DOCUMENT_OPERATION2, SEMATTRS_FAAS_DOCUMENT_TIME2, SEMATTRS_FAAS_DOCUMENT_NAME2, SEMATTRS_FAAS_TIME2, SEMATTRS_FAAS_CRON2, SEMATTRS_FAAS_COLDSTART2, SEMATTRS_FAAS_INVOKED_NAME2, SEMATTRS_FAAS_INVOKED_PROVIDER2, SEMATTRS_FAAS_INVOKED_REGION2, SEMATTRS_NET_TRANSPORT2, SEMATTRS_NET_PEER_IP2, SEMATTRS_NET_PEER_PORT2, SEMATTRS_NET_PEER_NAME2, SEMATTRS_NET_HOST_IP2, SEMATTRS_NET_HOST_PORT2, SEMATTRS_NET_HOST_NAME2, SEMATTRS_NET_HOST_CONNECTION_TYPE2, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE2, SEMATTRS_NET_HOST_CARRIER_NAME2, SEMATTRS_NET_HOST_CARRIER_MCC2, SEMATTRS_NET_HOST_CARRIER_MNC2, SEMATTRS_NET_HOST_CARRIER_ICC2, SEMATTRS_PEER_SERVICE2, SEMATTRS_ENDUSER_ID2, SEMATTRS_ENDUSER_ROLE2, SEMATTRS_ENDUSER_SCOPE2, SEMATTRS_THREAD_ID2, SEMATTRS_THREAD_NAME2, SEMATTRS_CODE_FUNCTION2, SEMATTRS_CODE_NAMESPACE2, SEMATTRS_CODE_FILEPATH2, SEMATTRS_CODE_LINENO2, SEMATTRS_HTTP_METHOD2, SEMATTRS_HTTP_URL2, SEMATTRS_HTTP_TARGET2, SEMATTRS_HTTP_HOST2, SEMATTRS_HTTP_SCHEME2, SEMATTRS_HTTP_STATUS_CODE2, SEMATTRS_HTTP_FLAVOR2, SEMATTRS_HTTP_USER_AGENT2, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH2, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH2, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2, SEMATTRS_HTTP_SERVER_NAME2, SEMATTRS_HTTP_ROUTE2, SEMATTRS_HTTP_CLIENT_IP2, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES2, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY2, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ2, SEMATTRS_AWS_DYNAMODB_PROJECTION2, SEMATTRS_AWS_DYNAMODB_LIMIT2, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET2, SEMATTRS_AWS_DYNAMODB_INDEX_NAME2, SEMATTRS_AWS_DYNAMODB_SELECT2, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT2, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD2, SEMATTRS_AWS_DYNAMODB_SEGMENT2, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS2, SEMATTRS_AWS_DYNAMODB_COUNT2, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT2, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2, SEMATTRS_MESSAGING_SYSTEM2, SEMATTRS_MESSAGING_DESTINATION2, SEMATTRS_MESSAGING_DESTINATION_KIND2, SEMATTRS_MESSAGING_TEMP_DESTINATION2, SEMATTRS_MESSAGING_PROTOCOL2, SEMATTRS_MESSAGING_PROTOCOL_VERSION2, SEMATTRS_MESSAGING_URL2, SEMATTRS_MESSAGING_MESSAGE_ID2, SEMATTRS_MESSAGING_CONVERSATION_ID2, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2, SEMATTRS_MESSAGING_OPERATION2, SEMATTRS_MESSAGING_CONSUMER_ID2, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY2, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY2, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP2, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID2, SEMATTRS_MESSAGING_KAFKA_PARTITION2, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE2, SEMATTRS_RPC_SYSTEM2, SEMATTRS_RPC_SERVICE2, SEMATTRS_RPC_METHOD2, SEMATTRS_RPC_GRPC_STATUS_CODE2, SEMATTRS_RPC_JSONRPC_VERSION2, SEMATTRS_RPC_JSONRPC_REQUEST_ID2, SEMATTRS_RPC_JSONRPC_ERROR_CODE2, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE2, SEMATTRS_MESSAGE_TYPE2, SEMATTRS_MESSAGE_ID2, SEMATTRS_MESSAGE_COMPRESSED_SIZE2, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE2, SemanticAttributes2, TMP_DBSYSTEMVALUES_OTHER_SQL2, TMP_DBSYSTEMVALUES_MSSQL2, TMP_DBSYSTEMVALUES_MYSQL2, TMP_DBSYSTEMVALUES_ORACLE2, TMP_DBSYSTEMVALUES_DB22, TMP_DBSYSTEMVALUES_POSTGRESQL2, TMP_DBSYSTEMVALUES_REDSHIFT2, TMP_DBSYSTEMVALUES_HIVE2, TMP_DBSYSTEMVALUES_CLOUDSCAPE2, TMP_DBSYSTEMVALUES_HSQLDB2, TMP_DBSYSTEMVALUES_PROGRESS2, TMP_DBSYSTEMVALUES_MAXDB2, TMP_DBSYSTEMVALUES_HANADB2, TMP_DBSYSTEMVALUES_INGRES2, TMP_DBSYSTEMVALUES_FIRSTSQL2, TMP_DBSYSTEMVALUES_EDB2, TMP_DBSYSTEMVALUES_CACHE2, TMP_DBSYSTEMVALUES_ADABAS2, TMP_DBSYSTEMVALUES_FIREBIRD2, TMP_DBSYSTEMVALUES_DERBY2, TMP_DBSYSTEMVALUES_FILEMAKER2, TMP_DBSYSTEMVALUES_INFORMIX2, TMP_DBSYSTEMVALUES_INSTANTDB2, TMP_DBSYSTEMVALUES_INTERBASE2, TMP_DBSYSTEMVALUES_MARIADB2, TMP_DBSYSTEMVALUES_NETEZZA2, TMP_DBSYSTEMVALUES_PERVASIVE2, TMP_DBSYSTEMVALUES_POINTBASE2, TMP_DBSYSTEMVALUES_SQLITE2, TMP_DBSYSTEMVALUES_SYBASE2, TMP_DBSYSTEMVALUES_TERADATA2, TMP_DBSYSTEMVALUES_VERTICA2, TMP_DBSYSTEMVALUES_H22, TMP_DBSYSTEMVALUES_COLDFUSION2, TMP_DBSYSTEMVALUES_CASSANDRA2, TMP_DBSYSTEMVALUES_HBASE2, TMP_DBSYSTEMVALUES_MONGODB2, TMP_DBSYSTEMVALUES_REDIS2, TMP_DBSYSTEMVALUES_COUCHBASE2, TMP_DBSYSTEMVALUES_COUCHDB2, TMP_DBSYSTEMVALUES_COSMOSDB2, TMP_DBSYSTEMVALUES_DYNAMODB2, TMP_DBSYSTEMVALUES_NEO4J2, TMP_DBSYSTEMVALUES_GEODE2, TMP_DBSYSTEMVALUES_ELASTICSEARCH2, TMP_DBSYSTEMVALUES_MEMCACHED2, TMP_DBSYSTEMVALUES_COCKROACHDB2, DBSYSTEMVALUES_OTHER_SQL2, DBSYSTEMVALUES_MSSQL2, DBSYSTEMVALUES_MYSQL2, DBSYSTEMVALUES_ORACLE2, DBSYSTEMVALUES_DB22, DBSYSTEMVALUES_POSTGRESQL2, DBSYSTEMVALUES_REDSHIFT2, DBSYSTEMVALUES_HIVE2, DBSYSTEMVALUES_CLOUDSCAPE2, DBSYSTEMVALUES_HSQLDB2, DBSYSTEMVALUES_PROGRESS2, DBSYSTEMVALUES_MAXDB2, DBSYSTEMVALUES_HANADB2, DBSYSTEMVALUES_INGRES2, DBSYSTEMVALUES_FIRSTSQL2, DBSYSTEMVALUES_EDB2, DBSYSTEMVALUES_CACHE2, DBSYSTEMVALUES_ADABAS2, DBSYSTEMVALUES_FIREBIRD2, DBSYSTEMVALUES_DERBY2, DBSYSTEMVALUES_FILEMAKER2, DBSYSTEMVALUES_INFORMIX2, DBSYSTEMVALUES_INSTANTDB2, DBSYSTEMVALUES_INTERBASE2, DBSYSTEMVALUES_MARIADB2, DBSYSTEMVALUES_NETEZZA2, DBSYSTEMVALUES_PERVASIVE2, DBSYSTEMVALUES_POINTBASE2, DBSYSTEMVALUES_SQLITE2, DBSYSTEMVALUES_SYBASE2, DBSYSTEMVALUES_TERADATA2, DBSYSTEMVALUES_VERTICA2, DBSYSTEMVALUES_H22, DBSYSTEMVALUES_COLDFUSION2, DBSYSTEMVALUES_CASSANDRA2, DBSYSTEMVALUES_HBASE2, DBSYSTEMVALUES_MONGODB2, DBSYSTEMVALUES_REDIS2, DBSYSTEMVALUES_COUCHBASE2, DBSYSTEMVALUES_COUCHDB2, DBSYSTEMVALUES_COSMOSDB2, DBSYSTEMVALUES_DYNAMODB2, DBSYSTEMVALUES_NEO4J2, DBSYSTEMVALUES_GEODE2, DBSYSTEMVALUES_ELASTICSEARCH2, DBSYSTEMVALUES_MEMCACHED2, DBSYSTEMVALUES_COCKROACHDB2, DbSystemValues2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2, DBCASSANDRACONSISTENCYLEVELVALUES_ALL2, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2, DBCASSANDRACONSISTENCYLEVELVALUES_ONE2, DBCASSANDRACONSISTENCYLEVELVALUES_TWO2, DBCASSANDRACONSISTENCYLEVELVALUES_THREE2, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2, DBCASSANDRACONSISTENCYLEVELVALUES_ANY2, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2, DbCassandraConsistencyLevelValues2, TMP_FAASTRIGGERVALUES_DATASOURCE2, TMP_FAASTRIGGERVALUES_HTTP2, TMP_FAASTRIGGERVALUES_PUBSUB2, TMP_FAASTRIGGERVALUES_TIMER2, TMP_FAASTRIGGERVALUES_OTHER2, FAASTRIGGERVALUES_DATASOURCE2, FAASTRIGGERVALUES_HTTP2, FAASTRIGGERVALUES_PUBSUB2, FAASTRIGGERVALUES_TIMER2, FAASTRIGGERVALUES_OTHER2, FaasTriggerValues2, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2, FAASDOCUMENTOPERATIONVALUES_INSERT2, FAASDOCUMENTOPERATIONVALUES_EDIT2, FAASDOCUMENTOPERATIONVALUES_DELETE2, FaasDocumentOperationValues2, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2, TMP_FAASINVOKEDPROVIDERVALUES_AWS2, TMP_FAASINVOKEDPROVIDERVALUES_AZURE2, TMP_FAASINVOKEDPROVIDERVALUES_GCP2, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2, FAASINVOKEDPROVIDERVALUES_AWS2, FAASINVOKEDPROVIDERVALUES_AZURE2, FAASINVOKEDPROVIDERVALUES_GCP2, FaasInvokedProviderValues2, TMP_NETTRANSPORTVALUES_IP_TCP2, TMP_NETTRANSPORTVALUES_IP_UDP2, TMP_NETTRANSPORTVALUES_IP2, TMP_NETTRANSPORTVALUES_UNIX2, TMP_NETTRANSPORTVALUES_PIPE2, TMP_NETTRANSPORTVALUES_INPROC2, TMP_NETTRANSPORTVALUES_OTHER2, NETTRANSPORTVALUES_IP_TCP2, NETTRANSPORTVALUES_IP_UDP2, NETTRANSPORTVALUES_IP2, NETTRANSPORTVALUES_UNIX2, NETTRANSPORTVALUES_PIPE2, NETTRANSPORTVALUES_INPROC2, NETTRANSPORTVALUES_OTHER2, NetTransportValues2, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2, NETHOSTCONNECTIONTYPEVALUES_WIFI2, NETHOSTCONNECTIONTYPEVALUES_WIRED2, NETHOSTCONNECTIONTYPEVALUES_CELL2, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2, NetHostConnectionTypeValues2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2, NETHOSTCONNECTIONSUBTYPEVALUES_LTE2, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2, NETHOSTCONNECTIONSUBTYPEVALUES_GSM2, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2, NETHOSTCONNECTIONSUBTYPEVALUES_NR2, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2, NetHostConnectionSubtypeValues2, TMP_HTTPFLAVORVALUES_HTTP_1_02, TMP_HTTPFLAVORVALUES_HTTP_1_12, TMP_HTTPFLAVORVALUES_HTTP_2_02, TMP_HTTPFLAVORVALUES_SPDY2, TMP_HTTPFLAVORVALUES_QUIC2, HTTPFLAVORVALUES_HTTP_1_02, HTTPFLAVORVALUES_HTTP_1_12, HTTPFLAVORVALUES_HTTP_2_02, HTTPFLAVORVALUES_SPDY2, HTTPFLAVORVALUES_QUIC2, HttpFlavorValues2, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2, MESSAGINGDESTINATIONKINDVALUES_QUEUE2, MESSAGINGDESTINATIONKINDVALUES_TOPIC2, MessagingDestinationKindValues2, TMP_MESSAGINGOPERATIONVALUES_RECEIVE2, TMP_MESSAGINGOPERATIONVALUES_PROCESS2, MESSAGINGOPERATIONVALUES_RECEIVE2, MESSAGINGOPERATIONVALUES_PROCESS2, MessagingOperationValues2, TMP_RPCGRPCSTATUSCODEVALUES_OK2, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2, RPCGRPCSTATUSCODEVALUES_OK2, RPCGRPCSTATUSCODEVALUES_CANCELLED2, RPCGRPCSTATUSCODEVALUES_UNKNOWN2, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2, RPCGRPCSTATUSCODEVALUES_NOT_FOUND2, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2, RPCGRPCSTATUSCODEVALUES_ABORTED2, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2, RPCGRPCSTATUSCODEVALUES_INTERNAL2, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2, RPCGRPCSTATUSCODEVALUES_DATA_LOSS2, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2, RpcGrpcStatusCodeValues2, TMP_MESSAGETYPEVALUES_SENT2, TMP_MESSAGETYPEVALUES_RECEIVED2, MESSAGETYPEVALUES_SENT2, MESSAGETYPEVALUES_RECEIVED2, MessageTypeValues2;
var init_SemanticAttributes2 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils4();
    TMP_AWS_LAMBDA_INVOKED_ARN2 = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM2 = "db.system";
    TMP_DB_CONNECTION_STRING2 = "db.connection_string";
    TMP_DB_USER2 = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME2 = "db.jdbc.driver_classname";
    TMP_DB_NAME2 = "db.name";
    TMP_DB_STATEMENT2 = "db.statement";
    TMP_DB_OPERATION2 = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME2 = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE2 = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE2 = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2 = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE2 = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE2 = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID2 = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC2 = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE2 = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX2 = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION2 = "db.mongodb.collection";
    TMP_DB_SQL_TABLE2 = "db.sql.table";
    TMP_EXCEPTION_TYPE2 = "exception.type";
    TMP_EXCEPTION_MESSAGE2 = "exception.message";
    TMP_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED2 = "exception.escaped";
    TMP_FAAS_TRIGGER2 = "faas.trigger";
    TMP_FAAS_EXECUTION2 = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION2 = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION2 = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME2 = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME2 = "faas.document.name";
    TMP_FAAS_TIME2 = "faas.time";
    TMP_FAAS_CRON2 = "faas.cron";
    TMP_FAAS_COLDSTART2 = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME2 = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER2 = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION2 = "faas.invoked_region";
    TMP_NET_TRANSPORT2 = "net.transport";
    TMP_NET_PEER_IP2 = "net.peer.ip";
    TMP_NET_PEER_PORT2 = "net.peer.port";
    TMP_NET_PEER_NAME2 = "net.peer.name";
    TMP_NET_HOST_IP2 = "net.host.ip";
    TMP_NET_HOST_PORT2 = "net.host.port";
    TMP_NET_HOST_NAME2 = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE2 = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE2 = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME2 = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC2 = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC2 = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC2 = "net.host.carrier.icc";
    TMP_PEER_SERVICE2 = "peer.service";
    TMP_ENDUSER_ID2 = "enduser.id";
    TMP_ENDUSER_ROLE2 = "enduser.role";
    TMP_ENDUSER_SCOPE2 = "enduser.scope";
    TMP_THREAD_ID2 = "thread.id";
    TMP_THREAD_NAME2 = "thread.name";
    TMP_CODE_FUNCTION2 = "code.function";
    TMP_CODE_NAMESPACE2 = "code.namespace";
    TMP_CODE_FILEPATH2 = "code.filepath";
    TMP_CODE_LINENO2 = "code.lineno";
    TMP_HTTP_METHOD2 = "http.method";
    TMP_HTTP_URL2 = "http.url";
    TMP_HTTP_TARGET2 = "http.target";
    TMP_HTTP_HOST2 = "http.host";
    TMP_HTTP_SCHEME2 = "http.scheme";
    TMP_HTTP_STATUS_CODE2 = "http.status_code";
    TMP_HTTP_FLAVOR2 = "http.flavor";
    TMP_HTTP_USER_AGENT2 = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH2 = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME2 = "http.server_name";
    TMP_HTTP_ROUTE2 = "http.route";
    TMP_HTTP_CLIENT_IP2 = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES2 = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2 = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ2 = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION2 = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT2 = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME2 = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT2 = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT2 = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD2 = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT2 = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2 = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT2 = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT2 = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM2 = "messaging.system";
    TMP_MESSAGING_DESTINATION2 = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND2 = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION2 = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL2 = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION2 = "messaging.protocol_version";
    TMP_MESSAGING_URL2 = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID2 = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID2 = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION2 = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID2 = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY2 = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY2 = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP2 = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID2 = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION2 = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE2 = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM2 = "rpc.system";
    TMP_RPC_SERVICE2 = "rpc.service";
    TMP_RPC_METHOD2 = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE2 = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION2 = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID2 = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE2 = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE2 = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE2 = "message.type";
    TMP_MESSAGE_ID2 = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE2 = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE2 = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN2 = TMP_AWS_LAMBDA_INVOKED_ARN2;
    SEMATTRS_DB_SYSTEM2 = TMP_DB_SYSTEM2;
    SEMATTRS_DB_CONNECTION_STRING2 = TMP_DB_CONNECTION_STRING2;
    SEMATTRS_DB_USER2 = TMP_DB_USER2;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME2 = TMP_DB_JDBC_DRIVER_CLASSNAME2;
    SEMATTRS_DB_NAME2 = TMP_DB_NAME2;
    SEMATTRS_DB_STATEMENT2 = TMP_DB_STATEMENT2;
    SEMATTRS_DB_OPERATION2 = TMP_DB_OPERATION2;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME2 = TMP_DB_MSSQL_INSTANCE_NAME2;
    SEMATTRS_DB_CASSANDRA_KEYSPACE2 = TMP_DB_CASSANDRA_KEYSPACE2;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE2 = TMP_DB_CASSANDRA_PAGE_SIZE2;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL2 = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2;
    SEMATTRS_DB_CASSANDRA_TABLE2 = TMP_DB_CASSANDRA_TABLE2;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE2 = TMP_DB_CASSANDRA_IDEMPOTENCE2;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID2 = TMP_DB_CASSANDRA_COORDINATOR_ID2;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC2 = TMP_DB_CASSANDRA_COORDINATOR_DC2;
    SEMATTRS_DB_HBASE_NAMESPACE2 = TMP_DB_HBASE_NAMESPACE2;
    SEMATTRS_DB_REDIS_DATABASE_INDEX2 = TMP_DB_REDIS_DATABASE_INDEX2;
    SEMATTRS_DB_MONGODB_COLLECTION2 = TMP_DB_MONGODB_COLLECTION2;
    SEMATTRS_DB_SQL_TABLE2 = TMP_DB_SQL_TABLE2;
    SEMATTRS_EXCEPTION_TYPE2 = TMP_EXCEPTION_TYPE2;
    SEMATTRS_EXCEPTION_MESSAGE2 = TMP_EXCEPTION_MESSAGE2;
    SEMATTRS_EXCEPTION_STACKTRACE2 = TMP_EXCEPTION_STACKTRACE2;
    SEMATTRS_EXCEPTION_ESCAPED2 = TMP_EXCEPTION_ESCAPED2;
    SEMATTRS_FAAS_TRIGGER2 = TMP_FAAS_TRIGGER2;
    SEMATTRS_FAAS_EXECUTION2 = TMP_FAAS_EXECUTION2;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION2 = TMP_FAAS_DOCUMENT_COLLECTION2;
    SEMATTRS_FAAS_DOCUMENT_OPERATION2 = TMP_FAAS_DOCUMENT_OPERATION2;
    SEMATTRS_FAAS_DOCUMENT_TIME2 = TMP_FAAS_DOCUMENT_TIME2;
    SEMATTRS_FAAS_DOCUMENT_NAME2 = TMP_FAAS_DOCUMENT_NAME2;
    SEMATTRS_FAAS_TIME2 = TMP_FAAS_TIME2;
    SEMATTRS_FAAS_CRON2 = TMP_FAAS_CRON2;
    SEMATTRS_FAAS_COLDSTART2 = TMP_FAAS_COLDSTART2;
    SEMATTRS_FAAS_INVOKED_NAME2 = TMP_FAAS_INVOKED_NAME2;
    SEMATTRS_FAAS_INVOKED_PROVIDER2 = TMP_FAAS_INVOKED_PROVIDER2;
    SEMATTRS_FAAS_INVOKED_REGION2 = TMP_FAAS_INVOKED_REGION2;
    SEMATTRS_NET_TRANSPORT2 = TMP_NET_TRANSPORT2;
    SEMATTRS_NET_PEER_IP2 = TMP_NET_PEER_IP2;
    SEMATTRS_NET_PEER_PORT2 = TMP_NET_PEER_PORT2;
    SEMATTRS_NET_PEER_NAME2 = TMP_NET_PEER_NAME2;
    SEMATTRS_NET_HOST_IP2 = TMP_NET_HOST_IP2;
    SEMATTRS_NET_HOST_PORT2 = TMP_NET_HOST_PORT2;
    SEMATTRS_NET_HOST_NAME2 = TMP_NET_HOST_NAME2;
    SEMATTRS_NET_HOST_CONNECTION_TYPE2 = TMP_NET_HOST_CONNECTION_TYPE2;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE2 = TMP_NET_HOST_CONNECTION_SUBTYPE2;
    SEMATTRS_NET_HOST_CARRIER_NAME2 = TMP_NET_HOST_CARRIER_NAME2;
    SEMATTRS_NET_HOST_CARRIER_MCC2 = TMP_NET_HOST_CARRIER_MCC2;
    SEMATTRS_NET_HOST_CARRIER_MNC2 = TMP_NET_HOST_CARRIER_MNC2;
    SEMATTRS_NET_HOST_CARRIER_ICC2 = TMP_NET_HOST_CARRIER_ICC2;
    SEMATTRS_PEER_SERVICE2 = TMP_PEER_SERVICE2;
    SEMATTRS_ENDUSER_ID2 = TMP_ENDUSER_ID2;
    SEMATTRS_ENDUSER_ROLE2 = TMP_ENDUSER_ROLE2;
    SEMATTRS_ENDUSER_SCOPE2 = TMP_ENDUSER_SCOPE2;
    SEMATTRS_THREAD_ID2 = TMP_THREAD_ID2;
    SEMATTRS_THREAD_NAME2 = TMP_THREAD_NAME2;
    SEMATTRS_CODE_FUNCTION2 = TMP_CODE_FUNCTION2;
    SEMATTRS_CODE_NAMESPACE2 = TMP_CODE_NAMESPACE2;
    SEMATTRS_CODE_FILEPATH2 = TMP_CODE_FILEPATH2;
    SEMATTRS_CODE_LINENO2 = TMP_CODE_LINENO2;
    SEMATTRS_HTTP_METHOD2 = TMP_HTTP_METHOD2;
    SEMATTRS_HTTP_URL2 = TMP_HTTP_URL2;
    SEMATTRS_HTTP_TARGET2 = TMP_HTTP_TARGET2;
    SEMATTRS_HTTP_HOST2 = TMP_HTTP_HOST2;
    SEMATTRS_HTTP_SCHEME2 = TMP_HTTP_SCHEME2;
    SEMATTRS_HTTP_STATUS_CODE2 = TMP_HTTP_STATUS_CODE2;
    SEMATTRS_HTTP_FLAVOR2 = TMP_HTTP_FLAVOR2;
    SEMATTRS_HTTP_USER_AGENT2 = TMP_HTTP_USER_AGENT2;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH2 = TMP_HTTP_REQUEST_CONTENT_LENGTH2;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH2 = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;
    SEMATTRS_HTTP_SERVER_NAME2 = TMP_HTTP_SERVER_NAME2;
    SEMATTRS_HTTP_ROUTE2 = TMP_HTTP_ROUTE2;
    SEMATTRS_HTTP_CLIENT_IP2 = TMP_HTTP_CLIENT_IP2;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES2 = TMP_AWS_DYNAMODB_TABLE_NAMES2;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY2 = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ2 = TMP_AWS_DYNAMODB_CONSISTENT_READ2;
    SEMATTRS_AWS_DYNAMODB_PROJECTION2 = TMP_AWS_DYNAMODB_PROJECTION2;
    SEMATTRS_AWS_DYNAMODB_LIMIT2 = TMP_AWS_DYNAMODB_LIMIT2;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME2 = TMP_AWS_DYNAMODB_INDEX_NAME2;
    SEMATTRS_AWS_DYNAMODB_SELECT2 = TMP_AWS_DYNAMODB_SELECT2;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT2 = TMP_AWS_DYNAMODB_TABLE_COUNT2;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD2 = TMP_AWS_DYNAMODB_SCAN_FORWARD2;
    SEMATTRS_AWS_DYNAMODB_SEGMENT2 = TMP_AWS_DYNAMODB_SEGMENT2;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS2 = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2;
    SEMATTRS_AWS_DYNAMODB_COUNT2 = TMP_AWS_DYNAMODB_COUNT2;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT2 = TMP_AWS_DYNAMODB_SCANNED_COUNT2;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2;
    SEMATTRS_MESSAGING_SYSTEM2 = TMP_MESSAGING_SYSTEM2;
    SEMATTRS_MESSAGING_DESTINATION2 = TMP_MESSAGING_DESTINATION2;
    SEMATTRS_MESSAGING_DESTINATION_KIND2 = TMP_MESSAGING_DESTINATION_KIND2;
    SEMATTRS_MESSAGING_TEMP_DESTINATION2 = TMP_MESSAGING_TEMP_DESTINATION2;
    SEMATTRS_MESSAGING_PROTOCOL2 = TMP_MESSAGING_PROTOCOL2;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION2 = TMP_MESSAGING_PROTOCOL_VERSION2;
    SEMATTRS_MESSAGING_URL2 = TMP_MESSAGING_URL2;
    SEMATTRS_MESSAGING_MESSAGE_ID2 = TMP_MESSAGING_MESSAGE_ID2;
    SEMATTRS_MESSAGING_CONVERSATION_ID2 = TMP_MESSAGING_CONVERSATION_ID2;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2;
    SEMATTRS_MESSAGING_OPERATION2 = TMP_MESSAGING_OPERATION2;
    SEMATTRS_MESSAGING_CONSUMER_ID2 = TMP_MESSAGING_CONSUMER_ID2;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY2 = TMP_MESSAGING_RABBITMQ_ROUTING_KEY2;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY2 = TMP_MESSAGING_KAFKA_MESSAGE_KEY2;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP2 = TMP_MESSAGING_KAFKA_CONSUMER_GROUP2;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID2 = TMP_MESSAGING_KAFKA_CLIENT_ID2;
    SEMATTRS_MESSAGING_KAFKA_PARTITION2 = TMP_MESSAGING_KAFKA_PARTITION2;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE2 = TMP_MESSAGING_KAFKA_TOMBSTONE2;
    SEMATTRS_RPC_SYSTEM2 = TMP_RPC_SYSTEM2;
    SEMATTRS_RPC_SERVICE2 = TMP_RPC_SERVICE2;
    SEMATTRS_RPC_METHOD2 = TMP_RPC_METHOD2;
    SEMATTRS_RPC_GRPC_STATUS_CODE2 = TMP_RPC_GRPC_STATUS_CODE2;
    SEMATTRS_RPC_JSONRPC_VERSION2 = TMP_RPC_JSONRPC_VERSION2;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID2 = TMP_RPC_JSONRPC_REQUEST_ID2;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE2 = TMP_RPC_JSONRPC_ERROR_CODE2;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE2 = TMP_RPC_JSONRPC_ERROR_MESSAGE2;
    SEMATTRS_MESSAGE_TYPE2 = TMP_MESSAGE_TYPE2;
    SEMATTRS_MESSAGE_ID2 = TMP_MESSAGE_ID2;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE2 = TMP_MESSAGE_COMPRESSED_SIZE2;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE2 = TMP_MESSAGE_UNCOMPRESSED_SIZE2;
    SemanticAttributes2 = /* @__PURE__ */ createConstMap2([
      TMP_AWS_LAMBDA_INVOKED_ARN2,
      TMP_DB_SYSTEM2,
      TMP_DB_CONNECTION_STRING2,
      TMP_DB_USER2,
      TMP_DB_JDBC_DRIVER_CLASSNAME2,
      TMP_DB_NAME2,
      TMP_DB_STATEMENT2,
      TMP_DB_OPERATION2,
      TMP_DB_MSSQL_INSTANCE_NAME2,
      TMP_DB_CASSANDRA_KEYSPACE2,
      TMP_DB_CASSANDRA_PAGE_SIZE2,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2,
      TMP_DB_CASSANDRA_TABLE2,
      TMP_DB_CASSANDRA_IDEMPOTENCE2,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
      TMP_DB_CASSANDRA_COORDINATOR_ID2,
      TMP_DB_CASSANDRA_COORDINATOR_DC2,
      TMP_DB_HBASE_NAMESPACE2,
      TMP_DB_REDIS_DATABASE_INDEX2,
      TMP_DB_MONGODB_COLLECTION2,
      TMP_DB_SQL_TABLE2,
      TMP_EXCEPTION_TYPE2,
      TMP_EXCEPTION_MESSAGE2,
      TMP_EXCEPTION_STACKTRACE2,
      TMP_EXCEPTION_ESCAPED2,
      TMP_FAAS_TRIGGER2,
      TMP_FAAS_EXECUTION2,
      TMP_FAAS_DOCUMENT_COLLECTION2,
      TMP_FAAS_DOCUMENT_OPERATION2,
      TMP_FAAS_DOCUMENT_TIME2,
      TMP_FAAS_DOCUMENT_NAME2,
      TMP_FAAS_TIME2,
      TMP_FAAS_CRON2,
      TMP_FAAS_COLDSTART2,
      TMP_FAAS_INVOKED_NAME2,
      TMP_FAAS_INVOKED_PROVIDER2,
      TMP_FAAS_INVOKED_REGION2,
      TMP_NET_TRANSPORT2,
      TMP_NET_PEER_IP2,
      TMP_NET_PEER_PORT2,
      TMP_NET_PEER_NAME2,
      TMP_NET_HOST_IP2,
      TMP_NET_HOST_PORT2,
      TMP_NET_HOST_NAME2,
      TMP_NET_HOST_CONNECTION_TYPE2,
      TMP_NET_HOST_CONNECTION_SUBTYPE2,
      TMP_NET_HOST_CARRIER_NAME2,
      TMP_NET_HOST_CARRIER_MCC2,
      TMP_NET_HOST_CARRIER_MNC2,
      TMP_NET_HOST_CARRIER_ICC2,
      TMP_PEER_SERVICE2,
      TMP_ENDUSER_ID2,
      TMP_ENDUSER_ROLE2,
      TMP_ENDUSER_SCOPE2,
      TMP_THREAD_ID2,
      TMP_THREAD_NAME2,
      TMP_CODE_FUNCTION2,
      TMP_CODE_NAMESPACE2,
      TMP_CODE_FILEPATH2,
      TMP_CODE_LINENO2,
      TMP_HTTP_METHOD2,
      TMP_HTTP_URL2,
      TMP_HTTP_TARGET2,
      TMP_HTTP_HOST2,
      TMP_HTTP_SCHEME2,
      TMP_HTTP_STATUS_CODE2,
      TMP_HTTP_FLAVOR2,
      TMP_HTTP_USER_AGENT2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_SERVER_NAME2,
      TMP_HTTP_ROUTE2,
      TMP_HTTP_CLIENT_IP2,
      TMP_AWS_DYNAMODB_TABLE_NAMES2,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
      TMP_AWS_DYNAMODB_CONSISTENT_READ2,
      TMP_AWS_DYNAMODB_PROJECTION2,
      TMP_AWS_DYNAMODB_LIMIT2,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
      TMP_AWS_DYNAMODB_INDEX_NAME2,
      TMP_AWS_DYNAMODB_SELECT2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
      TMP_AWS_DYNAMODB_TABLE_COUNT2,
      TMP_AWS_DYNAMODB_SCAN_FORWARD2,
      TMP_AWS_DYNAMODB_SEGMENT2,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2,
      TMP_AWS_DYNAMODB_COUNT2,
      TMP_AWS_DYNAMODB_SCANNED_COUNT2,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
      TMP_MESSAGING_SYSTEM2,
      TMP_MESSAGING_DESTINATION2,
      TMP_MESSAGING_DESTINATION_KIND2,
      TMP_MESSAGING_TEMP_DESTINATION2,
      TMP_MESSAGING_PROTOCOL2,
      TMP_MESSAGING_PROTOCOL_VERSION2,
      TMP_MESSAGING_URL2,
      TMP_MESSAGING_MESSAGE_ID2,
      TMP_MESSAGING_CONVERSATION_ID2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
      TMP_MESSAGING_OPERATION2,
      TMP_MESSAGING_CONSUMER_ID2,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY2,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY2,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP2,
      TMP_MESSAGING_KAFKA_CLIENT_ID2,
      TMP_MESSAGING_KAFKA_PARTITION2,
      TMP_MESSAGING_KAFKA_TOMBSTONE2,
      TMP_RPC_SYSTEM2,
      TMP_RPC_SERVICE2,
      TMP_RPC_METHOD2,
      TMP_RPC_GRPC_STATUS_CODE2,
      TMP_RPC_JSONRPC_VERSION2,
      TMP_RPC_JSONRPC_REQUEST_ID2,
      TMP_RPC_JSONRPC_ERROR_CODE2,
      TMP_RPC_JSONRPC_ERROR_MESSAGE2,
      TMP_MESSAGE_TYPE2,
      TMP_MESSAGE_ID2,
      TMP_MESSAGE_COMPRESSED_SIZE2,
      TMP_MESSAGE_UNCOMPRESSED_SIZE2
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL2 = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL2 = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL2 = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE2 = "oracle";
    TMP_DBSYSTEMVALUES_DB22 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL2 = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT2 = "redshift";
    TMP_DBSYSTEMVALUES_HIVE2 = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE2 = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB2 = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS2 = "progress";
    TMP_DBSYSTEMVALUES_MAXDB2 = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB2 = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES2 = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL2 = "firstsql";
    TMP_DBSYSTEMVALUES_EDB2 = "edb";
    TMP_DBSYSTEMVALUES_CACHE2 = "cache";
    TMP_DBSYSTEMVALUES_ADABAS2 = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD2 = "firebird";
    TMP_DBSYSTEMVALUES_DERBY2 = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER2 = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX2 = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB2 = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE2 = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB2 = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA2 = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE2 = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE2 = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE2 = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE2 = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA2 = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA2 = "vertica";
    TMP_DBSYSTEMVALUES_H22 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION2 = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA2 = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE2 = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB2 = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS2 = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE2 = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB2 = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB2 = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB2 = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J2 = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE2 = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH2 = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED2 = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB2 = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL2 = TMP_DBSYSTEMVALUES_OTHER_SQL2;
    DBSYSTEMVALUES_MSSQL2 = TMP_DBSYSTEMVALUES_MSSQL2;
    DBSYSTEMVALUES_MYSQL2 = TMP_DBSYSTEMVALUES_MYSQL2;
    DBSYSTEMVALUES_ORACLE2 = TMP_DBSYSTEMVALUES_ORACLE2;
    DBSYSTEMVALUES_DB22 = TMP_DBSYSTEMVALUES_DB22;
    DBSYSTEMVALUES_POSTGRESQL2 = TMP_DBSYSTEMVALUES_POSTGRESQL2;
    DBSYSTEMVALUES_REDSHIFT2 = TMP_DBSYSTEMVALUES_REDSHIFT2;
    DBSYSTEMVALUES_HIVE2 = TMP_DBSYSTEMVALUES_HIVE2;
    DBSYSTEMVALUES_CLOUDSCAPE2 = TMP_DBSYSTEMVALUES_CLOUDSCAPE2;
    DBSYSTEMVALUES_HSQLDB2 = TMP_DBSYSTEMVALUES_HSQLDB2;
    DBSYSTEMVALUES_PROGRESS2 = TMP_DBSYSTEMVALUES_PROGRESS2;
    DBSYSTEMVALUES_MAXDB2 = TMP_DBSYSTEMVALUES_MAXDB2;
    DBSYSTEMVALUES_HANADB2 = TMP_DBSYSTEMVALUES_HANADB2;
    DBSYSTEMVALUES_INGRES2 = TMP_DBSYSTEMVALUES_INGRES2;
    DBSYSTEMVALUES_FIRSTSQL2 = TMP_DBSYSTEMVALUES_FIRSTSQL2;
    DBSYSTEMVALUES_EDB2 = TMP_DBSYSTEMVALUES_EDB2;
    DBSYSTEMVALUES_CACHE2 = TMP_DBSYSTEMVALUES_CACHE2;
    DBSYSTEMVALUES_ADABAS2 = TMP_DBSYSTEMVALUES_ADABAS2;
    DBSYSTEMVALUES_FIREBIRD2 = TMP_DBSYSTEMVALUES_FIREBIRD2;
    DBSYSTEMVALUES_DERBY2 = TMP_DBSYSTEMVALUES_DERBY2;
    DBSYSTEMVALUES_FILEMAKER2 = TMP_DBSYSTEMVALUES_FILEMAKER2;
    DBSYSTEMVALUES_INFORMIX2 = TMP_DBSYSTEMVALUES_INFORMIX2;
    DBSYSTEMVALUES_INSTANTDB2 = TMP_DBSYSTEMVALUES_INSTANTDB2;
    DBSYSTEMVALUES_INTERBASE2 = TMP_DBSYSTEMVALUES_INTERBASE2;
    DBSYSTEMVALUES_MARIADB2 = TMP_DBSYSTEMVALUES_MARIADB2;
    DBSYSTEMVALUES_NETEZZA2 = TMP_DBSYSTEMVALUES_NETEZZA2;
    DBSYSTEMVALUES_PERVASIVE2 = TMP_DBSYSTEMVALUES_PERVASIVE2;
    DBSYSTEMVALUES_POINTBASE2 = TMP_DBSYSTEMVALUES_POINTBASE2;
    DBSYSTEMVALUES_SQLITE2 = TMP_DBSYSTEMVALUES_SQLITE2;
    DBSYSTEMVALUES_SYBASE2 = TMP_DBSYSTEMVALUES_SYBASE2;
    DBSYSTEMVALUES_TERADATA2 = TMP_DBSYSTEMVALUES_TERADATA2;
    DBSYSTEMVALUES_VERTICA2 = TMP_DBSYSTEMVALUES_VERTICA2;
    DBSYSTEMVALUES_H22 = TMP_DBSYSTEMVALUES_H22;
    DBSYSTEMVALUES_COLDFUSION2 = TMP_DBSYSTEMVALUES_COLDFUSION2;
    DBSYSTEMVALUES_CASSANDRA2 = TMP_DBSYSTEMVALUES_CASSANDRA2;
    DBSYSTEMVALUES_HBASE2 = TMP_DBSYSTEMVALUES_HBASE2;
    DBSYSTEMVALUES_MONGODB2 = TMP_DBSYSTEMVALUES_MONGODB2;
    DBSYSTEMVALUES_REDIS2 = TMP_DBSYSTEMVALUES_REDIS2;
    DBSYSTEMVALUES_COUCHBASE2 = TMP_DBSYSTEMVALUES_COUCHBASE2;
    DBSYSTEMVALUES_COUCHDB2 = TMP_DBSYSTEMVALUES_COUCHDB2;
    DBSYSTEMVALUES_COSMOSDB2 = TMP_DBSYSTEMVALUES_COSMOSDB2;
    DBSYSTEMVALUES_DYNAMODB2 = TMP_DBSYSTEMVALUES_DYNAMODB2;
    DBSYSTEMVALUES_NEO4J2 = TMP_DBSYSTEMVALUES_NEO4J2;
    DBSYSTEMVALUES_GEODE2 = TMP_DBSYSTEMVALUES_GEODE2;
    DBSYSTEMVALUES_ELASTICSEARCH2 = TMP_DBSYSTEMVALUES_ELASTICSEARCH2;
    DBSYSTEMVALUES_MEMCACHED2 = TMP_DBSYSTEMVALUES_MEMCACHED2;
    DBSYSTEMVALUES_COCKROACHDB2 = TMP_DBSYSTEMVALUES_COCKROACHDB2;
    DbSystemValues2 = /* @__PURE__ */ createConstMap2([
      TMP_DBSYSTEMVALUES_OTHER_SQL2,
      TMP_DBSYSTEMVALUES_MSSQL2,
      TMP_DBSYSTEMVALUES_MYSQL2,
      TMP_DBSYSTEMVALUES_ORACLE2,
      TMP_DBSYSTEMVALUES_DB22,
      TMP_DBSYSTEMVALUES_POSTGRESQL2,
      TMP_DBSYSTEMVALUES_REDSHIFT2,
      TMP_DBSYSTEMVALUES_HIVE2,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE2,
      TMP_DBSYSTEMVALUES_HSQLDB2,
      TMP_DBSYSTEMVALUES_PROGRESS2,
      TMP_DBSYSTEMVALUES_MAXDB2,
      TMP_DBSYSTEMVALUES_HANADB2,
      TMP_DBSYSTEMVALUES_INGRES2,
      TMP_DBSYSTEMVALUES_FIRSTSQL2,
      TMP_DBSYSTEMVALUES_EDB2,
      TMP_DBSYSTEMVALUES_CACHE2,
      TMP_DBSYSTEMVALUES_ADABAS2,
      TMP_DBSYSTEMVALUES_FIREBIRD2,
      TMP_DBSYSTEMVALUES_DERBY2,
      TMP_DBSYSTEMVALUES_FILEMAKER2,
      TMP_DBSYSTEMVALUES_INFORMIX2,
      TMP_DBSYSTEMVALUES_INSTANTDB2,
      TMP_DBSYSTEMVALUES_INTERBASE2,
      TMP_DBSYSTEMVALUES_MARIADB2,
      TMP_DBSYSTEMVALUES_NETEZZA2,
      TMP_DBSYSTEMVALUES_PERVASIVE2,
      TMP_DBSYSTEMVALUES_POINTBASE2,
      TMP_DBSYSTEMVALUES_SQLITE2,
      TMP_DBSYSTEMVALUES_SYBASE2,
      TMP_DBSYSTEMVALUES_TERADATA2,
      TMP_DBSYSTEMVALUES_VERTICA2,
      TMP_DBSYSTEMVALUES_H22,
      TMP_DBSYSTEMVALUES_COLDFUSION2,
      TMP_DBSYSTEMVALUES_CASSANDRA2,
      TMP_DBSYSTEMVALUES_HBASE2,
      TMP_DBSYSTEMVALUES_MONGODB2,
      TMP_DBSYSTEMVALUES_REDIS2,
      TMP_DBSYSTEMVALUES_COUCHBASE2,
      TMP_DBSYSTEMVALUES_COUCHDB2,
      TMP_DBSYSTEMVALUES_COSMOSDB2,
      TMP_DBSYSTEMVALUES_DYNAMODB2,
      TMP_DBSYSTEMVALUES_NEO4J2,
      TMP_DBSYSTEMVALUES_GEODE2,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH2,
      TMP_DBSYSTEMVALUES_MEMCACHED2,
      TMP_DBSYSTEMVALUES_COCKROACHDB2
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2;
    DbCassandraConsistencyLevelValues2 = /* @__PURE__ */ createConstMap2([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE2 = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP2 = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB2 = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER2 = "timer";
    TMP_FAASTRIGGERVALUES_OTHER2 = "other";
    FAASTRIGGERVALUES_DATASOURCE2 = TMP_FAASTRIGGERVALUES_DATASOURCE2;
    FAASTRIGGERVALUES_HTTP2 = TMP_FAASTRIGGERVALUES_HTTP2;
    FAASTRIGGERVALUES_PUBSUB2 = TMP_FAASTRIGGERVALUES_PUBSUB2;
    FAASTRIGGERVALUES_TIMER2 = TMP_FAASTRIGGERVALUES_TIMER2;
    FAASTRIGGERVALUES_OTHER2 = TMP_FAASTRIGGERVALUES_OTHER2;
    FaasTriggerValues2 = /* @__PURE__ */ createConstMap2([
      TMP_FAASTRIGGERVALUES_DATASOURCE2,
      TMP_FAASTRIGGERVALUES_HTTP2,
      TMP_FAASTRIGGERVALUES_PUBSUB2,
      TMP_FAASTRIGGERVALUES_TIMER2,
      TMP_FAASTRIGGERVALUES_OTHER2
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2 = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2 = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2 = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT2 = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2;
    FAASDOCUMENTOPERATIONVALUES_EDIT2 = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2;
    FAASDOCUMENTOPERATIONVALUES_DELETE2 = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2;
    FaasDocumentOperationValues2 = /* @__PURE__ */ createConstMap2([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS2 = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE2 = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP2 = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2;
    FAASINVOKEDPROVIDERVALUES_AWS2 = TMP_FAASINVOKEDPROVIDERVALUES_AWS2;
    FAASINVOKEDPROVIDERVALUES_AZURE2 = TMP_FAASINVOKEDPROVIDERVALUES_AZURE2;
    FAASINVOKEDPROVIDERVALUES_GCP2 = TMP_FAASINVOKEDPROVIDERVALUES_GCP2;
    FaasInvokedProviderValues2 = /* @__PURE__ */ createConstMap2([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS2,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE2,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP2
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP2 = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP2 = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP2 = "ip";
    TMP_NETTRANSPORTVALUES_UNIX2 = "unix";
    TMP_NETTRANSPORTVALUES_PIPE2 = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC2 = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER2 = "other";
    NETTRANSPORTVALUES_IP_TCP2 = TMP_NETTRANSPORTVALUES_IP_TCP2;
    NETTRANSPORTVALUES_IP_UDP2 = TMP_NETTRANSPORTVALUES_IP_UDP2;
    NETTRANSPORTVALUES_IP2 = TMP_NETTRANSPORTVALUES_IP2;
    NETTRANSPORTVALUES_UNIX2 = TMP_NETTRANSPORTVALUES_UNIX2;
    NETTRANSPORTVALUES_PIPE2 = TMP_NETTRANSPORTVALUES_PIPE2;
    NETTRANSPORTVALUES_INPROC2 = TMP_NETTRANSPORTVALUES_INPROC2;
    NETTRANSPORTVALUES_OTHER2 = TMP_NETTRANSPORTVALUES_OTHER2;
    NetTransportValues2 = /* @__PURE__ */ createConstMap2([
      TMP_NETTRANSPORTVALUES_IP_TCP2,
      TMP_NETTRANSPORTVALUES_IP_UDP2,
      TMP_NETTRANSPORTVALUES_IP2,
      TMP_NETTRANSPORTVALUES_UNIX2,
      TMP_NETTRANSPORTVALUES_PIPE2,
      TMP_NETTRANSPORTVALUES_INPROC2,
      TMP_NETTRANSPORTVALUES_OTHER2
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2 = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2 = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2 = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI2 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2;
    NETHOSTCONNECTIONTYPEVALUES_WIRED2 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2;
    NETHOSTCONNECTIONTYPEVALUES_CELL2 = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2;
    NetHostConnectionTypeValues2 = /* @__PURE__ */ createConstMap2([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2;
    NetHostConnectionSubtypeValues2 = /* @__PURE__ */ createConstMap2([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_02 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_12 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_02 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY2 = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC2 = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_02 = TMP_HTTPFLAVORVALUES_HTTP_1_02;
    HTTPFLAVORVALUES_HTTP_1_12 = TMP_HTTPFLAVORVALUES_HTTP_1_12;
    HTTPFLAVORVALUES_HTTP_2_02 = TMP_HTTPFLAVORVALUES_HTTP_2_02;
    HTTPFLAVORVALUES_SPDY2 = TMP_HTTPFLAVORVALUES_SPDY2;
    HTTPFLAVORVALUES_QUIC2 = TMP_HTTPFLAVORVALUES_QUIC2;
    HttpFlavorValues2 = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_02,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_12,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_02,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY2,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC2
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2;
    MessagingDestinationKindValues2 = /* @__PURE__ */ createConstMap2([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE2 = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS2 = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE2 = TMP_MESSAGINGOPERATIONVALUES_RECEIVE2;
    MESSAGINGOPERATIONVALUES_PROCESS2 = TMP_MESSAGINGOPERATIONVALUES_PROCESS2;
    MessagingOperationValues2 = /* @__PURE__ */ createConstMap2([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE2,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS2
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK2 = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2 = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2 = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2 = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = 16;
    RPCGRPCSTATUSCODEVALUES_OK2 = TMP_RPCGRPCSTATUSCODEVALUES_OK2;
    RPCGRPCSTATUSCODEVALUES_CANCELLED2 = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2;
    RPCGRPCSTATUSCODEVALUES_ABORTED2 = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2;
    RPCGRPCSTATUSCODEVALUES_INTERNAL2 = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2;
    RpcGrpcStatusCodeValues2 = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK2,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2
    };
    TMP_MESSAGETYPEVALUES_SENT2 = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED2 = "RECEIVED";
    MESSAGETYPEVALUES_SENT2 = TMP_MESSAGETYPEVALUES_SENT2;
    MESSAGETYPEVALUES_RECEIVED2 = TMP_MESSAGETYPEVALUES_RECEIVED2;
    MessageTypeValues2 = /* @__PURE__ */ createConstMap2([
      TMP_MESSAGETYPEVALUES_SENT2,
      TMP_MESSAGETYPEVALUES_RECEIVED2
    ]);
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace3 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes2();
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER2, TMP_CLOUD_ACCOUNT_ID2, TMP_CLOUD_REGION2, TMP_CLOUD_AVAILABILITY_ZONE2, TMP_CLOUD_PLATFORM2, TMP_AWS_ECS_CONTAINER_ARN2, TMP_AWS_ECS_CLUSTER_ARN2, TMP_AWS_ECS_LAUNCHTYPE2, TMP_AWS_ECS_TASK_ARN2, TMP_AWS_ECS_TASK_FAMILY2, TMP_AWS_ECS_TASK_REVISION2, TMP_AWS_EKS_CLUSTER_ARN2, TMP_AWS_LOG_GROUP_NAMES2, TMP_AWS_LOG_GROUP_ARNS2, TMP_AWS_LOG_STREAM_NAMES2, TMP_AWS_LOG_STREAM_ARNS2, TMP_CONTAINER_NAME2, TMP_CONTAINER_ID2, TMP_CONTAINER_RUNTIME2, TMP_CONTAINER_IMAGE_NAME2, TMP_CONTAINER_IMAGE_TAG2, TMP_DEPLOYMENT_ENVIRONMENT2, TMP_DEVICE_ID2, TMP_DEVICE_MODEL_IDENTIFIER2, TMP_DEVICE_MODEL_NAME2, TMP_FAAS_NAME2, TMP_FAAS_ID2, TMP_FAAS_VERSION2, TMP_FAAS_INSTANCE2, TMP_FAAS_MAX_MEMORY2, TMP_HOST_ID2, TMP_HOST_NAME2, TMP_HOST_TYPE2, TMP_HOST_ARCH2, TMP_HOST_IMAGE_NAME2, TMP_HOST_IMAGE_ID2, TMP_HOST_IMAGE_VERSION2, TMP_K8S_CLUSTER_NAME2, TMP_K8S_NODE_NAME2, TMP_K8S_NODE_UID2, TMP_K8S_NAMESPACE_NAME2, TMP_K8S_POD_UID2, TMP_K8S_POD_NAME2, TMP_K8S_CONTAINER_NAME2, TMP_K8S_REPLICASET_UID2, TMP_K8S_REPLICASET_NAME2, TMP_K8S_DEPLOYMENT_UID2, TMP_K8S_DEPLOYMENT_NAME2, TMP_K8S_STATEFULSET_UID2, TMP_K8S_STATEFULSET_NAME2, TMP_K8S_DAEMONSET_UID2, TMP_K8S_DAEMONSET_NAME2, TMP_K8S_JOB_UID2, TMP_K8S_JOB_NAME2, TMP_K8S_CRONJOB_UID2, TMP_K8S_CRONJOB_NAME2, TMP_OS_TYPE2, TMP_OS_DESCRIPTION2, TMP_OS_NAME2, TMP_OS_VERSION2, TMP_PROCESS_PID2, TMP_PROCESS_EXECUTABLE_NAME2, TMP_PROCESS_EXECUTABLE_PATH2, TMP_PROCESS_COMMAND2, TMP_PROCESS_COMMAND_LINE2, TMP_PROCESS_COMMAND_ARGS2, TMP_PROCESS_OWNER2, TMP_PROCESS_RUNTIME_NAME2, TMP_PROCESS_RUNTIME_VERSION2, TMP_PROCESS_RUNTIME_DESCRIPTION2, TMP_SERVICE_NAME2, TMP_SERVICE_NAMESPACE2, TMP_SERVICE_INSTANCE_ID2, TMP_SERVICE_VERSION2, TMP_TELEMETRY_SDK_NAME2, TMP_TELEMETRY_SDK_LANGUAGE2, TMP_TELEMETRY_SDK_VERSION2, TMP_TELEMETRY_AUTO_VERSION2, TMP_WEBENGINE_NAME2, TMP_WEBENGINE_VERSION2, TMP_WEBENGINE_DESCRIPTION2, SEMRESATTRS_CLOUD_PROVIDER2, SEMRESATTRS_CLOUD_ACCOUNT_ID2, SEMRESATTRS_CLOUD_REGION2, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE2, SEMRESATTRS_CLOUD_PLATFORM2, SEMRESATTRS_AWS_ECS_CONTAINER_ARN2, SEMRESATTRS_AWS_ECS_CLUSTER_ARN2, SEMRESATTRS_AWS_ECS_LAUNCHTYPE2, SEMRESATTRS_AWS_ECS_TASK_ARN2, SEMRESATTRS_AWS_ECS_TASK_FAMILY2, SEMRESATTRS_AWS_ECS_TASK_REVISION2, SEMRESATTRS_AWS_EKS_CLUSTER_ARN2, SEMRESATTRS_AWS_LOG_GROUP_NAMES2, SEMRESATTRS_AWS_LOG_GROUP_ARNS2, SEMRESATTRS_AWS_LOG_STREAM_NAMES2, SEMRESATTRS_AWS_LOG_STREAM_ARNS2, SEMRESATTRS_CONTAINER_NAME2, SEMRESATTRS_CONTAINER_ID2, SEMRESATTRS_CONTAINER_RUNTIME2, SEMRESATTRS_CONTAINER_IMAGE_NAME2, SEMRESATTRS_CONTAINER_IMAGE_TAG2, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT2, SEMRESATTRS_DEVICE_ID2, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER2, SEMRESATTRS_DEVICE_MODEL_NAME2, SEMRESATTRS_FAAS_NAME2, SEMRESATTRS_FAAS_ID2, SEMRESATTRS_FAAS_VERSION2, SEMRESATTRS_FAAS_INSTANCE2, SEMRESATTRS_FAAS_MAX_MEMORY2, SEMRESATTRS_HOST_ID2, SEMRESATTRS_HOST_NAME2, SEMRESATTRS_HOST_TYPE2, SEMRESATTRS_HOST_ARCH2, SEMRESATTRS_HOST_IMAGE_NAME2, SEMRESATTRS_HOST_IMAGE_ID2, SEMRESATTRS_HOST_IMAGE_VERSION2, SEMRESATTRS_K8S_CLUSTER_NAME2, SEMRESATTRS_K8S_NODE_NAME2, SEMRESATTRS_K8S_NODE_UID2, SEMRESATTRS_K8S_NAMESPACE_NAME2, SEMRESATTRS_K8S_POD_UID2, SEMRESATTRS_K8S_POD_NAME2, SEMRESATTRS_K8S_CONTAINER_NAME2, SEMRESATTRS_K8S_REPLICASET_UID2, SEMRESATTRS_K8S_REPLICASET_NAME2, SEMRESATTRS_K8S_DEPLOYMENT_UID2, SEMRESATTRS_K8S_DEPLOYMENT_NAME2, SEMRESATTRS_K8S_STATEFULSET_UID2, SEMRESATTRS_K8S_STATEFULSET_NAME2, SEMRESATTRS_K8S_DAEMONSET_UID2, SEMRESATTRS_K8S_DAEMONSET_NAME2, SEMRESATTRS_K8S_JOB_UID2, SEMRESATTRS_K8S_JOB_NAME2, SEMRESATTRS_K8S_CRONJOB_UID2, SEMRESATTRS_K8S_CRONJOB_NAME2, SEMRESATTRS_OS_TYPE2, SEMRESATTRS_OS_DESCRIPTION2, SEMRESATTRS_OS_NAME2, SEMRESATTRS_OS_VERSION2, SEMRESATTRS_PROCESS_PID2, SEMRESATTRS_PROCESS_EXECUTABLE_NAME2, SEMRESATTRS_PROCESS_EXECUTABLE_PATH2, SEMRESATTRS_PROCESS_COMMAND2, SEMRESATTRS_PROCESS_COMMAND_LINE2, SEMRESATTRS_PROCESS_COMMAND_ARGS2, SEMRESATTRS_PROCESS_OWNER2, SEMRESATTRS_PROCESS_RUNTIME_NAME2, SEMRESATTRS_PROCESS_RUNTIME_VERSION2, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION2, SEMRESATTRS_SERVICE_NAME2, SEMRESATTRS_SERVICE_NAMESPACE2, SEMRESATTRS_SERVICE_INSTANCE_ID2, SEMRESATTRS_SERVICE_VERSION2, SEMRESATTRS_TELEMETRY_SDK_NAME2, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE2, SEMRESATTRS_TELEMETRY_SDK_VERSION2, SEMRESATTRS_TELEMETRY_AUTO_VERSION2, SEMRESATTRS_WEBENGINE_NAME2, SEMRESATTRS_WEBENGINE_VERSION2, SEMRESATTRS_WEBENGINE_DESCRIPTION2, SemanticResourceAttributes2, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2, TMP_CLOUDPROVIDERVALUES_AWS2, TMP_CLOUDPROVIDERVALUES_AZURE2, TMP_CLOUDPROVIDERVALUES_GCP2, CLOUDPROVIDERVALUES_ALIBABA_CLOUD2, CLOUDPROVIDERVALUES_AWS2, CLOUDPROVIDERVALUES_AZURE2, CLOUDPROVIDERVALUES_GCP2, CloudProviderValues2, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2, TMP_CLOUDPLATFORMVALUES_AWS_EC22, TMP_CLOUDPLATFORMVALUES_AWS_ECS2, TMP_CLOUDPLATFORMVALUES_AWS_EKS2, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2, TMP_CLOUDPLATFORMVALUES_AZURE_VM2, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2, TMP_CLOUDPLATFORMVALUES_AZURE_AKS2, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2, CLOUDPLATFORMVALUES_AWS_EC22, CLOUDPLATFORMVALUES_AWS_ECS2, CLOUDPLATFORMVALUES_AWS_EKS2, CLOUDPLATFORMVALUES_AWS_LAMBDA2, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2, CLOUDPLATFORMVALUES_AZURE_VM2, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2, CLOUDPLATFORMVALUES_AZURE_AKS2, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2, CLOUDPLATFORMVALUES_GCP_APP_ENGINE2, CloudPlatformValues2, TMP_AWSECSLAUNCHTYPEVALUES_EC22, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2, AWSECSLAUNCHTYPEVALUES_EC22, AWSECSLAUNCHTYPEVALUES_FARGATE2, AwsEcsLaunchtypeValues2, TMP_HOSTARCHVALUES_AMD642, TMP_HOSTARCHVALUES_ARM322, TMP_HOSTARCHVALUES_ARM642, TMP_HOSTARCHVALUES_IA642, TMP_HOSTARCHVALUES_PPC322, TMP_HOSTARCHVALUES_PPC642, TMP_HOSTARCHVALUES_X862, HOSTARCHVALUES_AMD642, HOSTARCHVALUES_ARM322, HOSTARCHVALUES_ARM642, HOSTARCHVALUES_IA642, HOSTARCHVALUES_PPC322, HOSTARCHVALUES_PPC642, HOSTARCHVALUES_X862, HostArchValues2, TMP_OSTYPEVALUES_WINDOWS2, TMP_OSTYPEVALUES_LINUX2, TMP_OSTYPEVALUES_DARWIN2, TMP_OSTYPEVALUES_FREEBSD2, TMP_OSTYPEVALUES_NETBSD2, TMP_OSTYPEVALUES_OPENBSD2, TMP_OSTYPEVALUES_DRAGONFLYBSD2, TMP_OSTYPEVALUES_HPUX2, TMP_OSTYPEVALUES_AIX2, TMP_OSTYPEVALUES_SOLARIS2, TMP_OSTYPEVALUES_Z_OS2, OSTYPEVALUES_WINDOWS2, OSTYPEVALUES_LINUX2, OSTYPEVALUES_DARWIN2, OSTYPEVALUES_FREEBSD2, OSTYPEVALUES_NETBSD2, OSTYPEVALUES_OPENBSD2, OSTYPEVALUES_DRAGONFLYBSD2, OSTYPEVALUES_HPUX2, OSTYPEVALUES_AIX2, OSTYPEVALUES_SOLARIS2, OSTYPEVALUES_Z_OS2, OsTypeValues2, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2, TMP_TELEMETRYSDKLANGUAGEVALUES_GO2, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2, TELEMETRYSDKLANGUAGEVALUES_CPP2, TELEMETRYSDKLANGUAGEVALUES_DOTNET2, TELEMETRYSDKLANGUAGEVALUES_ERLANG2, TELEMETRYSDKLANGUAGEVALUES_GO2, TELEMETRYSDKLANGUAGEVALUES_JAVA2, TELEMETRYSDKLANGUAGEVALUES_NODEJS2, TELEMETRYSDKLANGUAGEVALUES_PHP2, TELEMETRYSDKLANGUAGEVALUES_PYTHON2, TELEMETRYSDKLANGUAGEVALUES_RUBY2, TELEMETRYSDKLANGUAGEVALUES_WEBJS2, TelemetrySdkLanguageValues2;
var init_SemanticResourceAttributes2 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils4();
    TMP_CLOUD_PROVIDER2 = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID2 = "cloud.account.id";
    TMP_CLOUD_REGION2 = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE2 = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM2 = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN2 = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN2 = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE2 = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN2 = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY2 = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION2 = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN2 = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES2 = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS2 = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES2 = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS2 = "aws.log.stream.arns";
    TMP_CONTAINER_NAME2 = "container.name";
    TMP_CONTAINER_ID2 = "container.id";
    TMP_CONTAINER_RUNTIME2 = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME2 = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG2 = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT2 = "deployment.environment";
    TMP_DEVICE_ID2 = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER2 = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME2 = "device.model.name";
    TMP_FAAS_NAME2 = "faas.name";
    TMP_FAAS_ID2 = "faas.id";
    TMP_FAAS_VERSION2 = "faas.version";
    TMP_FAAS_INSTANCE2 = "faas.instance";
    TMP_FAAS_MAX_MEMORY2 = "faas.max_memory";
    TMP_HOST_ID2 = "host.id";
    TMP_HOST_NAME2 = "host.name";
    TMP_HOST_TYPE2 = "host.type";
    TMP_HOST_ARCH2 = "host.arch";
    TMP_HOST_IMAGE_NAME2 = "host.image.name";
    TMP_HOST_IMAGE_ID2 = "host.image.id";
    TMP_HOST_IMAGE_VERSION2 = "host.image.version";
    TMP_K8S_CLUSTER_NAME2 = "k8s.cluster.name";
    TMP_K8S_NODE_NAME2 = "k8s.node.name";
    TMP_K8S_NODE_UID2 = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME2 = "k8s.namespace.name";
    TMP_K8S_POD_UID2 = "k8s.pod.uid";
    TMP_K8S_POD_NAME2 = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME2 = "k8s.container.name";
    TMP_K8S_REPLICASET_UID2 = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME2 = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID2 = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME2 = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID2 = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME2 = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID2 = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME2 = "k8s.daemonset.name";
    TMP_K8S_JOB_UID2 = "k8s.job.uid";
    TMP_K8S_JOB_NAME2 = "k8s.job.name";
    TMP_K8S_CRONJOB_UID2 = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME2 = "k8s.cronjob.name";
    TMP_OS_TYPE2 = "os.type";
    TMP_OS_DESCRIPTION2 = "os.description";
    TMP_OS_NAME2 = "os.name";
    TMP_OS_VERSION2 = "os.version";
    TMP_PROCESS_PID2 = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME2 = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH2 = "process.executable.path";
    TMP_PROCESS_COMMAND2 = "process.command";
    TMP_PROCESS_COMMAND_LINE2 = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS2 = "process.command_args";
    TMP_PROCESS_OWNER2 = "process.owner";
    TMP_PROCESS_RUNTIME_NAME2 = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION2 = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION2 = "process.runtime.description";
    TMP_SERVICE_NAME2 = "service.name";
    TMP_SERVICE_NAMESPACE2 = "service.namespace";
    TMP_SERVICE_INSTANCE_ID2 = "service.instance.id";
    TMP_SERVICE_VERSION2 = "service.version";
    TMP_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION2 = "telemetry.auto.version";
    TMP_WEBENGINE_NAME2 = "webengine.name";
    TMP_WEBENGINE_VERSION2 = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION2 = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER2 = TMP_CLOUD_PROVIDER2;
    SEMRESATTRS_CLOUD_ACCOUNT_ID2 = TMP_CLOUD_ACCOUNT_ID2;
    SEMRESATTRS_CLOUD_REGION2 = TMP_CLOUD_REGION2;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE2 = TMP_CLOUD_AVAILABILITY_ZONE2;
    SEMRESATTRS_CLOUD_PLATFORM2 = TMP_CLOUD_PLATFORM2;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN2 = TMP_AWS_ECS_CONTAINER_ARN2;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN2 = TMP_AWS_ECS_CLUSTER_ARN2;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE2 = TMP_AWS_ECS_LAUNCHTYPE2;
    SEMRESATTRS_AWS_ECS_TASK_ARN2 = TMP_AWS_ECS_TASK_ARN2;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY2 = TMP_AWS_ECS_TASK_FAMILY2;
    SEMRESATTRS_AWS_ECS_TASK_REVISION2 = TMP_AWS_ECS_TASK_REVISION2;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN2 = TMP_AWS_EKS_CLUSTER_ARN2;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES2 = TMP_AWS_LOG_GROUP_NAMES2;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS2 = TMP_AWS_LOG_GROUP_ARNS2;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES2 = TMP_AWS_LOG_STREAM_NAMES2;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS2 = TMP_AWS_LOG_STREAM_ARNS2;
    SEMRESATTRS_CONTAINER_NAME2 = TMP_CONTAINER_NAME2;
    SEMRESATTRS_CONTAINER_ID2 = TMP_CONTAINER_ID2;
    SEMRESATTRS_CONTAINER_RUNTIME2 = TMP_CONTAINER_RUNTIME2;
    SEMRESATTRS_CONTAINER_IMAGE_NAME2 = TMP_CONTAINER_IMAGE_NAME2;
    SEMRESATTRS_CONTAINER_IMAGE_TAG2 = TMP_CONTAINER_IMAGE_TAG2;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT2 = TMP_DEPLOYMENT_ENVIRONMENT2;
    SEMRESATTRS_DEVICE_ID2 = TMP_DEVICE_ID2;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER2 = TMP_DEVICE_MODEL_IDENTIFIER2;
    SEMRESATTRS_DEVICE_MODEL_NAME2 = TMP_DEVICE_MODEL_NAME2;
    SEMRESATTRS_FAAS_NAME2 = TMP_FAAS_NAME2;
    SEMRESATTRS_FAAS_ID2 = TMP_FAAS_ID2;
    SEMRESATTRS_FAAS_VERSION2 = TMP_FAAS_VERSION2;
    SEMRESATTRS_FAAS_INSTANCE2 = TMP_FAAS_INSTANCE2;
    SEMRESATTRS_FAAS_MAX_MEMORY2 = TMP_FAAS_MAX_MEMORY2;
    SEMRESATTRS_HOST_ID2 = TMP_HOST_ID2;
    SEMRESATTRS_HOST_NAME2 = TMP_HOST_NAME2;
    SEMRESATTRS_HOST_TYPE2 = TMP_HOST_TYPE2;
    SEMRESATTRS_HOST_ARCH2 = TMP_HOST_ARCH2;
    SEMRESATTRS_HOST_IMAGE_NAME2 = TMP_HOST_IMAGE_NAME2;
    SEMRESATTRS_HOST_IMAGE_ID2 = TMP_HOST_IMAGE_ID2;
    SEMRESATTRS_HOST_IMAGE_VERSION2 = TMP_HOST_IMAGE_VERSION2;
    SEMRESATTRS_K8S_CLUSTER_NAME2 = TMP_K8S_CLUSTER_NAME2;
    SEMRESATTRS_K8S_NODE_NAME2 = TMP_K8S_NODE_NAME2;
    SEMRESATTRS_K8S_NODE_UID2 = TMP_K8S_NODE_UID2;
    SEMRESATTRS_K8S_NAMESPACE_NAME2 = TMP_K8S_NAMESPACE_NAME2;
    SEMRESATTRS_K8S_POD_UID2 = TMP_K8S_POD_UID2;
    SEMRESATTRS_K8S_POD_NAME2 = TMP_K8S_POD_NAME2;
    SEMRESATTRS_K8S_CONTAINER_NAME2 = TMP_K8S_CONTAINER_NAME2;
    SEMRESATTRS_K8S_REPLICASET_UID2 = TMP_K8S_REPLICASET_UID2;
    SEMRESATTRS_K8S_REPLICASET_NAME2 = TMP_K8S_REPLICASET_NAME2;
    SEMRESATTRS_K8S_DEPLOYMENT_UID2 = TMP_K8S_DEPLOYMENT_UID2;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME2 = TMP_K8S_DEPLOYMENT_NAME2;
    SEMRESATTRS_K8S_STATEFULSET_UID2 = TMP_K8S_STATEFULSET_UID2;
    SEMRESATTRS_K8S_STATEFULSET_NAME2 = TMP_K8S_STATEFULSET_NAME2;
    SEMRESATTRS_K8S_DAEMONSET_UID2 = TMP_K8S_DAEMONSET_UID2;
    SEMRESATTRS_K8S_DAEMONSET_NAME2 = TMP_K8S_DAEMONSET_NAME2;
    SEMRESATTRS_K8S_JOB_UID2 = TMP_K8S_JOB_UID2;
    SEMRESATTRS_K8S_JOB_NAME2 = TMP_K8S_JOB_NAME2;
    SEMRESATTRS_K8S_CRONJOB_UID2 = TMP_K8S_CRONJOB_UID2;
    SEMRESATTRS_K8S_CRONJOB_NAME2 = TMP_K8S_CRONJOB_NAME2;
    SEMRESATTRS_OS_TYPE2 = TMP_OS_TYPE2;
    SEMRESATTRS_OS_DESCRIPTION2 = TMP_OS_DESCRIPTION2;
    SEMRESATTRS_OS_NAME2 = TMP_OS_NAME2;
    SEMRESATTRS_OS_VERSION2 = TMP_OS_VERSION2;
    SEMRESATTRS_PROCESS_PID2 = TMP_PROCESS_PID2;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME2 = TMP_PROCESS_EXECUTABLE_NAME2;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH2 = TMP_PROCESS_EXECUTABLE_PATH2;
    SEMRESATTRS_PROCESS_COMMAND2 = TMP_PROCESS_COMMAND2;
    SEMRESATTRS_PROCESS_COMMAND_LINE2 = TMP_PROCESS_COMMAND_LINE2;
    SEMRESATTRS_PROCESS_COMMAND_ARGS2 = TMP_PROCESS_COMMAND_ARGS2;
    SEMRESATTRS_PROCESS_OWNER2 = TMP_PROCESS_OWNER2;
    SEMRESATTRS_PROCESS_RUNTIME_NAME2 = TMP_PROCESS_RUNTIME_NAME2;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION2 = TMP_PROCESS_RUNTIME_VERSION2;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION2 = TMP_PROCESS_RUNTIME_DESCRIPTION2;
    SEMRESATTRS_SERVICE_NAME2 = TMP_SERVICE_NAME2;
    SEMRESATTRS_SERVICE_NAMESPACE2 = TMP_SERVICE_NAMESPACE2;
    SEMRESATTRS_SERVICE_INSTANCE_ID2 = TMP_SERVICE_INSTANCE_ID2;
    SEMRESATTRS_SERVICE_VERSION2 = TMP_SERVICE_VERSION2;
    SEMRESATTRS_TELEMETRY_SDK_NAME2 = TMP_TELEMETRY_SDK_NAME2;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE2 = TMP_TELEMETRY_SDK_LANGUAGE2;
    SEMRESATTRS_TELEMETRY_SDK_VERSION2 = TMP_TELEMETRY_SDK_VERSION2;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION2 = TMP_TELEMETRY_AUTO_VERSION2;
    SEMRESATTRS_WEBENGINE_NAME2 = TMP_WEBENGINE_NAME2;
    SEMRESATTRS_WEBENGINE_VERSION2 = TMP_WEBENGINE_VERSION2;
    SEMRESATTRS_WEBENGINE_DESCRIPTION2 = TMP_WEBENGINE_DESCRIPTION2;
    SemanticResourceAttributes2 = /* @__PURE__ */ createConstMap2([
      TMP_CLOUD_PROVIDER2,
      TMP_CLOUD_ACCOUNT_ID2,
      TMP_CLOUD_REGION2,
      TMP_CLOUD_AVAILABILITY_ZONE2,
      TMP_CLOUD_PLATFORM2,
      TMP_AWS_ECS_CONTAINER_ARN2,
      TMP_AWS_ECS_CLUSTER_ARN2,
      TMP_AWS_ECS_LAUNCHTYPE2,
      TMP_AWS_ECS_TASK_ARN2,
      TMP_AWS_ECS_TASK_FAMILY2,
      TMP_AWS_ECS_TASK_REVISION2,
      TMP_AWS_EKS_CLUSTER_ARN2,
      TMP_AWS_LOG_GROUP_NAMES2,
      TMP_AWS_LOG_GROUP_ARNS2,
      TMP_AWS_LOG_STREAM_NAMES2,
      TMP_AWS_LOG_STREAM_ARNS2,
      TMP_CONTAINER_NAME2,
      TMP_CONTAINER_ID2,
      TMP_CONTAINER_RUNTIME2,
      TMP_CONTAINER_IMAGE_NAME2,
      TMP_CONTAINER_IMAGE_TAG2,
      TMP_DEPLOYMENT_ENVIRONMENT2,
      TMP_DEVICE_ID2,
      TMP_DEVICE_MODEL_IDENTIFIER2,
      TMP_DEVICE_MODEL_NAME2,
      TMP_FAAS_NAME2,
      TMP_FAAS_ID2,
      TMP_FAAS_VERSION2,
      TMP_FAAS_INSTANCE2,
      TMP_FAAS_MAX_MEMORY2,
      TMP_HOST_ID2,
      TMP_HOST_NAME2,
      TMP_HOST_TYPE2,
      TMP_HOST_ARCH2,
      TMP_HOST_IMAGE_NAME2,
      TMP_HOST_IMAGE_ID2,
      TMP_HOST_IMAGE_VERSION2,
      TMP_K8S_CLUSTER_NAME2,
      TMP_K8S_NODE_NAME2,
      TMP_K8S_NODE_UID2,
      TMP_K8S_NAMESPACE_NAME2,
      TMP_K8S_POD_UID2,
      TMP_K8S_POD_NAME2,
      TMP_K8S_CONTAINER_NAME2,
      TMP_K8S_REPLICASET_UID2,
      TMP_K8S_REPLICASET_NAME2,
      TMP_K8S_DEPLOYMENT_UID2,
      TMP_K8S_DEPLOYMENT_NAME2,
      TMP_K8S_STATEFULSET_UID2,
      TMP_K8S_STATEFULSET_NAME2,
      TMP_K8S_DAEMONSET_UID2,
      TMP_K8S_DAEMONSET_NAME2,
      TMP_K8S_JOB_UID2,
      TMP_K8S_JOB_NAME2,
      TMP_K8S_CRONJOB_UID2,
      TMP_K8S_CRONJOB_NAME2,
      TMP_OS_TYPE2,
      TMP_OS_DESCRIPTION2,
      TMP_OS_NAME2,
      TMP_OS_VERSION2,
      TMP_PROCESS_PID2,
      TMP_PROCESS_EXECUTABLE_NAME2,
      TMP_PROCESS_EXECUTABLE_PATH2,
      TMP_PROCESS_COMMAND2,
      TMP_PROCESS_COMMAND_LINE2,
      TMP_PROCESS_COMMAND_ARGS2,
      TMP_PROCESS_OWNER2,
      TMP_PROCESS_RUNTIME_NAME2,
      TMP_PROCESS_RUNTIME_VERSION2,
      TMP_PROCESS_RUNTIME_DESCRIPTION2,
      TMP_SERVICE_NAME2,
      TMP_SERVICE_NAMESPACE2,
      TMP_SERVICE_INSTANCE_ID2,
      TMP_SERVICE_VERSION2,
      TMP_TELEMETRY_SDK_NAME2,
      TMP_TELEMETRY_SDK_LANGUAGE2,
      TMP_TELEMETRY_SDK_VERSION2,
      TMP_TELEMETRY_AUTO_VERSION2,
      TMP_WEBENGINE_NAME2,
      TMP_WEBENGINE_VERSION2,
      TMP_WEBENGINE_DESCRIPTION2
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS2 = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE2 = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP2 = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2;
    CLOUDPROVIDERVALUES_AWS2 = TMP_CLOUDPROVIDERVALUES_AWS2;
    CLOUDPROVIDERVALUES_AZURE2 = TMP_CLOUDPROVIDERVALUES_AZURE2;
    CLOUDPROVIDERVALUES_GCP2 = TMP_CLOUDPROVIDERVALUES_GCP2;
    CloudProviderValues2 = /* @__PURE__ */ createConstMap2([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_CLOUDPROVIDERVALUES_AWS2,
      TMP_CLOUDPROVIDERVALUES_AZURE2,
      TMP_CLOUDPROVIDERVALUES_GCP2
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC22 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS2 = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS2 = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2 = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM2 = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS2 = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2;
    CLOUDPLATFORMVALUES_AWS_EC22 = TMP_CLOUDPLATFORMVALUES_AWS_EC22;
    CLOUDPLATFORMVALUES_AWS_ECS2 = TMP_CLOUDPLATFORMVALUES_AWS_ECS2;
    CLOUDPLATFORMVALUES_AWS_EKS2 = TMP_CLOUDPLATFORMVALUES_AWS_EKS2;
    CLOUDPLATFORMVALUES_AWS_LAMBDA2 = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2;
    CLOUDPLATFORMVALUES_AZURE_VM2 = TMP_CLOUDPLATFORMVALUES_AZURE_VM2;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2;
    CLOUDPLATFORMVALUES_AZURE_AKS2 = TMP_CLOUDPLATFORMVALUES_AZURE_AKS2;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2;
    CloudPlatformValues2 = /* @__PURE__ */ createConstMap2([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
      TMP_CLOUDPLATFORMVALUES_AWS_EC22,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS2,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS2,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM2,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC22 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2 = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC22 = TMP_AWSECSLAUNCHTYPEVALUES_EC22;
    AWSECSLAUNCHTYPEVALUES_FARGATE2 = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2;
    AwsEcsLaunchtypeValues2 = /* @__PURE__ */ createConstMap2([
      TMP_AWSECSLAUNCHTYPEVALUES_EC22,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2
    ]);
    TMP_HOSTARCHVALUES_AMD642 = "amd64";
    TMP_HOSTARCHVALUES_ARM322 = "arm32";
    TMP_HOSTARCHVALUES_ARM642 = "arm64";
    TMP_HOSTARCHVALUES_IA642 = "ia64";
    TMP_HOSTARCHVALUES_PPC322 = "ppc32";
    TMP_HOSTARCHVALUES_PPC642 = "ppc64";
    TMP_HOSTARCHVALUES_X862 = "x86";
    HOSTARCHVALUES_AMD642 = TMP_HOSTARCHVALUES_AMD642;
    HOSTARCHVALUES_ARM322 = TMP_HOSTARCHVALUES_ARM322;
    HOSTARCHVALUES_ARM642 = TMP_HOSTARCHVALUES_ARM642;
    HOSTARCHVALUES_IA642 = TMP_HOSTARCHVALUES_IA642;
    HOSTARCHVALUES_PPC322 = TMP_HOSTARCHVALUES_PPC322;
    HOSTARCHVALUES_PPC642 = TMP_HOSTARCHVALUES_PPC642;
    HOSTARCHVALUES_X862 = TMP_HOSTARCHVALUES_X862;
    HostArchValues2 = /* @__PURE__ */ createConstMap2([
      TMP_HOSTARCHVALUES_AMD642,
      TMP_HOSTARCHVALUES_ARM322,
      TMP_HOSTARCHVALUES_ARM642,
      TMP_HOSTARCHVALUES_IA642,
      TMP_HOSTARCHVALUES_PPC322,
      TMP_HOSTARCHVALUES_PPC642,
      TMP_HOSTARCHVALUES_X862
    ]);
    TMP_OSTYPEVALUES_WINDOWS2 = "windows";
    TMP_OSTYPEVALUES_LINUX2 = "linux";
    TMP_OSTYPEVALUES_DARWIN2 = "darwin";
    TMP_OSTYPEVALUES_FREEBSD2 = "freebsd";
    TMP_OSTYPEVALUES_NETBSD2 = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD2 = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD2 = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX2 = "hpux";
    TMP_OSTYPEVALUES_AIX2 = "aix";
    TMP_OSTYPEVALUES_SOLARIS2 = "solaris";
    TMP_OSTYPEVALUES_Z_OS2 = "z_os";
    OSTYPEVALUES_WINDOWS2 = TMP_OSTYPEVALUES_WINDOWS2;
    OSTYPEVALUES_LINUX2 = TMP_OSTYPEVALUES_LINUX2;
    OSTYPEVALUES_DARWIN2 = TMP_OSTYPEVALUES_DARWIN2;
    OSTYPEVALUES_FREEBSD2 = TMP_OSTYPEVALUES_FREEBSD2;
    OSTYPEVALUES_NETBSD2 = TMP_OSTYPEVALUES_NETBSD2;
    OSTYPEVALUES_OPENBSD2 = TMP_OSTYPEVALUES_OPENBSD2;
    OSTYPEVALUES_DRAGONFLYBSD2 = TMP_OSTYPEVALUES_DRAGONFLYBSD2;
    OSTYPEVALUES_HPUX2 = TMP_OSTYPEVALUES_HPUX2;
    OSTYPEVALUES_AIX2 = TMP_OSTYPEVALUES_AIX2;
    OSTYPEVALUES_SOLARIS2 = TMP_OSTYPEVALUES_SOLARIS2;
    OSTYPEVALUES_Z_OS2 = TMP_OSTYPEVALUES_Z_OS2;
    OsTypeValues2 = /* @__PURE__ */ createConstMap2([
      TMP_OSTYPEVALUES_WINDOWS2,
      TMP_OSTYPEVALUES_LINUX2,
      TMP_OSTYPEVALUES_DARWIN2,
      TMP_OSTYPEVALUES_FREEBSD2,
      TMP_OSTYPEVALUES_NETBSD2,
      TMP_OSTYPEVALUES_OPENBSD2,
      TMP_OSTYPEVALUES_DRAGONFLYBSD2,
      TMP_OSTYPEVALUES_HPUX2,
      TMP_OSTYPEVALUES_AIX2,
      TMP_OSTYPEVALUES_SOLARIS2,
      TMP_OSTYPEVALUES_Z_OS2
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2 = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO2 = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2 = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2 = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2 = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP2 = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2;
    TELEMETRYSDKLANGUAGEVALUES_GO2 = TMP_TELEMETRYSDKLANGUAGEVALUES_GO2;
    TELEMETRYSDKLANGUAGEVALUES_JAVA2 = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2;
    TELEMETRYSDKLANGUAGEVALUES_PHP2 = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2;
    TELEMETRYSDKLANGUAGEVALUES_RUBY2 = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2;
    TelemetrySdkLanguageValues2 = /* @__PURE__ */ createConstMap2([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2
    ]);
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource2 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes2();
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT2, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED2, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER2, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER2, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED2, ATTR_TELEMETRY_SDK_LANGUAGE2, TELEMETRY_SDK_LANGUAGE_VALUE_CPP2, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET2, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG2, TELEMETRY_SDK_LANGUAGE_VALUE_GO2, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA2, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS2, TELEMETRY_SDK_LANGUAGE_VALUE_PHP2, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON2, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY2, TELEMETRY_SDK_LANGUAGE_VALUE_RUST2, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT2, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS2, ATTR_TELEMETRY_SDK_NAME2, ATTR_TELEMETRY_SDK_VERSION2, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE2, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT2, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED2, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED2, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED2, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED2, ATTR_ASPNETCORE_RATE_LIMITING_POLICY2, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED2, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK2, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS2, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE2, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS2, ATTR_CLIENT_ADDRESS2, ATTR_CLIENT_PORT2, ATTR_ERROR_TYPE2, ERROR_TYPE_VALUE_OTHER2, ATTR_EXCEPTION_ESCAPED2, ATTR_EXCEPTION_MESSAGE2, ATTR_EXCEPTION_STACKTRACE2, ATTR_EXCEPTION_TYPE2, ATTR_HTTP_REQUEST_HEADER2, ATTR_HTTP_REQUEST_METHOD2, HTTP_REQUEST_METHOD_VALUE_OTHER2, HTTP_REQUEST_METHOD_VALUE_CONNECT2, HTTP_REQUEST_METHOD_VALUE_DELETE2, HTTP_REQUEST_METHOD_VALUE_GET2, HTTP_REQUEST_METHOD_VALUE_HEAD2, HTTP_REQUEST_METHOD_VALUE_OPTIONS2, HTTP_REQUEST_METHOD_VALUE_PATCH2, HTTP_REQUEST_METHOD_VALUE_POST2, HTTP_REQUEST_METHOD_VALUE_PUT2, HTTP_REQUEST_METHOD_VALUE_TRACE2, ATTR_HTTP_REQUEST_METHOD_ORIGINAL2, ATTR_HTTP_REQUEST_RESEND_COUNT2, ATTR_HTTP_RESPONSE_HEADER2, ATTR_HTTP_RESPONSE_STATUS_CODE2, ATTR_HTTP_ROUTE2, ATTR_JVM_GC_ACTION2, ATTR_JVM_GC_NAME2, ATTR_JVM_MEMORY_POOL_NAME2, ATTR_JVM_MEMORY_TYPE2, JVM_MEMORY_TYPE_VALUE_HEAP2, JVM_MEMORY_TYPE_VALUE_NON_HEAP2, ATTR_JVM_THREAD_DAEMON2, ATTR_JVM_THREAD_STATE2, JVM_THREAD_STATE_VALUE_BLOCKED2, JVM_THREAD_STATE_VALUE_NEW2, JVM_THREAD_STATE_VALUE_RUNNABLE2, JVM_THREAD_STATE_VALUE_TERMINATED2, JVM_THREAD_STATE_VALUE_TIMED_WAITING2, JVM_THREAD_STATE_VALUE_WAITING2, ATTR_NETWORK_LOCAL_ADDRESS2, ATTR_NETWORK_LOCAL_PORT2, ATTR_NETWORK_PEER_ADDRESS2, ATTR_NETWORK_PEER_PORT2, ATTR_NETWORK_PROTOCOL_NAME2, ATTR_NETWORK_PROTOCOL_VERSION2, ATTR_NETWORK_TRANSPORT2, NETWORK_TRANSPORT_VALUE_PIPE2, NETWORK_TRANSPORT_VALUE_QUIC2, NETWORK_TRANSPORT_VALUE_TCP2, NETWORK_TRANSPORT_VALUE_UDP2, NETWORK_TRANSPORT_VALUE_UNIX2, ATTR_NETWORK_TYPE2, NETWORK_TYPE_VALUE_IPV42, NETWORK_TYPE_VALUE_IPV62, ATTR_OTEL_SCOPE_NAME2, ATTR_OTEL_SCOPE_VERSION2, ATTR_OTEL_STATUS_CODE2, OTEL_STATUS_CODE_VALUE_ERROR2, OTEL_STATUS_CODE_VALUE_OK2, ATTR_OTEL_STATUS_DESCRIPTION2, ATTR_SERVER_ADDRESS2, ATTR_SERVER_PORT2, ATTR_SERVICE_NAME2, ATTR_SERVICE_VERSION2, ATTR_SIGNALR_CONNECTION_STATUS2, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN2, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE2, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT2, ATTR_SIGNALR_TRANSPORT2, SIGNALR_TRANSPORT_VALUE_LONG_POLLING2, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS2, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS2, ATTR_URL_FRAGMENT2, ATTR_URL_FULL2, ATTR_URL_PATH2, ATTR_URL_QUERY2, ATTR_URL_SCHEME2, ATTR_USER_AGENT_ORIGINAL2;
var init_stable_attributes2 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT2 = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED2 = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER2 = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER2 = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED2 = "request_canceled";
    ATTR_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP2 = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET2 = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG2 = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO2 = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA2 = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS2 = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP2 = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON2 = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY2 = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST2 = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT2 = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS2 = "webjs";
    ATTR_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE2 = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT2 = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED2 = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED2 = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED2 = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED2 = "unhandled";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY2 = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED2 = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK2 = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS2 = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE2 = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS2 = "success";
    ATTR_CLIENT_ADDRESS2 = "client.address";
    ATTR_CLIENT_PORT2 = "client.port";
    ATTR_ERROR_TYPE2 = "error.type";
    ERROR_TYPE_VALUE_OTHER2 = "_OTHER";
    ATTR_EXCEPTION_ESCAPED2 = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE2 = "exception.message";
    ATTR_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE2 = "exception.type";
    ATTR_HTTP_REQUEST_HEADER2 = function(key) {
      return "http.request.header." + key;
    };
    ATTR_HTTP_REQUEST_METHOD2 = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER2 = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT2 = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE2 = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET2 = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD2 = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS2 = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH2 = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST2 = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT2 = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE2 = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL2 = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT2 = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER2 = function(key) {
      return "http.response.header." + key;
    };
    ATTR_HTTP_RESPONSE_STATUS_CODE2 = "http.response.status_code";
    ATTR_HTTP_ROUTE2 = "http.route";
    ATTR_JVM_GC_ACTION2 = "jvm.gc.action";
    ATTR_JVM_GC_NAME2 = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME2 = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE2 = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP2 = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP2 = "non_heap";
    ATTR_JVM_THREAD_DAEMON2 = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE2 = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED2 = "blocked";
    JVM_THREAD_STATE_VALUE_NEW2 = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE2 = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED2 = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING2 = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING2 = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS2 = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT2 = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS2 = "network.peer.address";
    ATTR_NETWORK_PEER_PORT2 = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME2 = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION2 = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT2 = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE2 = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC2 = "quic";
    NETWORK_TRANSPORT_VALUE_TCP2 = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP2 = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX2 = "unix";
    ATTR_NETWORK_TYPE2 = "network.type";
    NETWORK_TYPE_VALUE_IPV42 = "ipv4";
    NETWORK_TYPE_VALUE_IPV62 = "ipv6";
    ATTR_OTEL_SCOPE_NAME2 = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION2 = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE2 = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR2 = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK2 = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION2 = "otel.status_description";
    ATTR_SERVER_ADDRESS2 = "server.address";
    ATTR_SERVER_PORT2 = "server.port";
    ATTR_SERVICE_NAME2 = "service.name";
    ATTR_SERVICE_VERSION2 = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS2 = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN2 = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE2 = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT2 = "timeout";
    ATTR_SIGNALR_TRANSPORT2 = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING2 = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS2 = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS2 = "web_sockets";
    ATTR_URL_FRAGMENT2 = "url.fragment";
    ATTR_URL_FULL2 = "url.full";
    ATTR_URL_PATH2 = "url.path";
    ATTR_URL_QUERY2 = "url.query";
    ATTR_URL_SCHEME2 = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL2 = "user_agent.original";
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS2, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES2, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS2, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE2, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION2, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS2, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS2, METRIC_HTTP_CLIENT_REQUEST_DURATION2, METRIC_HTTP_SERVER_REQUEST_DURATION2, METRIC_JVM_CLASS_COUNT2, METRIC_JVM_CLASS_LOADED2, METRIC_JVM_CLASS_UNLOADED2, METRIC_JVM_CPU_COUNT2, METRIC_JVM_CPU_RECENT_UTILIZATION2, METRIC_JVM_CPU_TIME2, METRIC_JVM_GC_DURATION2, METRIC_JVM_MEMORY_COMMITTED2, METRIC_JVM_MEMORY_LIMIT2, METRIC_JVM_MEMORY_USED2, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC2, METRIC_JVM_THREAD_COUNT2, METRIC_KESTREL_ACTIVE_CONNECTIONS2, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES2, METRIC_KESTREL_CONNECTION_DURATION2, METRIC_KESTREL_QUEUED_CONNECTIONS2, METRIC_KESTREL_QUEUED_REQUESTS2, METRIC_KESTREL_REJECTED_CONNECTIONS2, METRIC_KESTREL_TLS_HANDSHAKE_DURATION2, METRIC_KESTREL_UPGRADED_CONNECTIONS2, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS2, METRIC_SIGNALR_SERVER_CONNECTION_DURATION2;
var init_stable_metrics2 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS2 = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES2 = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS2 = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE2 = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION2 = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS2 = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS2 = "aspnetcore.routing.match_attempts";
    METRIC_HTTP_CLIENT_REQUEST_DURATION2 = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION2 = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT2 = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED2 = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED2 = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT2 = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION2 = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME2 = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION2 = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED2 = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT2 = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED2 = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC2 = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT2 = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS2 = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES2 = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION2 = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS2 = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS2 = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS2 = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION2 = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS2 = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS2 = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION2 = "signalr.server.connection.duration";
  }
});

// node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED2,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED2,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED2,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED2,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED2,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER2,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER2,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED2,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE2,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS2,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT2,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE2,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY2,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT2,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED2,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK2,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS2,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS2,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT2,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE2,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED2,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE2,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE2,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE2,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER2,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD2,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL2,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT2,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER2,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE2,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE2,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION2,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME2,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME2,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE2,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON2,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE2,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS2,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT2,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS2,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT2,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME2,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION2,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT2,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE2,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME2,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION2,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE2,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION2,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS2,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT2,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME2,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION2,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS2,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT2,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE2,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME2,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION2,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT2,
  ATTR_URL_FULL: () => ATTR_URL_FULL2,
  ATTR_URL_PATH: () => ATTR_URL_PATH2,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY2,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME2,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL2,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC22,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE2,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues2,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC22,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS2,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS2,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA2,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS2,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM2,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE2,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS2,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE2,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP2,
  CloudPlatformValues: () => CloudPlatformValues2,
  CloudProviderValues: () => CloudProviderValues2,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS2,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE2,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA2,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE2,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB2,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION2,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB2,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE2,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB2,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB22,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY2,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB2,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB2,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH2,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER2,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD2,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL2,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE2,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H22,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB2,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE2,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE2,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB2,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX2,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES2,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB2,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE2,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB2,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB2,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED2,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB2,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL2,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL2,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J2,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA2,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE2,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL2,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE2,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE2,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL2,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS2,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS2,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT2,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE2,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE2,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA2,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA2,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues2,
  DbSystemValues: () => DbSystemValues2,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER2,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE2,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT2,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT2,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS2,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE2,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP2,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE2,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP2,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER2,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB2,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER2,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues2,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues2,
  FaasTriggerValues: () => FaasTriggerValues2,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD642,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM322,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM642,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA642,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC322,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC642,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X862,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_02,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_12,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_02,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC2,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY2,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT2,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE2,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET2,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD2,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS2,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER2,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH2,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST2,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT2,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE2,
  HostArchValues: () => HostArchValues2,
  HttpFlavorValues: () => HttpFlavorValues2,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP2,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP2,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED2,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW2,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE2,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED2,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING2,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING2,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED2,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT2,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC2,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS2,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE2,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS2,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES2,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS2,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS2,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION2,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE2,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS2,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION2,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION2,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT2,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED2,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED2,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT2,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION2,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME2,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION2,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED2,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT2,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED2,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC2,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT2,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS2,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES2,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION2,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS2,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS2,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS2,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION2,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS2,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS2,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION2,
  MessageTypeValues: () => MessageTypeValues2,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues2,
  MessagingOperationValues: () => MessagingOperationValues2,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL2,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI2,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED2,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC2,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP2,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP2,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP2,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER2,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE2,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX2,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE2,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC2,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP2,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP2,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX2,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV42,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV62,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues2,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues2,
  NetTransportValues: () => NetTransportValues2,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX2,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN2,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD2,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD2,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX2,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX2,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD2,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD2,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS2,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS2,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS2,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR2,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK2,
  OsTypeValues: () => OsTypeValues2,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED2,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED2,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL2,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK2,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues2,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ2,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY2,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT2,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME2,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT2,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION2,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT2,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD2,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT2,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT2,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT2,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES2,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS2,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN2,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH2,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION2,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO2,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE2,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL2,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC2,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID2,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE2,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE2,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE2,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE2,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING2,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE2,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME2,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION2,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME2,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME2,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION2,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX2,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE2,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT2,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM2,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER2,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID2,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE2,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE2,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED2,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE2,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE2,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE2,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART2,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON2,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION2,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME2,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION2,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME2,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION2,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME2,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER2,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION2,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME2,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER2,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP2,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR2,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST2,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD2,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH2,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH2,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE2,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME2,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME2,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE2,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET2,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL2,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT2,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE2,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID2,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE2,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE2,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID2,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID2,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION2,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND2,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID2,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP2,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY2,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION2,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE2,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID2,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION2,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL2,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION2,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY2,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM2,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION2,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL2,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC2,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC2,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC2,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME2,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE2,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE2,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP2,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME2,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT2,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP2,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME2,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT2,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT2,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE2,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE2,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE2,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE2,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID2,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION2,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD2,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE2,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM2,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID2,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME2,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN2,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN2,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE2,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN2,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY2,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION2,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN2,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS2,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES2,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS2,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES2,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID2,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE2,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM2,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER2,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION2,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID2,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME2,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG2,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME2,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME2,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT2,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID2,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER2,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME2,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID2,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE2,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY2,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME2,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION2,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH2,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID2,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID2,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME2,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION2,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME2,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE2,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME2,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME2,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME2,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID2,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME2,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID2,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME2,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID2,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME2,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID2,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME2,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME2,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID2,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME2,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID2,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME2,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID2,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME2,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID2,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION2,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME2,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE2,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION2,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND2,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS2,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE2,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME2,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH2,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER2,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID2,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION2,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME2,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION2,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID2,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME2,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE2,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION2,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION2,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE2,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME2,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION2,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION2,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME2,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION2,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN2,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE2,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT2,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING2,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS2,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS2,
  SemanticAttributes: () => SemanticAttributes2,
  SemanticResourceAttributes: () => SemanticResourceAttributes2,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP2,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO2,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA2,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP2,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY2,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS2,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP2,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET2,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG2,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO2,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA2,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS2,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP2,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON2,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY2,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST2,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT2,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS2,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues2
});
var init_esm3 = __esm({
  "node_modules/@opentelemetry/instrumentation-http/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace3();
    init_resource2();
    init_stable_attributes2();
    init_stable_metrics2();
  }
});

// node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js
var require_AttributeNames = __commonJS({
  "node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["HTTP_ERROR_NAME"] = "http.error_name";
      AttributeNames3["HTTP_ERROR_MESSAGE"] = "http.error_message";
      AttributeNames3["HTTP_STATUS_TEXT"] = "http.status_text";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/forwarded-parse/lib/error.js
var require_error = __commonJS({
  "node_modules/forwarded-parse/lib/error.js"(exports2, module2) {
    "use strict";
    var util3 = require("util");
    function ParseError(message, input) {
      Error.captureStackTrace(this, ParseError);
      this.name = this.constructor.name;
      this.message = message;
      this.input = input;
    }
    util3.inherits(ParseError, Error);
    module2.exports = ParseError;
  }
});

// node_modules/forwarded-parse/lib/ascii.js
var require_ascii = __commonJS({
  "node_modules/forwarded-parse/lib/ascii.js"(exports2, module2) {
    "use strict";
    function isDelimiter(code) {
      return code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code >= 58 && code <= 64 || code >= 91 && code <= 93 || code === 123 || code === 125;
    }
    function isTokenChar(code) {
      return code === 33 || code >= 35 && code <= 39 || code === 42 || code === 43 || code === 45 || code === 46 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 94 && code <= 122 || code === 124 || code === 126;
    }
    function isPrint(code) {
      return code >= 32 && code <= 126;
    }
    function isExtended(code) {
      return code >= 128 && code <= 255;
    }
    module2.exports = {
      isDelimiter,
      isTokenChar,
      isExtended,
      isPrint
    };
  }
});

// node_modules/forwarded-parse/index.js
var require_forwarded_parse = __commonJS({
  "node_modules/forwarded-parse/index.js"(exports2, module2) {
    "use strict";
    var util3 = require("util");
    var ParseError = require_error();
    var ascii = require_ascii();
    var isDelimiter = ascii.isDelimiter;
    var isTokenChar = ascii.isTokenChar;
    var isExtended = ascii.isExtended;
    var isPrint = ascii.isPrint;
    function decode(str) {
      return str.replace(/\\(.)/g, "$1");
    }
    function unexpectedCharacterMessage(header, position) {
      return util3.format(
        "Unexpected character '%s' at index %d",
        header.charAt(position),
        position
      );
    }
    function parse(header) {
      var mustUnescape = false;
      var isEscaping = false;
      var inQuotes = false;
      var forwarded = {};
      var output = [];
      var start = -1;
      var end = -1;
      var parameter;
      var code;
      for (var i = 0; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (parameter === void 0) {
          if (i !== 0 && start === -1 && (code === 32 || code === 9)) {
            continue;
          }
          if (isTokenChar(code)) {
            if (start === -1) start = i;
          } else if (code === 61 && start !== -1) {
            parameter = header.slice(start, i).toLowerCase();
            start = -1;
          } else {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
        } else {
          if (isEscaping && (code === 9 || isPrint(code) || isExtended(code))) {
            isEscaping = false;
          } else if (isTokenChar(code)) {
            if (end !== -1) {
              throw new ParseError(unexpectedCharacterMessage(header, i), header);
            }
            if (start === -1) start = i;
          } else if (isDelimiter(code) || isExtended(code)) {
            if (inQuotes) {
              if (code === 34) {
                inQuotes = false;
                end = i;
              } else if (code === 92) {
                if (start === -1) start = i;
                isEscaping = mustUnescape = true;
              } else if (start === -1) {
                start = i;
              }
            } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
              inQuotes = true;
            } else if ((code === 44 || code === 59) && (start !== -1 || end !== -1)) {
              if (start !== -1) {
                if (end === -1) end = i;
                forwarded[parameter] = mustUnescape ? decode(header.slice(start, end)) : header.slice(start, end);
              } else {
                forwarded[parameter] = "";
              }
              if (code === 44) {
                output.push(forwarded);
                forwarded = {};
              }
              parameter = void 0;
              start = end = -1;
            } else {
              throw new ParseError(unexpectedCharacterMessage(header, i), header);
            }
          } else if (code === 32 || code === 9) {
            if (end !== -1) continue;
            if (inQuotes) {
              if (start === -1) start = i;
            } else if (start !== -1) {
              end = i;
            } else {
              throw new ParseError(unexpectedCharacterMessage(header, i), header);
            }
          } else {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
        }
      }
      if (parameter === void 0 || inQuotes || start === -1 && end === -1 || code === 32 || code === 9) {
        throw new ParseError("Unexpected end of input", header);
      }
      if (start !== -1) {
        if (end === -1) end = i;
        forwarded[parameter] = mustUnescape ? decode(header.slice(start, end)) : header.slice(start, end);
      } else {
        forwarded[parameter] = "";
      }
      output.push(forwarded);
      return output;
    }
    module2.exports = parse;
  }
});

// node_modules/@opentelemetry/instrumentation-http/build/src/utils.js
var require_utils3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-http/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.headerCapture = exports2.getIncomingStableRequestMetricAttributesOnResponse = exports2.getIncomingRequestMetricAttributesOnResponse = exports2.getIncomingRequestAttributesOnResponse = exports2.getIncomingRequestMetricAttributes = exports2.getIncomingRequestAttributes = exports2.getRemoteClientAddress = exports2.getOutgoingRequestMetricAttributesOnResponse = exports2.getOutgoingRequestAttributesOnResponse = exports2.setAttributesFromHttpKind = exports2.getOutgoingRequestMetricAttributes = exports2.getOutgoingRequestAttributes = exports2.extractHostnameAndPort = exports2.isValidOptionsType = exports2.getRequestInfo = exports2.isCompressed = exports2.setResponseContentLengthAttribute = exports2.setRequestContentLengthAttribute = exports2.setSpanWithError = exports2.satisfiesPattern = exports2.parseResponseStatus = exports2.getAbsoluteUrl = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var core_1 = require_src();
    var url2 = require("url");
    var AttributeNames_1 = require_AttributeNames();
    var forwardedParse = require_forwarded_parse();
    var getAbsoluteUrl4 = (requestUrl, headers, fallbackProtocol = "http:") => {
      const reqUrlObject = requestUrl || {};
      const protocol = reqUrlObject.protocol || fallbackProtocol;
      const port = (reqUrlObject.port || "").toString();
      const path = reqUrlObject.path || "/";
      let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || "localhost";
      if (host.indexOf(":") === -1 && port && port !== "80" && port !== "443") {
        host += `:${port}`;
      }
      return `${protocol}//${host}${path}`;
    };
    exports2.getAbsoluteUrl = getAbsoluteUrl4;
    var parseResponseStatus = (kind, statusCode) => {
      const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;
      if (statusCode && statusCode >= 100 && statusCode < upperBound) {
        return api_1.SpanStatusCode.UNSET;
      }
      return api_1.SpanStatusCode.ERROR;
    };
    exports2.parseResponseStatus = parseResponseStatus;
    var satisfiesPattern2 = (constant, pattern) => {
      if (typeof pattern === "string") {
        return pattern === constant;
      } else if (pattern instanceof RegExp) {
        return pattern.test(constant);
      } else if (typeof pattern === "function") {
        return pattern(constant);
      } else {
        throw new TypeError("Pattern is in unsupported datatype");
      }
    };
    exports2.satisfiesPattern = satisfiesPattern2;
    var setSpanWithError = (span, error, semconvStability) => {
      const message = error.message;
      if ((semconvStability & 2) === 2) {
        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);
        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);
      }
      if ((semconvStability & 1) === 1) {
        span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, error.name);
      }
      span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });
      span.recordException(error);
    };
    exports2.setSpanWithError = setSpanWithError;
    var setRequestContentLengthAttribute = (request, attributes) => {
      const length = getContentLength(request.headers);
      if (length === null)
        return;
      if ((0, exports2.isCompressed)(request.headers)) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;
      } else {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;
      }
    };
    exports2.setRequestContentLengthAttribute = setRequestContentLengthAttribute;
    var setResponseContentLengthAttribute = (response, attributes) => {
      const length = getContentLength(response.headers);
      if (length === null)
        return;
      if ((0, exports2.isCompressed)(response.headers)) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;
      } else {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;
      }
    };
    exports2.setResponseContentLengthAttribute = setResponseContentLengthAttribute;
    function getContentLength(headers) {
      const contentLengthHeader = headers["content-length"];
      if (contentLengthHeader === void 0)
        return null;
      const contentLength = parseInt(contentLengthHeader, 10);
      if (isNaN(contentLength))
        return null;
      return contentLength;
    }
    var isCompressed = (headers) => {
      const encoding = headers["content-encoding"];
      return !!encoding && encoding !== "identity";
    };
    exports2.isCompressed = isCompressed;
    function stringUrlToHttpOptions2(stringUrl) {
      const { hostname: hostname2, pathname, port, username, password, search, protocol, hash, href, origin, host } = new URL(stringUrl);
      const options = {
        protocol,
        hostname: hostname2 && hostname2[0] === "[" ? hostname2.slice(1, -1) : hostname2,
        hash,
        search,
        pathname,
        path: `${pathname || ""}${search || ""}`,
        href,
        origin,
        host
      };
      if (port !== "") {
        options.port = Number(port);
      }
      if (username || password) {
        options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
      }
      return options;
    }
    var getRequestInfo2 = (logger2, options, extraOptions) => {
      let pathname;
      let origin;
      let optionsParsed;
      let invalidUrl = false;
      if (typeof options === "string") {
        try {
          const convertedOptions = stringUrlToHttpOptions2(options);
          optionsParsed = convertedOptions;
          pathname = convertedOptions.pathname || "/";
        } catch (e) {
          invalidUrl = true;
          logger2.verbose("Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:", e);
          optionsParsed = {
            path: options
          };
          pathname = optionsParsed.path || "/";
        }
        origin = `${optionsParsed.protocol || "http:"}//${optionsParsed.host}`;
        if (extraOptions !== void 0) {
          Object.assign(optionsParsed, extraOptions);
        }
      } else if (options instanceof url2.URL) {
        optionsParsed = {
          protocol: options.protocol,
          hostname: typeof options.hostname === "string" && options.hostname.startsWith("[") ? options.hostname.slice(1, -1) : options.hostname,
          path: `${options.pathname || ""}${options.search || ""}`
        };
        if (options.port !== "") {
          optionsParsed.port = Number(options.port);
        }
        if (options.username || options.password) {
          optionsParsed.auth = `${options.username}:${options.password}`;
        }
        pathname = options.pathname;
        origin = options.origin;
        if (extraOptions !== void 0) {
          Object.assign(optionsParsed, extraOptions);
        }
      } else {
        optionsParsed = Object.assign({ protocol: options.host ? "http:" : void 0 }, options);
        const hostname2 = optionsParsed.host || (optionsParsed.port != null ? `${optionsParsed.hostname}${optionsParsed.port}` : optionsParsed.hostname);
        origin = `${optionsParsed.protocol || "http:"}//${hostname2}`;
        pathname = options.pathname;
        if (!pathname && optionsParsed.path) {
          try {
            const parsedUrl = new URL(optionsParsed.path, origin);
            pathname = parsedUrl.pathname || "/";
          } catch (e) {
            pathname = "/";
          }
        }
      }
      const method = optionsParsed.method ? optionsParsed.method.toUpperCase() : "GET";
      return { origin, pathname, method, optionsParsed, invalidUrl };
    };
    exports2.getRequestInfo = getRequestInfo2;
    var isValidOptionsType = (options) => {
      if (!options) {
        return false;
      }
      const type = typeof options;
      return type === "string" || type === "object" && !Array.isArray(options);
    };
    exports2.isValidOptionsType = isValidOptionsType;
    var extractHostnameAndPort = (requestOptions) => {
      var _a;
      if (requestOptions.hostname && requestOptions.port) {
        return { hostname: requestOptions.hostname, port: requestOptions.port };
      }
      const matches = ((_a = requestOptions.host) === null || _a === void 0 ? void 0 : _a.match(/^([^:/ ]+)(:\d{1,5})?/)) || null;
      const hostname2 = requestOptions.hostname || (matches === null ? "localhost" : matches[1]);
      let port = requestOptions.port;
      if (!port) {
        if (matches && matches[2]) {
          port = matches[2].substring(1);
        } else {
          port = requestOptions.protocol === "https:" ? "443" : "80";
        }
      }
      return { hostname: hostname2, port };
    };
    exports2.extractHostnameAndPort = extractHostnameAndPort;
    var getOutgoingRequestAttributes = (requestOptions, options, semconvStability) => {
      var _a, _b;
      const hostname2 = options.hostname;
      const port = options.port;
      const method = (_a = requestOptions.method) !== null && _a !== void 0 ? _a : "GET";
      const normalizedMethod = normalizeMethod(method);
      const headers = requestOptions.headers || {};
      const userAgent = headers["user-agent"];
      const urlFull = (0, exports2.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`);
      const oldAttributes = {
        [semantic_conventions_1.SEMATTRS_HTTP_URL]: urlFull,
        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,
        [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || "/",
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname2,
        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_b = headers.host) !== null && _b !== void 0 ? _b : `${hostname2}:${port}`
      };
      const newAttributes = {
        // Required attributes
        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,
        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: hostname2,
        [semantic_conventions_1.ATTR_SERVER_PORT]: Number(port),
        [semantic_conventions_1.ATTR_URL_FULL]: urlFull
        // leaving out protocol version, it is not yet negotiated
        // leaving out protocol name, it is only required when protocol version is set
        // retries and redirects not supported
        // Opt-in attributes left off for now
      };
      if (method !== normalizedMethod) {
        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;
      }
      if (userAgent !== void 0) {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;
      }
      switch (semconvStability) {
        case 1:
          return Object.assign(newAttributes, options.hookAttributes);
        case 2:
          return Object.assign(oldAttributes, options.hookAttributes);
      }
      return Object.assign(oldAttributes, newAttributes, options.hookAttributes);
    };
    exports2.getOutgoingRequestAttributes = getOutgoingRequestAttributes;
    var getOutgoingRequestMetricAttributes = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];
      return metricAttributes;
    };
    exports2.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;
    var setAttributesFromHttpKind = (kind, attributes) => {
      if (kind) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;
        if (kind.toUpperCase() !== "QUIC") {
          attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;
        } else {
          attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;
        }
      }
    };
    exports2.setAttributesFromHttpKind = setAttributesFromHttpKind;
    var getOutgoingRequestAttributesOnResponse = (response, semconvStability) => {
      const { statusCode, statusMessage, httpVersion, socket } = response;
      const oldAttributes = {};
      const stableAttributes = {};
      if (statusCode != null) {
        stableAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode;
      }
      if (socket) {
        const { remoteAddress, remotePort } = socket;
        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;
        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;
        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS] = remoteAddress;
        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_PORT] = remotePort;
        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = response.httpVersion;
      }
      (0, exports2.setResponseContentLengthAttribute)(response, oldAttributes);
      if (statusCode) {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
        oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
      }
      (0, exports2.setAttributesFromHttpKind)(httpVersion, oldAttributes);
      switch (semconvStability) {
        case 1:
          return stableAttributes;
        case 2:
          return oldAttributes;
      }
      return Object.assign(oldAttributes, stableAttributes);
    };
    exports2.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;
    var getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];
      return metricAttributes;
    };
    exports2.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;
    function parseHostHeader(hostHeader, proto) {
      const parts = hostHeader.split(":");
      if (parts.length === 1) {
        if (proto === "http") {
          return { host: parts[0], port: "80" };
        }
        if (proto === "https") {
          return { host: parts[0], port: "443" };
        }
        return { host: parts[0] };
      }
      if (parts.length === 2) {
        return {
          host: parts[0],
          port: parts[1]
        };
      }
      if (parts[0].startsWith("[")) {
        if (parts[parts.length - 1].endsWith("]")) {
          if (proto === "http") {
            return { host: hostHeader, port: "80" };
          }
          if (proto === "https") {
            return { host: hostHeader, port: "443" };
          }
        } else if (parts[parts.length - 2].endsWith("]")) {
          return {
            host: parts.slice(0, -1).join(":"),
            port: parts[parts.length - 1]
          };
        }
      }
      return { host: hostHeader };
    }
    function getServerAddress(request, component) {
      const forwardedHeader = request.headers["forwarded"];
      if (forwardedHeader) {
        for (const entry of parseForwardedHeader2(forwardedHeader)) {
          if (entry.host) {
            return parseHostHeader(entry.host, entry.proto);
          }
        }
      }
      const xForwardedHost = request.headers["x-forwarded-host"];
      if (typeof xForwardedHost === "string") {
        if (typeof request.headers["x-forwarded-proto"] === "string") {
          return parseHostHeader(xForwardedHost, request.headers["x-forwarded-proto"]);
        }
        if (Array.isArray(request.headers["x-forwarded-proto"])) {
          return parseHostHeader(xForwardedHost, request.headers["x-forwarded-proto"][0]);
        }
        return parseHostHeader(xForwardedHost);
      } else if (Array.isArray(xForwardedHost) && typeof xForwardedHost[0] === "string" && xForwardedHost[0].length > 0) {
        if (typeof request.headers["x-forwarded-proto"] === "string") {
          return parseHostHeader(xForwardedHost[0], request.headers["x-forwarded-proto"]);
        }
        if (Array.isArray(request.headers["x-forwarded-proto"])) {
          return parseHostHeader(xForwardedHost[0], request.headers["x-forwarded-proto"][0]);
        }
        return parseHostHeader(xForwardedHost[0]);
      }
      const host = request.headers["host"];
      if (typeof host === "string" && host.length > 0) {
        return parseHostHeader(host, component);
      }
      return null;
    }
    function getRemoteClientAddress(request) {
      const forwardedHeader = request.headers["forwarded"];
      if (forwardedHeader) {
        for (const entry of parseForwardedHeader2(forwardedHeader)) {
          if (entry.for) {
            return entry.for;
          }
        }
      }
      const xForwardedFor = request.headers["x-forwarded-for"];
      if (typeof xForwardedFor === "string") {
        return xForwardedFor;
      } else if (Array.isArray(xForwardedFor)) {
        return xForwardedFor[0];
      }
      const remote = request.socket.remoteAddress;
      if (remote) {
        return remote;
      }
      return null;
    }
    exports2.getRemoteClientAddress = getRemoteClientAddress;
    function getInfoFromIncomingMessage(component, request, logger2) {
      var _a, _b;
      try {
        if (request.headers.host) {
          return new URL((_a = request.url) !== null && _a !== void 0 ? _a : "/", `${component}://${request.headers.host}`);
        } else {
          const unsafeParsedUrl = new URL(
            (_b = request.url) !== null && _b !== void 0 ? _b : "/",
            // using localhost as a workaround to still use the URL constructor for parsing
            `${component}://localhost`
          );
          return {
            pathname: unsafeParsedUrl.pathname,
            search: unsafeParsedUrl.search,
            toString: function() {
              return unsafeParsedUrl.pathname + unsafeParsedUrl.search;
            }
          };
        }
      } catch (e) {
        logger2.verbose("Unable to get URL from request", e);
        return {};
      }
    }
    var getIncomingRequestAttributes = (request, options, logger2) => {
      const headers = request.headers;
      const userAgent = headers["user-agent"];
      const ips = headers["x-forwarded-for"];
      const httpVersion = request.httpVersion;
      const host = headers.host;
      const hostname2 = (host === null || host === void 0 ? void 0 : host.replace(/^(.*)(:[0-9]{1,5})/, "$1")) || "localhost";
      const method = request.method;
      const normalizedMethod = normalizeMethod(method);
      const serverAddress = getServerAddress(request, options.component);
      const serverName = options.serverName;
      const remoteClientAddress = getRemoteClientAddress(request);
      const newAttributes = {
        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,
        [semantic_conventions_1.ATTR_URL_SCHEME]: options.component,
        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.host,
        [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: request.socket.remoteAddress,
        [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: request.socket.remotePort,
        [semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]: request.httpVersion,
        [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent
      };
      const parsedUrl = getInfoFromIncomingMessage(options.component, request, logger2);
      if ((parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) != null) {
        newAttributes[semantic_conventions_1.ATTR_URL_PATH] = parsedUrl.pathname;
      }
      if (remoteClientAddress != null) {
        newAttributes[semantic_conventions_1.ATTR_CLIENT_ADDRESS] = remoteClientAddress;
      }
      if ((serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port) != null) {
        newAttributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverAddress.port);
      }
      if (method !== normalizedMethod) {
        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;
      }
      const oldAttributes = {
        [semantic_conventions_1.SEMATTRS_HTTP_URL]: parsedUrl.toString(),
        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,
        [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname2,
        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,
        [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component
      };
      if (typeof ips === "string") {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(",")[0];
      }
      if (typeof serverName === "string") {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;
      }
      if (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] = (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) + (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.search) || "/";
      }
      if (userAgent !== void 0) {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;
      }
      (0, exports2.setRequestContentLengthAttribute)(request, oldAttributes);
      (0, exports2.setAttributesFromHttpKind)(httpVersion, oldAttributes);
      switch (options.semconvStability) {
        case 1:
          return Object.assign(newAttributes, options.hookAttributes);
        case 2:
          return Object.assign(oldAttributes, options.hookAttributes);
      }
      return Object.assign(oldAttributes, newAttributes, options.hookAttributes);
    };
    exports2.getIncomingRequestAttributes = getIncomingRequestAttributes;
    var getIncomingRequestMetricAttributes = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];
      return metricAttributes;
    };
    exports2.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;
    var getIncomingRequestAttributesOnResponse = (request, response, semconvStability) => {
      const { socket } = request;
      const { statusCode, statusMessage } = response;
      const newAttributes = {
        [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode
      };
      const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
      const oldAttributes = {};
      if (socket) {
        const { localAddress, localPort, remoteAddress, remotePort } = socket;
        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;
        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;
        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;
        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;
      }
      oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
      oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
      if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP && rpcMetadata.route !== void 0) {
        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;
        newAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;
      }
      switch (semconvStability) {
        case 1:
          return newAttributes;
        case 2:
          return oldAttributes;
      }
      return Object.assign(oldAttributes, newAttributes);
    };
    exports2.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;
    var getIncomingRequestMetricAttributesOnResponse = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];
      if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== void 0) {
        metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
      }
      return metricAttributes;
    };
    exports2.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;
    var getIncomingStableRequestMetricAttributesOnResponse = (spanAttributes) => {
      const metricAttributes = {};
      if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== void 0) {
        metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
      }
      if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
        metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];
      }
      return metricAttributes;
    };
    exports2.getIncomingStableRequestMetricAttributesOnResponse = getIncomingStableRequestMetricAttributesOnResponse;
    function headerCapture(type, headers) {
      const normalizedHeaders = /* @__PURE__ */ new Map();
      for (let i = 0, len = headers.length; i < len; i++) {
        const capturedHeader = headers[i].toLowerCase();
        normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, "_"));
      }
      return (span, getHeader) => {
        for (const capturedHeader of normalizedHeaders.keys()) {
          const value = getHeader(capturedHeader);
          if (value === void 0) {
            continue;
          }
          const normalizedHeader = normalizedHeaders.get(capturedHeader);
          const key = `http.${type}.header.${normalizedHeader}`;
          if (typeof value === "string") {
            span.setAttribute(key, [value]);
          } else if (Array.isArray(value)) {
            span.setAttribute(key, value);
          } else {
            span.setAttribute(key, [value]);
          }
        }
      };
    }
    exports2.headerCapture = headerCapture;
    var KNOWN_METHODS = /* @__PURE__ */ new Set([
      // methods from https://www.rfc-editor.org/rfc/rfc9110.html#name-methods
      "GET",
      "HEAD",
      "POST",
      "PUT",
      "DELETE",
      "CONNECT",
      "OPTIONS",
      "TRACE",
      // PATCH from https://www.rfc-editor.org/rfc/rfc5789.html
      "PATCH"
    ]);
    function normalizeMethod(method) {
      if (method == null) {
        return "GET";
      }
      const upper = method.toUpperCase();
      if (KNOWN_METHODS.has(upper)) {
        return upper;
      }
      return "_OTHER";
    }
    function parseForwardedHeader2(header) {
      try {
        return forwardedParse(header);
      } catch (_a) {
        return [];
      }
    }
  }
});

// node_modules/@opentelemetry/instrumentation-http/build/src/http.js
var require_http = __commonJS({
  "node_modules/@opentelemetry/instrumentation-http/build/src/http.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var semver = require_semver2();
    var url2 = require("url");
    var version_1 = require_version2();
    var instrumentation_1 = require_src4();
    var core_2 = require_src();
    var events_1 = require("events");
    var semantic_conventions_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var utils_1 = require_utils3();
    var HttpInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super("@opentelemetry/instrumentation-http", version_1.VERSION, config2);
        this._spanNotEnded = /* @__PURE__ */ new WeakSet();
        this._semconvStability = 2;
        this._headerCapture = this._createHeaderCapture();
        for (const entry of (0, core_2.getEnv)().OTEL_SEMCONV_STABILITY_OPT_IN) {
          if (entry.toLowerCase() === "http/dup") {
            this._semconvStability = 3;
            break;
          } else if (entry.toLowerCase() === "http") {
            this._semconvStability = 1;
          }
        }
      }
      _updateMetricInstruments() {
        this._oldHttpServerDurationHistogram = this.meter.createHistogram("http.server.duration", {
          description: "Measures the duration of inbound HTTP requests.",
          unit: "ms",
          valueType: api_1.ValueType.DOUBLE
        });
        this._oldHttpClientDurationHistogram = this.meter.createHistogram("http.client.duration", {
          description: "Measures the duration of outbound HTTP requests.",
          unit: "ms",
          valueType: api_1.ValueType.DOUBLE
        });
        this._stableHttpServerDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_SERVER_REQUEST_DURATION, {
          description: "Duration of HTTP server requests.",
          unit: "s",
          valueType: api_1.ValueType.DOUBLE,
          advice: {
            explicitBucketBoundaries: [
              5e-3,
              0.01,
              0.025,
              0.05,
              0.075,
              0.1,
              0.25,
              0.5,
              0.75,
              1,
              2.5,
              5,
              7.5,
              10
            ]
          }
        });
        this._stableHttpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {
          description: "Duration of HTTP client requests.",
          unit: "s",
          valueType: api_1.ValueType.DOUBLE,
          advice: {
            explicitBucketBoundaries: [
              5e-3,
              0.01,
              0.025,
              0.05,
              0.075,
              0.1,
              0.25,
              0.5,
              0.75,
              1,
              2.5,
              5,
              7.5,
              10
            ]
          }
        });
      }
      _recordServerDuration(durationMs, oldAttributes, stableAttributes) {
        if ((this._semconvStability & 2) === 2) {
          this._oldHttpServerDurationHistogram.record(durationMs, oldAttributes);
        }
        if ((this._semconvStability & 1) === 1) {
          this._stableHttpServerDurationHistogram.record(durationMs / 1e3, stableAttributes);
        }
      }
      _recordClientDuration(durationMs, oldAttributes, stableAttributes) {
        if ((this._semconvStability & 2) === 2) {
          this._oldHttpClientDurationHistogram.record(durationMs, oldAttributes);
        }
        if ((this._semconvStability & 1) === 1) {
          this._stableHttpClientDurationHistogram.record(durationMs / 1e3, stableAttributes);
        }
      }
      setConfig(config2 = {}) {
        super.setConfig(config2);
        this._headerCapture = this._createHeaderCapture();
      }
      init() {
        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
      }
      _getHttpInstrumentation() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition("http", ["*"], (moduleExports) => {
          const isESM = moduleExports[Symbol.toStringTag] === "Module";
          if (!this.getConfig().disableOutgoingRequestInstrumentation) {
            const patchedRequest = this._wrap(moduleExports, "request", this._getPatchOutgoingRequestFunction("http"));
            const patchedGet = this._wrap(moduleExports, "get", this._getPatchOutgoingGetFunction(patchedRequest));
            if (isESM) {
              moduleExports.default.request = patchedRequest;
              moduleExports.default.get = patchedGet;
            }
          }
          if (!this.getConfig().disableIncomingRequestInstrumentation) {
            this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("http"));
          }
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === void 0)
            return;
          if (!this.getConfig().disableOutgoingRequestInstrumentation) {
            this._unwrap(moduleExports, "request");
            this._unwrap(moduleExports, "get");
          }
          if (!this.getConfig().disableIncomingRequestInstrumentation) {
            this._unwrap(moduleExports.Server.prototype, "emit");
          }
        });
      }
      _getHttpsInstrumentation() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition("https", ["*"], (moduleExports) => {
          const isESM = moduleExports[Symbol.toStringTag] === "Module";
          if (!this.getConfig().disableOutgoingRequestInstrumentation) {
            const patchedRequest = this._wrap(moduleExports, "request", this._getPatchHttpsOutgoingRequestFunction("https"));
            const patchedGet = this._wrap(moduleExports, "get", this._getPatchHttpsOutgoingGetFunction(patchedRequest));
            if (isESM) {
              moduleExports.default.request = patchedRequest;
              moduleExports.default.get = patchedGet;
            }
          }
          if (!this.getConfig().disableIncomingRequestInstrumentation) {
            this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("https"));
          }
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === void 0)
            return;
          if (!this.getConfig().disableOutgoingRequestInstrumentation) {
            this._unwrap(moduleExports, "request");
            this._unwrap(moduleExports, "get");
          }
          if (!this.getConfig().disableIncomingRequestInstrumentation) {
            this._unwrap(moduleExports.Server.prototype, "emit");
          }
        });
      }
      /**
       * Creates spans for incoming requests, restoring spans' context if applied.
       */
      _getPatchIncomingRequestFunction(component) {
        return (original) => {
          return this._incomingRequestFunction(component, original);
        };
      }
      /**
       * Creates spans for outgoing requests, sending spans' context for distributed
       * tracing.
       */
      _getPatchOutgoingRequestFunction(component) {
        return (original) => {
          return this._outgoingRequestFunction(component, original);
        };
      }
      _getPatchOutgoingGetFunction(clientRequest) {
        return (_original) => {
          return function outgoingGetRequest(options, ...args) {
            const req = clientRequest(options, ...args);
            req.end();
            return req;
          };
        };
      }
      /** Patches HTTPS outgoing requests */
      _getPatchHttpsOutgoingRequestFunction(component) {
        return (original) => {
          const instrumentation = this;
          return function httpsOutgoingRequest(options, ...args) {
            var _a;
            if (component === "https" && typeof options === "object" && ((_a = options === null || options === void 0 ? void 0 : options.constructor) === null || _a === void 0 ? void 0 : _a.name) !== "URL") {
              options = Object.assign({}, options);
              instrumentation._setDefaultOptions(options);
            }
            return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);
          };
        };
      }
      _setDefaultOptions(options) {
        options.protocol = options.protocol || "https:";
        options.port = options.port || 443;
      }
      /** Patches HTTPS outgoing get requests */
      _getPatchHttpsOutgoingGetFunction(clientRequest) {
        return (original) => {
          const instrumentation = this;
          return function httpsOutgoingRequest(options, ...args) {
            return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);
          };
        };
      }
      /**
       * Attach event listeners to a client request to end span and add span attributes.
       *
       * @param request The original request object.
       * @param span representing the current operation
       * @param startTime representing the start time of the request to calculate duration in Metric
       * @param oldMetricAttributes metric attributes for old semantic conventions
       * @param stableMetricAttributes metric attributes for new semantic conventions
       */
      _traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes) {
        if (this.getConfig().requestHook) {
          this._callRequestHook(span, request);
        }
        let responseFinished = false;
        request.prependListener("response", (response) => {
          this._diag.debug("outgoingRequest on response()");
          if (request.listenerCount("response") <= 1) {
            response.resume();
          }
          const responseAttributes = (0, utils_1.getOutgoingRequestAttributesOnResponse)(response, this._semconvStability);
          span.setAttributes(responseAttributes);
          oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getOutgoingRequestMetricAttributesOnResponse)(responseAttributes));
          if (this.getConfig().responseHook) {
            this._callResponseHook(span, response);
          }
          this._headerCapture.client.captureRequestHeaders(span, (header) => request.getHeader(header));
          this._headerCapture.client.captureResponseHeaders(span, (header) => response.headers[header]);
          api_1.context.bind(api_1.context.active(), response);
          const endHandler = () => {
            this._diag.debug("outgoingRequest on end()");
            if (responseFinished) {
              return;
            }
            responseFinished = true;
            let status;
            if (response.aborted && !response.complete) {
              status = { code: api_1.SpanStatusCode.ERROR };
            } else {
              status = {
                code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.CLIENT, response.statusCode)
              };
            }
            span.setStatus(status);
            if (this.getConfig().applyCustomAttributesOnSpan) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {
              }, true);
            }
            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
          };
          response.on("end", endHandler);
          if (semver.lt(process.version, "16.0.0")) {
            response.on("close", endHandler);
          }
          response.on(events_1.errorMonitor, (error) => {
            this._diag.debug("outgoingRequest on error()", error);
            if (responseFinished) {
              return;
            }
            responseFinished = true;
            (0, utils_1.setSpanWithError)(span, error, this._semconvStability);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: error.message
            });
            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
          });
        });
        request.on("close", () => {
          this._diag.debug("outgoingRequest on request close()");
          if (request.aborted || responseFinished) {
            return;
          }
          responseFinished = true;
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
        });
        request.on(events_1.errorMonitor, (error) => {
          this._diag.debug("outgoingRequest on request error()", error);
          if (responseFinished) {
            return;
          }
          responseFinished = true;
          (0, utils_1.setSpanWithError)(span, error, this._semconvStability);
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
        });
        this._diag.debug("http.ClientRequest return request");
        return request;
      }
      _incomingRequestFunction(component, original) {
        const instrumentation = this;
        return function incomingRequest(event, ...args) {
          if (event !== "request") {
            return original.apply(this, [event, ...args]);
          }
          const request = args[0];
          const response = args[1];
          const method = request.method || "GET";
          instrumentation._diag.debug(`${component} instrumentation incomingRequest`);
          if ((0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            var _a, _b;
            return (_b = (_a = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, request);
          }, (e) => {
            if (e != null) {
              instrumentation._diag.error("caught ignoreIncomingRequestHook error: ", e);
            }
          }, true)) {
            return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
              api_1.context.bind(api_1.context.active(), request);
              api_1.context.bind(api_1.context.active(), response);
              return original.apply(this, [event, ...args]);
            });
          }
          const headers = request.headers;
          const spanAttributes = (0, utils_1.getIncomingRequestAttributes)(request, {
            component,
            serverName: instrumentation.getConfig().serverName,
            hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook),
            semconvStability: instrumentation._semconvStability
          }, instrumentation._diag);
          const spanOptions = {
            kind: api_1.SpanKind.SERVER,
            attributes: spanAttributes
          };
          const startTime = (0, core_1.hrTime)();
          const oldMetricAttributes = (0, utils_1.getIncomingRequestMetricAttributes)(spanAttributes);
          const stableMetricAttributes = {
            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: spanAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],
            [semantic_conventions_1.ATTR_URL_SCHEME]: spanAttributes[semantic_conventions_1.ATTR_URL_SCHEME]
          };
          if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {
            stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];
          }
          const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
          const span = instrumentation._startHttpSpan(method, spanOptions, ctx);
          const rpcMetadata = {
            type: core_2.RPCType.HTTP,
            span
          };
          return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () => {
            api_1.context.bind(api_1.context.active(), request);
            api_1.context.bind(api_1.context.active(), response);
            if (instrumentation.getConfig().requestHook) {
              instrumentation._callRequestHook(span, request);
            }
            if (instrumentation.getConfig().responseHook) {
              instrumentation._callResponseHook(span, response);
            }
            instrumentation._headerCapture.server.captureRequestHeaders(span, (header) => request.headers[header]);
            let hasError = false;
            response.on("close", () => {
              if (hasError) {
                return;
              }
              instrumentation._onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime);
            });
            response.on(events_1.errorMonitor, (err) => {
              hasError = true;
              instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, err);
            });
            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [event, ...args]), (error) => {
              if (error) {
                (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);
                instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);
                throw error;
              }
            });
          });
        };
      }
      _outgoingRequestFunction(component, original) {
        const instrumentation = this;
        return function outgoingRequest(options, ...args) {
          if (!(0, utils_1.isValidOptionsType)(options)) {
            return original.apply(this, [options, ...args]);
          }
          const extraOptions = typeof args[0] === "object" && (typeof options === "string" || options instanceof url2.URL) ? args.shift() : void 0;
          const { method, invalidUrl, optionsParsed } = (0, utils_1.getRequestInfo)(instrumentation._diag, options, extraOptions);
          if (component === "http" && semver.lt(process.version, "9.0.0") && optionsParsed.protocol === "https:") {
            return original.apply(this, [optionsParsed, ...args]);
          }
          if ((0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            var _a, _b;
            return (_b = (_a = instrumentation.getConfig()).ignoreOutgoingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, optionsParsed);
          }, (e) => {
            if (e != null) {
              instrumentation._diag.error("caught ignoreOutgoingRequestHook error: ", e);
            }
          }, true)) {
            return original.apply(this, [optionsParsed, ...args]);
          }
          const { hostname: hostname2, port } = (0, utils_1.extractHostnameAndPort)(optionsParsed);
          const attributes = (0, utils_1.getOutgoingRequestAttributes)(optionsParsed, {
            component,
            port,
            hostname: hostname2,
            hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook)
          }, instrumentation._semconvStability);
          const startTime = (0, core_1.hrTime)();
          const oldMetricAttributes = (0, utils_1.getOutgoingRequestMetricAttributes)(attributes);
          const stableMetricAttributes = {
            [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],
            [semantic_conventions_1.ATTR_SERVER_ADDRESS]: attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS],
            [semantic_conventions_1.ATTR_SERVER_PORT]: attributes[semantic_conventions_1.ATTR_SERVER_PORT]
          };
          if (attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
            stableMetricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];
          }
          if (attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {
            stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];
          }
          const spanOptions = {
            kind: api_1.SpanKind.CLIENT,
            attributes
          };
          const span = instrumentation._startHttpSpan(method, spanOptions);
          const parentContext = api_1.context.active();
          const requestContext = api_1.trace.setSpan(parentContext, span);
          if (!optionsParsed.headers) {
            optionsParsed.headers = {};
          } else {
            optionsParsed.headers = Object.assign({}, optionsParsed.headers);
          }
          api_1.propagation.inject(requestContext, optionsParsed.headers);
          return api_1.context.with(requestContext, () => {
            const cb = args[args.length - 1];
            if (typeof cb === "function") {
              args[args.length - 1] = api_1.context.bind(parentContext, cb);
            }
            const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              if (invalidUrl) {
                return original.apply(this, [options, ...args]);
              } else {
                return original.apply(this, [optionsParsed, ...args]);
              }
            }, (error) => {
              if (error) {
                (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);
                instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);
                throw error;
              }
            });
            instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);
            api_1.context.bind(parentContext, request);
            return instrumentation._traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes);
          });
        };
      }
      _onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime) {
        const attributes = (0, utils_1.getIncomingRequestAttributesOnResponse)(request, response, this._semconvStability);
        oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getIncomingRequestMetricAttributesOnResponse)(attributes));
        stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getIncomingStableRequestMetricAttributesOnResponse)(attributes));
        this._headerCapture.server.captureResponseHeaders(span, (header) => response.getHeader(header));
        span.setAttributes(attributes).setStatus({
          code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.SERVER, response.statusCode)
        });
        const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
        if (route) {
          span.updateName(`${request.method || "GET"} ${route}`);
        }
        if (this.getConfig().applyCustomAttributesOnSpan) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {
          }, true);
        }
        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);
      }
      _onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {
        (0, utils_1.setSpanWithError)(span, error, this._semconvStability);
        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);
      }
      _startHttpSpan(name, options, ctx = api_1.context.active()) {
        const requireParent = options.kind === api_1.SpanKind.CLIENT ? this.getConfig().requireParentforOutgoingSpans : this.getConfig().requireParentforIncomingSpans;
        let span;
        const currentSpan = api_1.trace.getSpan(ctx);
        if (requireParent === true && currentSpan === void 0) {
          span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
        } else if (requireParent === true && (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext().isRemote)) {
          span = currentSpan;
        } else {
          span = this.tracer.startSpan(name, options, ctx);
        }
        this._spanNotEnded.add(span);
        return span;
      }
      _closeHttpSpan(span, spanKind, startTime, oldMetricAttributes, stableMetricAttributes) {
        if (!this._spanNotEnded.has(span)) {
          return;
        }
        span.end();
        this._spanNotEnded.delete(span);
        const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));
        if (spanKind === api_1.SpanKind.SERVER) {
          this._recordServerDuration(duration, oldMetricAttributes, stableMetricAttributes);
        } else if (spanKind === api_1.SpanKind.CLIENT) {
          this._recordClientDuration(duration, oldMetricAttributes, stableMetricAttributes);
        }
      }
      _callResponseHook(span, response) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().responseHook(span, response), () => {
        }, true);
      }
      _callRequestHook(span, request) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(span, request), () => {
        }, true);
      }
      _callStartSpanHook(request, hookFunc) {
        if (typeof hookFunc === "function") {
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => hookFunc(request), () => {
          }, true);
        }
      }
      _createHeaderCapture() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const config2 = this.getConfig();
        return {
          client: {
            captureRequestHeaders: (0, utils_1.headerCapture)("request", (_c = (_b = (_a = config2.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.client) === null || _b === void 0 ? void 0 : _b.requestHeaders) !== null && _c !== void 0 ? _c : []),
            captureResponseHeaders: (0, utils_1.headerCapture)("response", (_f = (_e = (_d = config2.headersToSpanAttributes) === null || _d === void 0 ? void 0 : _d.client) === null || _e === void 0 ? void 0 : _e.responseHeaders) !== null && _f !== void 0 ? _f : [])
          },
          server: {
            captureRequestHeaders: (0, utils_1.headerCapture)("request", (_j = (_h = (_g = config2.headersToSpanAttributes) === null || _g === void 0 ? void 0 : _g.server) === null || _h === void 0 ? void 0 : _h.requestHeaders) !== null && _j !== void 0 ? _j : []),
            captureResponseHeaders: (0, utils_1.headerCapture)("response", (_m = (_l = (_k = config2.headersToSpanAttributes) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.responseHeaders) !== null && _m !== void 0 ? _m : [])
          }
        };
      }
    };
    exports2.HttpInstrumentation = HttpInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-http/build/src/index.js
var require_src5 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-http/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpInstrumentation = void 0;
    var http_1 = require_http();
    Object.defineProperty(exports2, "HttpInstrumentation", { enumerable: true, get: function() {
      return http_1.HttpInstrumentation;
    } });
  }
});

// node_modules/@opentelemetry/instrumentation-undici/build/src/version.js
var require_version3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-undici/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.10.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-undici";
  }
});

// node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js
var require_SemanticAttributes = __commonJS({
  "node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticAttributes = void 0;
    exports2.SemanticAttributes = {
      /**
       * State of the HTTP connection in the HTTP connection pool.
       */
      HTTP_CONNECTION_STATE: "http.connection.state",
      /**
        * Describes a class of error the operation ended with.
        *
        * Note: The `error.type` SHOULD be predictable and SHOULD have low cardinality.
      Instrumentations SHOULD document the list of errors they report.
      
      The cardinality of `error.type` within one instrumentation library SHOULD be low.
      Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
      should be prepared for `error.type` to have high cardinality at query time when no
      additional filters are applied.
      
      If the operation has completed successfully, instrumentations SHOULD NOT set `error.type`.
      
      If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
      it&#39;s RECOMMENDED to:
      
      * Use a domain-specific attribute
      * Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.
        */
      ERROR_TYPE: "error.type",
      /**
       * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_REQUEST_BODY_SIZE: "http.request.body.size",
      /**
        * HTTP request method.
        *
        * Note: HTTP request method value SHOULD be &#34;known&#34; to the instrumentation.
      By default, this convention defines &#34;known&#34; methods as the ones listed in [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-methods)
      and the PATCH method defined in [RFC5789](https://www.rfc-editor.org/rfc/rfc5789.html).
      
      If the HTTP request method is not known to instrumentation, it MUST set the `http.request.method` attribute to `_OTHER`.
      
      If the HTTP instrumentation could end up converting valid HTTP request methods to `_OTHER`, then it MUST provide a way to override
      the list of known HTTP methods. If this override is done via environment variable, then the environment variable MUST be named
      OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS and support a comma-separated list of case-sensitive known HTTP methods
      (this list MUST be a full override of the default known method, it is not a list of known methods in addition to the defaults).
      
      HTTP method names are case-sensitive and `http.request.method` attribute value MUST match a known HTTP method name exactly.
      Instrumentations for specific web frameworks that consider HTTP methods to be case insensitive, SHOULD populate a canonical equivalent.
      Tracing instrumentations that do so, MUST also set `http.request.method_original` to the original value.
        */
      HTTP_REQUEST_METHOD: "http.request.method",
      /**
       * Original HTTP method sent by the client in the request line.
       */
      HTTP_REQUEST_METHOD_ORIGINAL: "http.request.method_original",
      /**
       * The ordinal number of request resending attempt (for any reason, including redirects).
       *
       * Note: The resend count SHOULD be updated each time an HTTP request gets resent by the client, regardless of what was the cause of the resending (e.g. redirection, authorization failure, 503 Server Unavailable, network issues, or any other).
       */
      HTTP_REQUEST_RESEND_COUNT: "http.request.resend_count",
      /**
       * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_RESPONSE_BODY_SIZE: "http.response.body.size",
      /**
       * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
       */
      HTTP_RESPONSE_STATUS_CODE: "http.response.status_code",
      /**
        * The matched route, that is, the path template in the format used by the respective server framework.
        *
        * Note: MUST NOT be populated when this is not supported by the HTTP server framework as the route attribute should have low-cardinality and the URI path can NOT substitute it.
      SHOULD include the [application root](/docs/http/http-spans.md#http-server-definitions) if there is one.
        */
      HTTP_ROUTE: "http.route",
      /**
       * Peer address of the network connection - IP address or Unix domain socket name.
       */
      NETWORK_PEER_ADDRESS: "network.peer.address",
      /**
       * Peer port number of the network connection.
       */
      NETWORK_PEER_PORT: "network.peer.port",
      /**
       * [OSI application layer](https://osi-model.com/application-layer/) or non-OSI equivalent.
       *
       * Note: The value SHOULD be normalized to lowercase.
       */
      NETWORK_PROTOCOL_NAME: "network.protocol.name",
      /**
       * Version of the protocol specified in `network.protocol.name`.
       *
       * Note: `network.protocol.version` refers to the version of the protocol used and might be different from the protocol client&#39;s version. If the HTTP client has a version of `0.27.2`, but sends HTTP version `1.1`, this attribute should be set to `1.1`.
       */
      NETWORK_PROTOCOL_VERSION: "network.protocol.version",
      /**
       * Server domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name.
       *
       * Note: When observed from the client side, and when communicating through an intermediary, `server.address` SHOULD represent the server address behind any intermediaries, for example proxies, if it&#39;s available.
       */
      SERVER_ADDRESS: "server.address",
      /**
       * Server port number.
       *
       * Note: When observed from the client side, and when communicating through an intermediary, `server.port` SHOULD represent the server port behind any intermediaries, for example proxies, if it&#39;s available.
       */
      SERVER_PORT: "server.port",
      /**
        * Absolute URL describing a network resource according to [RFC3986](https://www.rfc-editor.org/rfc/rfc3986).
        *
        * Note: For network calls, URL usually has `scheme://host[:port][path][?query][#fragment]` format, where the fragment is not transmitted over HTTP, but if it is known, it SHOULD be included nevertheless.
      `url.full` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case username and password SHOULD be redacted and attribute&#39;s value SHOULD be `https://REDACTED:REDACTED@www.example.com/`.
      `url.full` SHOULD capture the absolute URL when it is available (or can be reconstructed) and SHOULD NOT be validated or modified except for sanitizing purposes.
        */
      URL_FULL: "url.full",
      /**
       * The [URI path](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) component.
       */
      URL_PATH: "url.path",
      /**
       * The [URI query](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) component.
       *
       * Note: Sensitive content provided in query string SHOULD be scrubbed when instrumentations can identify it.
       */
      URL_QUERY: "url.query",
      /**
       * The [URI scheme](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) component identifying the used protocol.
       */
      URL_SCHEME: "url.scheme",
      /**
       * Value of the [HTTP User-Agent](https://www.rfc-editor.org/rfc/rfc9110.html#field.user-agent) header sent by the client.
       */
      USER_AGENT_ORIGINAL: "user_agent.original"
    };
  }
});

// node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js
var require_undici = __commonJS({
  "node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UndiciInstrumentation = void 0;
    var diagch2 = require("diagnostics_channel");
    var url_1 = require("url");
    var instrumentation_1 = require_src4();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var version_1 = require_version3();
    var SemanticAttributes_1 = require_SemanticAttributes();
    var core_1 = require_src();
    var UndiciInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
        this._recordFromReq = /* @__PURE__ */ new WeakMap();
      }
      // No need to instrument files/modules
      init() {
        return void 0;
      }
      disable() {
        super.disable();
        this._channelSubs.forEach((sub) => sub.unsubscribe());
        this._channelSubs.length = 0;
      }
      enable() {
        super.enable();
        this._channelSubs = this._channelSubs || [];
        if (this._channelSubs.length > 0) {
          return;
        }
        this.subscribeToChannel("undici:request:create", this.onRequestCreated.bind(this));
        this.subscribeToChannel("undici:client:sendHeaders", this.onRequestHeaders.bind(this));
        this.subscribeToChannel("undici:request:headers", this.onResponseHeaders.bind(this));
        this.subscribeToChannel("undici:request:trailers", this.onDone.bind(this));
        this.subscribeToChannel("undici:request:error", this.onError.bind(this));
      }
      _updateMetricInstruments() {
        this._httpClientDurationHistogram = this.meter.createHistogram("http.client.request.duration", {
          description: "Measures the duration of outbound HTTP requests.",
          unit: "s",
          valueType: api_1.ValueType.DOUBLE,
          advice: {
            explicitBucketBoundaries: [
              5e-3,
              0.01,
              0.025,
              0.05,
              0.075,
              0.1,
              0.25,
              0.5,
              0.75,
              1,
              2.5,
              5,
              7.5,
              10
            ]
          }
        });
      }
      subscribeToChannel(diagnosticChannel, onMessage) {
        var _a;
        const [major2, minor] = process.version.replace("v", "").split(".").map((n) => Number(n));
        const useNewSubscribe = major2 > 18 || major2 === 18 && minor >= 19;
        let unsubscribe2;
        if (useNewSubscribe) {
          (_a = diagch2.subscribe) === null || _a === void 0 ? void 0 : _a.call(diagch2, diagnosticChannel, onMessage);
          unsubscribe2 = () => {
            var _a2;
            return (_a2 = diagch2.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(diagch2, diagnosticChannel, onMessage);
          };
        } else {
          const channel3 = diagch2.channel(diagnosticChannel);
          channel3.subscribe(onMessage);
          unsubscribe2 = () => channel3.unsubscribe(onMessage);
        }
        this._channelSubs.push({
          name: diagnosticChannel,
          unsubscribe: unsubscribe2
        });
      }
      // This is the 1st message we receive for each request (fired after request creation). Here we will
      // create the span and populate some atttributes, then link the span to the request for further
      // span processing
      onRequestCreated({ request }) {
        const config2 = this.getConfig();
        const enabled = config2.enabled !== false;
        const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          var _a;
          return !enabled || request.method === "CONNECT" || ((_a = config2.ignoreRequestHook) === null || _a === void 0 ? void 0 : _a.call(config2, request));
        }, (e) => e && this._diag.error("caught ignoreRequestHook error: ", e), true);
        if (shouldIgnoreReq) {
          return;
        }
        const startTime = (0, core_1.hrTime)();
        let requestUrl;
        try {
          requestUrl = new url_1.URL(request.path, request.origin);
        } catch (err) {
          this._diag.warn("could not determine url.full:", err);
          return;
        }
        const urlScheme = requestUrl.protocol.replace(":", "");
        const requestMethod = this.getRequestMethod(request.method);
        const attributes = {
          [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD]: requestMethod,
          [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD_ORIGINAL]: request.method,
          [SemanticAttributes_1.SemanticAttributes.URL_FULL]: requestUrl.toString(),
          [SemanticAttributes_1.SemanticAttributes.URL_PATH]: requestUrl.pathname,
          [SemanticAttributes_1.SemanticAttributes.URL_QUERY]: requestUrl.search,
          [SemanticAttributes_1.SemanticAttributes.URL_SCHEME]: urlScheme
        };
        const schemePorts = { https: "443", http: "80" };
        const serverAddress = requestUrl.hostname;
        const serverPort = requestUrl.port || schemePorts[urlScheme];
        attributes[SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS] = serverAddress;
        if (serverPort && !isNaN(Number(serverPort))) {
          attributes[SemanticAttributes_1.SemanticAttributes.SERVER_PORT] = Number(serverPort);
        }
        let userAgent;
        if (Array.isArray(request.headers)) {
          const idx = request.headers.findIndex((h) => h.toLowerCase() === "user-agent");
          if (idx >= 0) {
            userAgent = request.headers[idx + 1];
          }
        } else if (typeof request.headers === "string") {
          const headers = request.headers.split("\r\n");
          const uaHeader = headers.find((h) => h.toLowerCase().startsWith("user-agent"));
          userAgent = uaHeader && uaHeader.substring(uaHeader.indexOf(":") + 1).trim();
        }
        if (userAgent) {
          attributes[SemanticAttributes_1.SemanticAttributes.USER_AGENT_ORIGINAL] = userAgent;
        }
        const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          var _a;
          return (_a = config2.startSpanHook) === null || _a === void 0 ? void 0 : _a.call(config2, request);
        }, (e) => e && this._diag.error("caught startSpanHook error: ", e), true);
        if (hookAttributes) {
          Object.entries(hookAttributes).forEach(([key, val]) => {
            attributes[key] = val;
          });
        }
        const activeCtx = api_1.context.active();
        const currentSpan = api_1.trace.getSpan(activeCtx);
        let span;
        if (config2.requireParentforSpans && (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {
          span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
        } else {
          span = this.tracer.startSpan(requestMethod === "_OTHER" ? "HTTP" : requestMethod, {
            kind: api_1.SpanKind.CLIENT,
            attributes
          }, activeCtx);
        }
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          var _a;
          return (_a = config2.requestHook) === null || _a === void 0 ? void 0 : _a.call(config2, span, request);
        }, (e) => e && this._diag.error("caught requestHook error: ", e), true);
        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);
        const addedHeaders = {};
        api_1.propagation.inject(requestContext, addedHeaders);
        const headerEntries = Object.entries(addedHeaders);
        for (let i = 0; i < headerEntries.length; i++) {
          const [k, v] = headerEntries[i];
          if (typeof request.addHeader === "function") {
            request.addHeader(k, v);
          } else if (typeof request.headers === "string") {
            request.headers += `${k}: ${v}\r
`;
          } else if (Array.isArray(request.headers)) {
            request.headers.push(k, v);
          }
        }
        this._recordFromReq.set(request, { span, attributes, startTime });
      }
      // This is the 2nd message we receive for each request. It is fired when connection with
      // the remote is established and about to send the first byte. Here we do have info about the
      // remote address and port so we can populate some `network.*` attributes into the span
      onRequestHeaders({ request, socket }) {
        var _a;
        const record = this._recordFromReq.get(request);
        if (!record) {
          return;
        }
        const config2 = this.getConfig();
        const { span } = record;
        const { remoteAddress, remotePort } = socket;
        const spanAttributes = {
          [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_ADDRESS]: remoteAddress,
          [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_PORT]: remotePort
        };
        if ((_a = config2.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.requestHeaders) {
          const headersToAttribs = new Set(config2.headersToSpanAttributes.requestHeaders.map((n) => n.toLowerCase()));
          const rawHeaders = Array.isArray(request.headers) ? request.headers : request.headers.split("\r\n");
          rawHeaders.forEach((h, idx) => {
            const sepIndex = h.indexOf(":");
            const hasSeparator = sepIndex !== -1;
            const name = (hasSeparator ? h.substring(0, sepIndex) : h).toLowerCase();
            const value = hasSeparator ? h.substring(sepIndex + 1) : rawHeaders[idx + 1];
            if (headersToAttribs.has(name)) {
              spanAttributes[`http.request.header.${name}`] = value.trim();
            }
          });
        }
        span.setAttributes(spanAttributes);
      }
      // This is the 3rd message we get for each request and it's fired when the server
      // headers are received, body may not be accessible yet.
      // From the response headers we can set the status and content length
      onResponseHeaders({ request, response }) {
        var _a, _b;
        const record = this._recordFromReq.get(request);
        if (!record) {
          return;
        }
        const { span, attributes } = record;
        const spanAttributes = {
          [SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE]: response.statusCode
        };
        const config2 = this.getConfig();
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          var _a2;
          return (_a2 = config2.responseHook) === null || _a2 === void 0 ? void 0 : _a2.call(config2, span, { request, response });
        }, (e) => e && this._diag.error("caught responseHook error: ", e), true);
        const headersToAttribs = /* @__PURE__ */ new Set();
        if ((_a = config2.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.responseHeaders) {
          (_b = config2.headersToSpanAttributes) === null || _b === void 0 ? void 0 : _b.responseHeaders.forEach((name) => headersToAttribs.add(name.toLowerCase()));
        }
        for (let idx = 0; idx < response.headers.length; idx = idx + 2) {
          const name = response.headers[idx].toString().toLowerCase();
          const value = response.headers[idx + 1];
          if (headersToAttribs.has(name)) {
            spanAttributes[`http.response.header.${name}`] = value.toString();
          }
          if (name === "content-length") {
            const contentLength = Number(value.toString());
            if (!isNaN(contentLength)) {
              spanAttributes["http.response.header.content-length"] = contentLength;
            }
          }
        }
        span.setAttributes(spanAttributes);
        span.setStatus({
          code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.UNSET
        });
        record.attributes = Object.assign(attributes, spanAttributes);
      }
      // This is the last event we receive if the request went without any errors
      onDone({ request }) {
        const record = this._recordFromReq.get(request);
        if (!record) {
          return;
        }
        const { span, attributes, startTime } = record;
        span.end();
        this._recordFromReq.delete(request);
        this.recordRequestDuration(attributes, startTime);
      }
      // This is the event we get when something is wrong in the request like
      // - invalid options when calling `fetch` global API or any undici method for request
      // - connectivity errors such as unreachable host
      // - requests aborted through an `AbortController.signal`
      // NOTE: server errors are considered valid responses and it's the lib consumer
      // who should deal with that.
      onError({ request, error }) {
        const record = this._recordFromReq.get(request);
        if (!record) {
          return;
        }
        const { span, attributes, startTime } = record;
        span.recordException(error);
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: error.message
        });
        span.end();
        this._recordFromReq.delete(request);
        attributes[SemanticAttributes_1.SemanticAttributes.ERROR_TYPE] = error.message;
        this.recordRequestDuration(attributes, startTime);
      }
      recordRequestDuration(attributes, startTime) {
        const metricsAttributes = {};
        const keysToCopy = [
          SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE,
          SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD,
          SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS,
          SemanticAttributes_1.SemanticAttributes.SERVER_PORT,
          SemanticAttributes_1.SemanticAttributes.URL_SCHEME,
          SemanticAttributes_1.SemanticAttributes.ERROR_TYPE
        ];
        keysToCopy.forEach((key) => {
          if (key in attributes) {
            metricsAttributes[key] = attributes[key];
          }
        });
        const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1e3;
        this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);
      }
      getRequestMethod(original) {
        const knownMethods = {
          CONNECT: true,
          OPTIONS: true,
          HEAD: true,
          GET: true,
          POST: true,
          PUT: true,
          PATCH: true,
          DELETE: true,
          TRACE: true
        };
        if (original.toUpperCase() in knownMethods) {
          return original.toUpperCase();
        }
        return "_OTHER";
      }
    };
    exports2.UndiciInstrumentation = UndiciInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-undici/build/src/types.js
var require_types = __commonJS({
  "node_modules/@opentelemetry/instrumentation-undici/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-undici/build/src/index.js
var require_src6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-undici/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_undici(), exports2);
    __exportStar(require_types(), exports2);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap3(values) {
  let res = {};
  const len = values.length;
  for (let lp = 0; lp < len; lp++) {
    const val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils5 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN3, TMP_DB_SYSTEM3, TMP_DB_CONNECTION_STRING3, TMP_DB_USER3, TMP_DB_JDBC_DRIVER_CLASSNAME3, TMP_DB_NAME3, TMP_DB_STATEMENT3, TMP_DB_OPERATION3, TMP_DB_MSSQL_INSTANCE_NAME3, TMP_DB_CASSANDRA_KEYSPACE3, TMP_DB_CASSANDRA_PAGE_SIZE3, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL3, TMP_DB_CASSANDRA_TABLE3, TMP_DB_CASSANDRA_IDEMPOTENCE3, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3, TMP_DB_CASSANDRA_COORDINATOR_ID3, TMP_DB_CASSANDRA_COORDINATOR_DC3, TMP_DB_HBASE_NAMESPACE3, TMP_DB_REDIS_DATABASE_INDEX3, TMP_DB_MONGODB_COLLECTION3, TMP_DB_SQL_TABLE3, TMP_EXCEPTION_TYPE3, TMP_EXCEPTION_MESSAGE3, TMP_EXCEPTION_STACKTRACE3, TMP_EXCEPTION_ESCAPED3, TMP_FAAS_TRIGGER3, TMP_FAAS_EXECUTION3, TMP_FAAS_DOCUMENT_COLLECTION3, TMP_FAAS_DOCUMENT_OPERATION3, TMP_FAAS_DOCUMENT_TIME3, TMP_FAAS_DOCUMENT_NAME3, TMP_FAAS_TIME3, TMP_FAAS_CRON3, TMP_FAAS_COLDSTART3, TMP_FAAS_INVOKED_NAME3, TMP_FAAS_INVOKED_PROVIDER3, TMP_FAAS_INVOKED_REGION3, TMP_NET_TRANSPORT3, TMP_NET_PEER_IP3, TMP_NET_PEER_PORT3, TMP_NET_PEER_NAME3, TMP_NET_HOST_IP3, TMP_NET_HOST_PORT3, TMP_NET_HOST_NAME3, TMP_NET_HOST_CONNECTION_TYPE3, TMP_NET_HOST_CONNECTION_SUBTYPE3, TMP_NET_HOST_CARRIER_NAME3, TMP_NET_HOST_CARRIER_MCC3, TMP_NET_HOST_CARRIER_MNC3, TMP_NET_HOST_CARRIER_ICC3, TMP_PEER_SERVICE3, TMP_ENDUSER_ID3, TMP_ENDUSER_ROLE3, TMP_ENDUSER_SCOPE3, TMP_THREAD_ID3, TMP_THREAD_NAME3, TMP_CODE_FUNCTION3, TMP_CODE_NAMESPACE3, TMP_CODE_FILEPATH3, TMP_CODE_LINENO3, TMP_HTTP_METHOD3, TMP_HTTP_URL3, TMP_HTTP_TARGET3, TMP_HTTP_HOST3, TMP_HTTP_SCHEME3, TMP_HTTP_STATUS_CODE3, TMP_HTTP_FLAVOR3, TMP_HTTP_USER_AGENT3, TMP_HTTP_REQUEST_CONTENT_LENGTH3, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3, TMP_HTTP_RESPONSE_CONTENT_LENGTH3, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3, TMP_HTTP_SERVER_NAME3, TMP_HTTP_ROUTE3, TMP_HTTP_CLIENT_IP3, TMP_AWS_DYNAMODB_TABLE_NAMES3, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY3, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3, TMP_AWS_DYNAMODB_CONSISTENT_READ3, TMP_AWS_DYNAMODB_PROJECTION3, TMP_AWS_DYNAMODB_LIMIT3, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET3, TMP_AWS_DYNAMODB_INDEX_NAME3, TMP_AWS_DYNAMODB_SELECT3, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3, TMP_AWS_DYNAMODB_TABLE_COUNT3, TMP_AWS_DYNAMODB_SCAN_FORWARD3, TMP_AWS_DYNAMODB_SEGMENT3, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS3, TMP_AWS_DYNAMODB_COUNT3, TMP_AWS_DYNAMODB_SCANNED_COUNT3, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3, TMP_MESSAGING_SYSTEM3, TMP_MESSAGING_DESTINATION3, TMP_MESSAGING_DESTINATION_KIND3, TMP_MESSAGING_TEMP_DESTINATION3, TMP_MESSAGING_PROTOCOL3, TMP_MESSAGING_PROTOCOL_VERSION3, TMP_MESSAGING_URL3, TMP_MESSAGING_MESSAGE_ID3, TMP_MESSAGING_CONVERSATION_ID3, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3, TMP_MESSAGING_OPERATION3, TMP_MESSAGING_CONSUMER_ID3, TMP_MESSAGING_RABBITMQ_ROUTING_KEY3, TMP_MESSAGING_KAFKA_MESSAGE_KEY3, TMP_MESSAGING_KAFKA_CONSUMER_GROUP3, TMP_MESSAGING_KAFKA_CLIENT_ID3, TMP_MESSAGING_KAFKA_PARTITION3, TMP_MESSAGING_KAFKA_TOMBSTONE3, TMP_RPC_SYSTEM3, TMP_RPC_SERVICE3, TMP_RPC_METHOD3, TMP_RPC_GRPC_STATUS_CODE3, TMP_RPC_JSONRPC_VERSION3, TMP_RPC_JSONRPC_REQUEST_ID3, TMP_RPC_JSONRPC_ERROR_CODE3, TMP_RPC_JSONRPC_ERROR_MESSAGE3, TMP_MESSAGE_TYPE3, TMP_MESSAGE_ID3, TMP_MESSAGE_COMPRESSED_SIZE3, TMP_MESSAGE_UNCOMPRESSED_SIZE3, SEMATTRS_AWS_LAMBDA_INVOKED_ARN3, SEMATTRS_DB_SYSTEM3, SEMATTRS_DB_CONNECTION_STRING3, SEMATTRS_DB_USER3, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME3, SEMATTRS_DB_NAME3, SEMATTRS_DB_STATEMENT3, SEMATTRS_DB_OPERATION3, SEMATTRS_DB_MSSQL_INSTANCE_NAME3, SEMATTRS_DB_CASSANDRA_KEYSPACE3, SEMATTRS_DB_CASSANDRA_PAGE_SIZE3, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL3, SEMATTRS_DB_CASSANDRA_TABLE3, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE3, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID3, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC3, SEMATTRS_DB_HBASE_NAMESPACE3, SEMATTRS_DB_REDIS_DATABASE_INDEX3, SEMATTRS_DB_MONGODB_COLLECTION3, SEMATTRS_DB_SQL_TABLE3, SEMATTRS_EXCEPTION_TYPE3, SEMATTRS_EXCEPTION_MESSAGE3, SEMATTRS_EXCEPTION_STACKTRACE3, SEMATTRS_EXCEPTION_ESCAPED3, SEMATTRS_FAAS_TRIGGER3, SEMATTRS_FAAS_EXECUTION3, SEMATTRS_FAAS_DOCUMENT_COLLECTION3, SEMATTRS_FAAS_DOCUMENT_OPERATION3, SEMATTRS_FAAS_DOCUMENT_TIME3, SEMATTRS_FAAS_DOCUMENT_NAME3, SEMATTRS_FAAS_TIME3, SEMATTRS_FAAS_CRON3, SEMATTRS_FAAS_COLDSTART3, SEMATTRS_FAAS_INVOKED_NAME3, SEMATTRS_FAAS_INVOKED_PROVIDER3, SEMATTRS_FAAS_INVOKED_REGION3, SEMATTRS_NET_TRANSPORT3, SEMATTRS_NET_PEER_IP3, SEMATTRS_NET_PEER_PORT3, SEMATTRS_NET_PEER_NAME3, SEMATTRS_NET_HOST_IP3, SEMATTRS_NET_HOST_PORT3, SEMATTRS_NET_HOST_NAME3, SEMATTRS_NET_HOST_CONNECTION_TYPE3, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE3, SEMATTRS_NET_HOST_CARRIER_NAME3, SEMATTRS_NET_HOST_CARRIER_MCC3, SEMATTRS_NET_HOST_CARRIER_MNC3, SEMATTRS_NET_HOST_CARRIER_ICC3, SEMATTRS_PEER_SERVICE3, SEMATTRS_ENDUSER_ID3, SEMATTRS_ENDUSER_ROLE3, SEMATTRS_ENDUSER_SCOPE3, SEMATTRS_THREAD_ID3, SEMATTRS_THREAD_NAME3, SEMATTRS_CODE_FUNCTION3, SEMATTRS_CODE_NAMESPACE3, SEMATTRS_CODE_FILEPATH3, SEMATTRS_CODE_LINENO3, SEMATTRS_HTTP_METHOD3, SEMATTRS_HTTP_URL3, SEMATTRS_HTTP_TARGET3, SEMATTRS_HTTP_HOST3, SEMATTRS_HTTP_SCHEME3, SEMATTRS_HTTP_STATUS_CODE3, SEMATTRS_HTTP_FLAVOR3, SEMATTRS_HTTP_USER_AGENT3, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH3, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH3, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3, SEMATTRS_HTTP_SERVER_NAME3, SEMATTRS_HTTP_ROUTE3, SEMATTRS_HTTP_CLIENT_IP3, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES3, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY3, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ3, SEMATTRS_AWS_DYNAMODB_PROJECTION3, SEMATTRS_AWS_DYNAMODB_LIMIT3, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET3, SEMATTRS_AWS_DYNAMODB_INDEX_NAME3, SEMATTRS_AWS_DYNAMODB_SELECT3, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT3, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD3, SEMATTRS_AWS_DYNAMODB_SEGMENT3, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS3, SEMATTRS_AWS_DYNAMODB_COUNT3, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT3, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3, SEMATTRS_MESSAGING_SYSTEM3, SEMATTRS_MESSAGING_DESTINATION3, SEMATTRS_MESSAGING_DESTINATION_KIND3, SEMATTRS_MESSAGING_TEMP_DESTINATION3, SEMATTRS_MESSAGING_PROTOCOL3, SEMATTRS_MESSAGING_PROTOCOL_VERSION3, SEMATTRS_MESSAGING_URL3, SEMATTRS_MESSAGING_MESSAGE_ID3, SEMATTRS_MESSAGING_CONVERSATION_ID3, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3, SEMATTRS_MESSAGING_OPERATION3, SEMATTRS_MESSAGING_CONSUMER_ID3, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY3, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY3, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP3, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID3, SEMATTRS_MESSAGING_KAFKA_PARTITION3, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE3, SEMATTRS_RPC_SYSTEM3, SEMATTRS_RPC_SERVICE3, SEMATTRS_RPC_METHOD3, SEMATTRS_RPC_GRPC_STATUS_CODE3, SEMATTRS_RPC_JSONRPC_VERSION3, SEMATTRS_RPC_JSONRPC_REQUEST_ID3, SEMATTRS_RPC_JSONRPC_ERROR_CODE3, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE3, SEMATTRS_MESSAGE_TYPE3, SEMATTRS_MESSAGE_ID3, SEMATTRS_MESSAGE_COMPRESSED_SIZE3, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE3, SemanticAttributes3, TMP_DBSYSTEMVALUES_OTHER_SQL3, TMP_DBSYSTEMVALUES_MSSQL3, TMP_DBSYSTEMVALUES_MYSQL3, TMP_DBSYSTEMVALUES_ORACLE3, TMP_DBSYSTEMVALUES_DB23, TMP_DBSYSTEMVALUES_POSTGRESQL3, TMP_DBSYSTEMVALUES_REDSHIFT3, TMP_DBSYSTEMVALUES_HIVE3, TMP_DBSYSTEMVALUES_CLOUDSCAPE3, TMP_DBSYSTEMVALUES_HSQLDB3, TMP_DBSYSTEMVALUES_PROGRESS3, TMP_DBSYSTEMVALUES_MAXDB3, TMP_DBSYSTEMVALUES_HANADB3, TMP_DBSYSTEMVALUES_INGRES3, TMP_DBSYSTEMVALUES_FIRSTSQL3, TMP_DBSYSTEMVALUES_EDB3, TMP_DBSYSTEMVALUES_CACHE3, TMP_DBSYSTEMVALUES_ADABAS3, TMP_DBSYSTEMVALUES_FIREBIRD3, TMP_DBSYSTEMVALUES_DERBY3, TMP_DBSYSTEMVALUES_FILEMAKER3, TMP_DBSYSTEMVALUES_INFORMIX3, TMP_DBSYSTEMVALUES_INSTANTDB3, TMP_DBSYSTEMVALUES_INTERBASE3, TMP_DBSYSTEMVALUES_MARIADB3, TMP_DBSYSTEMVALUES_NETEZZA3, TMP_DBSYSTEMVALUES_PERVASIVE3, TMP_DBSYSTEMVALUES_POINTBASE3, TMP_DBSYSTEMVALUES_SQLITE3, TMP_DBSYSTEMVALUES_SYBASE3, TMP_DBSYSTEMVALUES_TERADATA3, TMP_DBSYSTEMVALUES_VERTICA3, TMP_DBSYSTEMVALUES_H23, TMP_DBSYSTEMVALUES_COLDFUSION3, TMP_DBSYSTEMVALUES_CASSANDRA3, TMP_DBSYSTEMVALUES_HBASE3, TMP_DBSYSTEMVALUES_MONGODB3, TMP_DBSYSTEMVALUES_REDIS3, TMP_DBSYSTEMVALUES_COUCHBASE3, TMP_DBSYSTEMVALUES_COUCHDB3, TMP_DBSYSTEMVALUES_COSMOSDB3, TMP_DBSYSTEMVALUES_DYNAMODB3, TMP_DBSYSTEMVALUES_NEO4J3, TMP_DBSYSTEMVALUES_GEODE3, TMP_DBSYSTEMVALUES_ELASTICSEARCH3, TMP_DBSYSTEMVALUES_MEMCACHED3, TMP_DBSYSTEMVALUES_COCKROACHDB3, DBSYSTEMVALUES_OTHER_SQL3, DBSYSTEMVALUES_MSSQL3, DBSYSTEMVALUES_MYSQL3, DBSYSTEMVALUES_ORACLE3, DBSYSTEMVALUES_DB23, DBSYSTEMVALUES_POSTGRESQL3, DBSYSTEMVALUES_REDSHIFT3, DBSYSTEMVALUES_HIVE3, DBSYSTEMVALUES_CLOUDSCAPE3, DBSYSTEMVALUES_HSQLDB3, DBSYSTEMVALUES_PROGRESS3, DBSYSTEMVALUES_MAXDB3, DBSYSTEMVALUES_HANADB3, DBSYSTEMVALUES_INGRES3, DBSYSTEMVALUES_FIRSTSQL3, DBSYSTEMVALUES_EDB3, DBSYSTEMVALUES_CACHE3, DBSYSTEMVALUES_ADABAS3, DBSYSTEMVALUES_FIREBIRD3, DBSYSTEMVALUES_DERBY3, DBSYSTEMVALUES_FILEMAKER3, DBSYSTEMVALUES_INFORMIX3, DBSYSTEMVALUES_INSTANTDB3, DBSYSTEMVALUES_INTERBASE3, DBSYSTEMVALUES_MARIADB3, DBSYSTEMVALUES_NETEZZA3, DBSYSTEMVALUES_PERVASIVE3, DBSYSTEMVALUES_POINTBASE3, DBSYSTEMVALUES_SQLITE3, DBSYSTEMVALUES_SYBASE3, DBSYSTEMVALUES_TERADATA3, DBSYSTEMVALUES_VERTICA3, DBSYSTEMVALUES_H23, DBSYSTEMVALUES_COLDFUSION3, DBSYSTEMVALUES_CASSANDRA3, DBSYSTEMVALUES_HBASE3, DBSYSTEMVALUES_MONGODB3, DBSYSTEMVALUES_REDIS3, DBSYSTEMVALUES_COUCHBASE3, DBSYSTEMVALUES_COUCHDB3, DBSYSTEMVALUES_COSMOSDB3, DBSYSTEMVALUES_DYNAMODB3, DBSYSTEMVALUES_NEO4J3, DBSYSTEMVALUES_GEODE3, DBSYSTEMVALUES_ELASTICSEARCH3, DBSYSTEMVALUES_MEMCACHED3, DBSYSTEMVALUES_COCKROACHDB3, DbSystemValues3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3, DBCASSANDRACONSISTENCYLEVELVALUES_ALL3, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3, DBCASSANDRACONSISTENCYLEVELVALUES_ONE3, DBCASSANDRACONSISTENCYLEVELVALUES_TWO3, DBCASSANDRACONSISTENCYLEVELVALUES_THREE3, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3, DBCASSANDRACONSISTENCYLEVELVALUES_ANY3, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3, DbCassandraConsistencyLevelValues3, TMP_FAASTRIGGERVALUES_DATASOURCE3, TMP_FAASTRIGGERVALUES_HTTP3, TMP_FAASTRIGGERVALUES_PUBSUB3, TMP_FAASTRIGGERVALUES_TIMER3, TMP_FAASTRIGGERVALUES_OTHER3, FAASTRIGGERVALUES_DATASOURCE3, FAASTRIGGERVALUES_HTTP3, FAASTRIGGERVALUES_PUBSUB3, FAASTRIGGERVALUES_TIMER3, FAASTRIGGERVALUES_OTHER3, FaasTriggerValues3, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT3, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT3, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE3, FAASDOCUMENTOPERATIONVALUES_INSERT3, FAASDOCUMENTOPERATIONVALUES_EDIT3, FAASDOCUMENTOPERATIONVALUES_DELETE3, FaasDocumentOperationValues3, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3, TMP_FAASINVOKEDPROVIDERVALUES_AWS3, TMP_FAASINVOKEDPROVIDERVALUES_AZURE3, TMP_FAASINVOKEDPROVIDERVALUES_GCP3, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3, FAASINVOKEDPROVIDERVALUES_AWS3, FAASINVOKEDPROVIDERVALUES_AZURE3, FAASINVOKEDPROVIDERVALUES_GCP3, FaasInvokedProviderValues3, TMP_NETTRANSPORTVALUES_IP_TCP3, TMP_NETTRANSPORTVALUES_IP_UDP3, TMP_NETTRANSPORTVALUES_IP3, TMP_NETTRANSPORTVALUES_UNIX3, TMP_NETTRANSPORTVALUES_PIPE3, TMP_NETTRANSPORTVALUES_INPROC3, TMP_NETTRANSPORTVALUES_OTHER3, NETTRANSPORTVALUES_IP_TCP3, NETTRANSPORTVALUES_IP_UDP3, NETTRANSPORTVALUES_IP3, NETTRANSPORTVALUES_UNIX3, NETTRANSPORTVALUES_PIPE3, NETTRANSPORTVALUES_INPROC3, NETTRANSPORTVALUES_OTHER3, NetTransportValues3, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI3, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED3, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL3, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3, NETHOSTCONNECTIONTYPEVALUES_WIFI3, NETHOSTCONNECTIONTYPEVALUES_WIRED3, NETHOSTCONNECTIONTYPEVALUES_CELL3, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3, NetHostConnectionTypeValues3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3, NETHOSTCONNECTIONSUBTYPEVALUES_LTE3, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3, NETHOSTCONNECTIONSUBTYPEVALUES_GSM3, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3, NETHOSTCONNECTIONSUBTYPEVALUES_NR3, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3, NetHostConnectionSubtypeValues3, TMP_HTTPFLAVORVALUES_HTTP_1_03, TMP_HTTPFLAVORVALUES_HTTP_1_13, TMP_HTTPFLAVORVALUES_HTTP_2_03, TMP_HTTPFLAVORVALUES_SPDY3, TMP_HTTPFLAVORVALUES_QUIC3, HTTPFLAVORVALUES_HTTP_1_03, HTTPFLAVORVALUES_HTTP_1_13, HTTPFLAVORVALUES_HTTP_2_03, HTTPFLAVORVALUES_SPDY3, HTTPFLAVORVALUES_QUIC3, HttpFlavorValues3, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE3, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC3, MESSAGINGDESTINATIONKINDVALUES_QUEUE3, MESSAGINGDESTINATIONKINDVALUES_TOPIC3, MessagingDestinationKindValues3, TMP_MESSAGINGOPERATIONVALUES_RECEIVE3, TMP_MESSAGINGOPERATIONVALUES_PROCESS3, MESSAGINGOPERATIONVALUES_RECEIVE3, MESSAGINGOPERATIONVALUES_PROCESS3, MessagingOperationValues3, TMP_RPCGRPCSTATUSCODEVALUES_OK3, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED3, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN3, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND3, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED3, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL3, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS3, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3, RPCGRPCSTATUSCODEVALUES_OK3, RPCGRPCSTATUSCODEVALUES_CANCELLED3, RPCGRPCSTATUSCODEVALUES_UNKNOWN3, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3, RPCGRPCSTATUSCODEVALUES_NOT_FOUND3, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3, RPCGRPCSTATUSCODEVALUES_ABORTED3, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3, RPCGRPCSTATUSCODEVALUES_INTERNAL3, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3, RPCGRPCSTATUSCODEVALUES_DATA_LOSS3, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3, RpcGrpcStatusCodeValues3, TMP_MESSAGETYPEVALUES_SENT3, TMP_MESSAGETYPEVALUES_RECEIVED3, MESSAGETYPEVALUES_SENT3, MESSAGETYPEVALUES_RECEIVED3, MessageTypeValues3;
var init_SemanticAttributes3 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils5();
    TMP_AWS_LAMBDA_INVOKED_ARN3 = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM3 = "db.system";
    TMP_DB_CONNECTION_STRING3 = "db.connection_string";
    TMP_DB_USER3 = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME3 = "db.jdbc.driver_classname";
    TMP_DB_NAME3 = "db.name";
    TMP_DB_STATEMENT3 = "db.statement";
    TMP_DB_OPERATION3 = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME3 = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE3 = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE3 = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL3 = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE3 = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE3 = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3 = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID3 = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC3 = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE3 = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX3 = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION3 = "db.mongodb.collection";
    TMP_DB_SQL_TABLE3 = "db.sql.table";
    TMP_EXCEPTION_TYPE3 = "exception.type";
    TMP_EXCEPTION_MESSAGE3 = "exception.message";
    TMP_EXCEPTION_STACKTRACE3 = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED3 = "exception.escaped";
    TMP_FAAS_TRIGGER3 = "faas.trigger";
    TMP_FAAS_EXECUTION3 = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION3 = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION3 = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME3 = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME3 = "faas.document.name";
    TMP_FAAS_TIME3 = "faas.time";
    TMP_FAAS_CRON3 = "faas.cron";
    TMP_FAAS_COLDSTART3 = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME3 = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER3 = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION3 = "faas.invoked_region";
    TMP_NET_TRANSPORT3 = "net.transport";
    TMP_NET_PEER_IP3 = "net.peer.ip";
    TMP_NET_PEER_PORT3 = "net.peer.port";
    TMP_NET_PEER_NAME3 = "net.peer.name";
    TMP_NET_HOST_IP3 = "net.host.ip";
    TMP_NET_HOST_PORT3 = "net.host.port";
    TMP_NET_HOST_NAME3 = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE3 = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE3 = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME3 = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC3 = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC3 = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC3 = "net.host.carrier.icc";
    TMP_PEER_SERVICE3 = "peer.service";
    TMP_ENDUSER_ID3 = "enduser.id";
    TMP_ENDUSER_ROLE3 = "enduser.role";
    TMP_ENDUSER_SCOPE3 = "enduser.scope";
    TMP_THREAD_ID3 = "thread.id";
    TMP_THREAD_NAME3 = "thread.name";
    TMP_CODE_FUNCTION3 = "code.function";
    TMP_CODE_NAMESPACE3 = "code.namespace";
    TMP_CODE_FILEPATH3 = "code.filepath";
    TMP_CODE_LINENO3 = "code.lineno";
    TMP_HTTP_METHOD3 = "http.method";
    TMP_HTTP_URL3 = "http.url";
    TMP_HTTP_TARGET3 = "http.target";
    TMP_HTTP_HOST3 = "http.host";
    TMP_HTTP_SCHEME3 = "http.scheme";
    TMP_HTTP_STATUS_CODE3 = "http.status_code";
    TMP_HTTP_FLAVOR3 = "http.flavor";
    TMP_HTTP_USER_AGENT3 = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH3 = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3 = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH3 = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3 = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME3 = "http.server_name";
    TMP_HTTP_ROUTE3 = "http.route";
    TMP_HTTP_CLIENT_IP3 = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES3 = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY3 = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3 = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3 = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3 = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ3 = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION3 = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT3 = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET3 = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME3 = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT3 = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3 = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3 = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3 = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT3 = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD3 = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT3 = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS3 = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT3 = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT3 = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3 = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3 = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM3 = "messaging.system";
    TMP_MESSAGING_DESTINATION3 = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND3 = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION3 = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL3 = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION3 = "messaging.protocol_version";
    TMP_MESSAGING_URL3 = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID3 = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID3 = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3 = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3 = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION3 = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID3 = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY3 = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY3 = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP3 = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID3 = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION3 = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE3 = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM3 = "rpc.system";
    TMP_RPC_SERVICE3 = "rpc.service";
    TMP_RPC_METHOD3 = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE3 = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION3 = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID3 = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE3 = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE3 = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE3 = "message.type";
    TMP_MESSAGE_ID3 = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE3 = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE3 = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN3 = TMP_AWS_LAMBDA_INVOKED_ARN3;
    SEMATTRS_DB_SYSTEM3 = TMP_DB_SYSTEM3;
    SEMATTRS_DB_CONNECTION_STRING3 = TMP_DB_CONNECTION_STRING3;
    SEMATTRS_DB_USER3 = TMP_DB_USER3;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME3 = TMP_DB_JDBC_DRIVER_CLASSNAME3;
    SEMATTRS_DB_NAME3 = TMP_DB_NAME3;
    SEMATTRS_DB_STATEMENT3 = TMP_DB_STATEMENT3;
    SEMATTRS_DB_OPERATION3 = TMP_DB_OPERATION3;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME3 = TMP_DB_MSSQL_INSTANCE_NAME3;
    SEMATTRS_DB_CASSANDRA_KEYSPACE3 = TMP_DB_CASSANDRA_KEYSPACE3;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE3 = TMP_DB_CASSANDRA_PAGE_SIZE3;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL3 = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL3;
    SEMATTRS_DB_CASSANDRA_TABLE3 = TMP_DB_CASSANDRA_TABLE3;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE3 = TMP_DB_CASSANDRA_IDEMPOTENCE3;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3 = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID3 = TMP_DB_CASSANDRA_COORDINATOR_ID3;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC3 = TMP_DB_CASSANDRA_COORDINATOR_DC3;
    SEMATTRS_DB_HBASE_NAMESPACE3 = TMP_DB_HBASE_NAMESPACE3;
    SEMATTRS_DB_REDIS_DATABASE_INDEX3 = TMP_DB_REDIS_DATABASE_INDEX3;
    SEMATTRS_DB_MONGODB_COLLECTION3 = TMP_DB_MONGODB_COLLECTION3;
    SEMATTRS_DB_SQL_TABLE3 = TMP_DB_SQL_TABLE3;
    SEMATTRS_EXCEPTION_TYPE3 = TMP_EXCEPTION_TYPE3;
    SEMATTRS_EXCEPTION_MESSAGE3 = TMP_EXCEPTION_MESSAGE3;
    SEMATTRS_EXCEPTION_STACKTRACE3 = TMP_EXCEPTION_STACKTRACE3;
    SEMATTRS_EXCEPTION_ESCAPED3 = TMP_EXCEPTION_ESCAPED3;
    SEMATTRS_FAAS_TRIGGER3 = TMP_FAAS_TRIGGER3;
    SEMATTRS_FAAS_EXECUTION3 = TMP_FAAS_EXECUTION3;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION3 = TMP_FAAS_DOCUMENT_COLLECTION3;
    SEMATTRS_FAAS_DOCUMENT_OPERATION3 = TMP_FAAS_DOCUMENT_OPERATION3;
    SEMATTRS_FAAS_DOCUMENT_TIME3 = TMP_FAAS_DOCUMENT_TIME3;
    SEMATTRS_FAAS_DOCUMENT_NAME3 = TMP_FAAS_DOCUMENT_NAME3;
    SEMATTRS_FAAS_TIME3 = TMP_FAAS_TIME3;
    SEMATTRS_FAAS_CRON3 = TMP_FAAS_CRON3;
    SEMATTRS_FAAS_COLDSTART3 = TMP_FAAS_COLDSTART3;
    SEMATTRS_FAAS_INVOKED_NAME3 = TMP_FAAS_INVOKED_NAME3;
    SEMATTRS_FAAS_INVOKED_PROVIDER3 = TMP_FAAS_INVOKED_PROVIDER3;
    SEMATTRS_FAAS_INVOKED_REGION3 = TMP_FAAS_INVOKED_REGION3;
    SEMATTRS_NET_TRANSPORT3 = TMP_NET_TRANSPORT3;
    SEMATTRS_NET_PEER_IP3 = TMP_NET_PEER_IP3;
    SEMATTRS_NET_PEER_PORT3 = TMP_NET_PEER_PORT3;
    SEMATTRS_NET_PEER_NAME3 = TMP_NET_PEER_NAME3;
    SEMATTRS_NET_HOST_IP3 = TMP_NET_HOST_IP3;
    SEMATTRS_NET_HOST_PORT3 = TMP_NET_HOST_PORT3;
    SEMATTRS_NET_HOST_NAME3 = TMP_NET_HOST_NAME3;
    SEMATTRS_NET_HOST_CONNECTION_TYPE3 = TMP_NET_HOST_CONNECTION_TYPE3;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE3 = TMP_NET_HOST_CONNECTION_SUBTYPE3;
    SEMATTRS_NET_HOST_CARRIER_NAME3 = TMP_NET_HOST_CARRIER_NAME3;
    SEMATTRS_NET_HOST_CARRIER_MCC3 = TMP_NET_HOST_CARRIER_MCC3;
    SEMATTRS_NET_HOST_CARRIER_MNC3 = TMP_NET_HOST_CARRIER_MNC3;
    SEMATTRS_NET_HOST_CARRIER_ICC3 = TMP_NET_HOST_CARRIER_ICC3;
    SEMATTRS_PEER_SERVICE3 = TMP_PEER_SERVICE3;
    SEMATTRS_ENDUSER_ID3 = TMP_ENDUSER_ID3;
    SEMATTRS_ENDUSER_ROLE3 = TMP_ENDUSER_ROLE3;
    SEMATTRS_ENDUSER_SCOPE3 = TMP_ENDUSER_SCOPE3;
    SEMATTRS_THREAD_ID3 = TMP_THREAD_ID3;
    SEMATTRS_THREAD_NAME3 = TMP_THREAD_NAME3;
    SEMATTRS_CODE_FUNCTION3 = TMP_CODE_FUNCTION3;
    SEMATTRS_CODE_NAMESPACE3 = TMP_CODE_NAMESPACE3;
    SEMATTRS_CODE_FILEPATH3 = TMP_CODE_FILEPATH3;
    SEMATTRS_CODE_LINENO3 = TMP_CODE_LINENO3;
    SEMATTRS_HTTP_METHOD3 = TMP_HTTP_METHOD3;
    SEMATTRS_HTTP_URL3 = TMP_HTTP_URL3;
    SEMATTRS_HTTP_TARGET3 = TMP_HTTP_TARGET3;
    SEMATTRS_HTTP_HOST3 = TMP_HTTP_HOST3;
    SEMATTRS_HTTP_SCHEME3 = TMP_HTTP_SCHEME3;
    SEMATTRS_HTTP_STATUS_CODE3 = TMP_HTTP_STATUS_CODE3;
    SEMATTRS_HTTP_FLAVOR3 = TMP_HTTP_FLAVOR3;
    SEMATTRS_HTTP_USER_AGENT3 = TMP_HTTP_USER_AGENT3;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH3 = TMP_HTTP_REQUEST_CONTENT_LENGTH3;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3 = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH3 = TMP_HTTP_RESPONSE_CONTENT_LENGTH3;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3 = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3;
    SEMATTRS_HTTP_SERVER_NAME3 = TMP_HTTP_SERVER_NAME3;
    SEMATTRS_HTTP_ROUTE3 = TMP_HTTP_ROUTE3;
    SEMATTRS_HTTP_CLIENT_IP3 = TMP_HTTP_CLIENT_IP3;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES3 = TMP_AWS_DYNAMODB_TABLE_NAMES3;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY3 = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY3;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3 = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3 = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3 = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ3 = TMP_AWS_DYNAMODB_CONSISTENT_READ3;
    SEMATTRS_AWS_DYNAMODB_PROJECTION3 = TMP_AWS_DYNAMODB_PROJECTION3;
    SEMATTRS_AWS_DYNAMODB_LIMIT3 = TMP_AWS_DYNAMODB_LIMIT3;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET3 = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET3;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME3 = TMP_AWS_DYNAMODB_INDEX_NAME3;
    SEMATTRS_AWS_DYNAMODB_SELECT3 = TMP_AWS_DYNAMODB_SELECT3;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3 = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3 = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT3 = TMP_AWS_DYNAMODB_TABLE_COUNT3;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD3 = TMP_AWS_DYNAMODB_SCAN_FORWARD3;
    SEMATTRS_AWS_DYNAMODB_SEGMENT3 = TMP_AWS_DYNAMODB_SEGMENT3;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS3 = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS3;
    SEMATTRS_AWS_DYNAMODB_COUNT3 = TMP_AWS_DYNAMODB_COUNT3;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT3 = TMP_AWS_DYNAMODB_SCANNED_COUNT3;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3 = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3;
    SEMATTRS_MESSAGING_SYSTEM3 = TMP_MESSAGING_SYSTEM3;
    SEMATTRS_MESSAGING_DESTINATION3 = TMP_MESSAGING_DESTINATION3;
    SEMATTRS_MESSAGING_DESTINATION_KIND3 = TMP_MESSAGING_DESTINATION_KIND3;
    SEMATTRS_MESSAGING_TEMP_DESTINATION3 = TMP_MESSAGING_TEMP_DESTINATION3;
    SEMATTRS_MESSAGING_PROTOCOL3 = TMP_MESSAGING_PROTOCOL3;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION3 = TMP_MESSAGING_PROTOCOL_VERSION3;
    SEMATTRS_MESSAGING_URL3 = TMP_MESSAGING_URL3;
    SEMATTRS_MESSAGING_MESSAGE_ID3 = TMP_MESSAGING_MESSAGE_ID3;
    SEMATTRS_MESSAGING_CONVERSATION_ID3 = TMP_MESSAGING_CONVERSATION_ID3;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3 = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3 = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3;
    SEMATTRS_MESSAGING_OPERATION3 = TMP_MESSAGING_OPERATION3;
    SEMATTRS_MESSAGING_CONSUMER_ID3 = TMP_MESSAGING_CONSUMER_ID3;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY3 = TMP_MESSAGING_RABBITMQ_ROUTING_KEY3;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY3 = TMP_MESSAGING_KAFKA_MESSAGE_KEY3;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP3 = TMP_MESSAGING_KAFKA_CONSUMER_GROUP3;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID3 = TMP_MESSAGING_KAFKA_CLIENT_ID3;
    SEMATTRS_MESSAGING_KAFKA_PARTITION3 = TMP_MESSAGING_KAFKA_PARTITION3;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE3 = TMP_MESSAGING_KAFKA_TOMBSTONE3;
    SEMATTRS_RPC_SYSTEM3 = TMP_RPC_SYSTEM3;
    SEMATTRS_RPC_SERVICE3 = TMP_RPC_SERVICE3;
    SEMATTRS_RPC_METHOD3 = TMP_RPC_METHOD3;
    SEMATTRS_RPC_GRPC_STATUS_CODE3 = TMP_RPC_GRPC_STATUS_CODE3;
    SEMATTRS_RPC_JSONRPC_VERSION3 = TMP_RPC_JSONRPC_VERSION3;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID3 = TMP_RPC_JSONRPC_REQUEST_ID3;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE3 = TMP_RPC_JSONRPC_ERROR_CODE3;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE3 = TMP_RPC_JSONRPC_ERROR_MESSAGE3;
    SEMATTRS_MESSAGE_TYPE3 = TMP_MESSAGE_TYPE3;
    SEMATTRS_MESSAGE_ID3 = TMP_MESSAGE_ID3;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE3 = TMP_MESSAGE_COMPRESSED_SIZE3;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE3 = TMP_MESSAGE_UNCOMPRESSED_SIZE3;
    SemanticAttributes3 = /* @__PURE__ */ createConstMap3([
      TMP_AWS_LAMBDA_INVOKED_ARN3,
      TMP_DB_SYSTEM3,
      TMP_DB_CONNECTION_STRING3,
      TMP_DB_USER3,
      TMP_DB_JDBC_DRIVER_CLASSNAME3,
      TMP_DB_NAME3,
      TMP_DB_STATEMENT3,
      TMP_DB_OPERATION3,
      TMP_DB_MSSQL_INSTANCE_NAME3,
      TMP_DB_CASSANDRA_KEYSPACE3,
      TMP_DB_CASSANDRA_PAGE_SIZE3,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL3,
      TMP_DB_CASSANDRA_TABLE3,
      TMP_DB_CASSANDRA_IDEMPOTENCE3,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3,
      TMP_DB_CASSANDRA_COORDINATOR_ID3,
      TMP_DB_CASSANDRA_COORDINATOR_DC3,
      TMP_DB_HBASE_NAMESPACE3,
      TMP_DB_REDIS_DATABASE_INDEX3,
      TMP_DB_MONGODB_COLLECTION3,
      TMP_DB_SQL_TABLE3,
      TMP_EXCEPTION_TYPE3,
      TMP_EXCEPTION_MESSAGE3,
      TMP_EXCEPTION_STACKTRACE3,
      TMP_EXCEPTION_ESCAPED3,
      TMP_FAAS_TRIGGER3,
      TMP_FAAS_EXECUTION3,
      TMP_FAAS_DOCUMENT_COLLECTION3,
      TMP_FAAS_DOCUMENT_OPERATION3,
      TMP_FAAS_DOCUMENT_TIME3,
      TMP_FAAS_DOCUMENT_NAME3,
      TMP_FAAS_TIME3,
      TMP_FAAS_CRON3,
      TMP_FAAS_COLDSTART3,
      TMP_FAAS_INVOKED_NAME3,
      TMP_FAAS_INVOKED_PROVIDER3,
      TMP_FAAS_INVOKED_REGION3,
      TMP_NET_TRANSPORT3,
      TMP_NET_PEER_IP3,
      TMP_NET_PEER_PORT3,
      TMP_NET_PEER_NAME3,
      TMP_NET_HOST_IP3,
      TMP_NET_HOST_PORT3,
      TMP_NET_HOST_NAME3,
      TMP_NET_HOST_CONNECTION_TYPE3,
      TMP_NET_HOST_CONNECTION_SUBTYPE3,
      TMP_NET_HOST_CARRIER_NAME3,
      TMP_NET_HOST_CARRIER_MCC3,
      TMP_NET_HOST_CARRIER_MNC3,
      TMP_NET_HOST_CARRIER_ICC3,
      TMP_PEER_SERVICE3,
      TMP_ENDUSER_ID3,
      TMP_ENDUSER_ROLE3,
      TMP_ENDUSER_SCOPE3,
      TMP_THREAD_ID3,
      TMP_THREAD_NAME3,
      TMP_CODE_FUNCTION3,
      TMP_CODE_NAMESPACE3,
      TMP_CODE_FILEPATH3,
      TMP_CODE_LINENO3,
      TMP_HTTP_METHOD3,
      TMP_HTTP_URL3,
      TMP_HTTP_TARGET3,
      TMP_HTTP_HOST3,
      TMP_HTTP_SCHEME3,
      TMP_HTTP_STATUS_CODE3,
      TMP_HTTP_FLAVOR3,
      TMP_HTTP_USER_AGENT3,
      TMP_HTTP_REQUEST_CONTENT_LENGTH3,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH3,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3,
      TMP_HTTP_SERVER_NAME3,
      TMP_HTTP_ROUTE3,
      TMP_HTTP_CLIENT_IP3,
      TMP_AWS_DYNAMODB_TABLE_NAMES3,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY3,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3,
      TMP_AWS_DYNAMODB_CONSISTENT_READ3,
      TMP_AWS_DYNAMODB_PROJECTION3,
      TMP_AWS_DYNAMODB_LIMIT3,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET3,
      TMP_AWS_DYNAMODB_INDEX_NAME3,
      TMP_AWS_DYNAMODB_SELECT3,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3,
      TMP_AWS_DYNAMODB_TABLE_COUNT3,
      TMP_AWS_DYNAMODB_SCAN_FORWARD3,
      TMP_AWS_DYNAMODB_SEGMENT3,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS3,
      TMP_AWS_DYNAMODB_COUNT3,
      TMP_AWS_DYNAMODB_SCANNED_COUNT3,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3,
      TMP_MESSAGING_SYSTEM3,
      TMP_MESSAGING_DESTINATION3,
      TMP_MESSAGING_DESTINATION_KIND3,
      TMP_MESSAGING_TEMP_DESTINATION3,
      TMP_MESSAGING_PROTOCOL3,
      TMP_MESSAGING_PROTOCOL_VERSION3,
      TMP_MESSAGING_URL3,
      TMP_MESSAGING_MESSAGE_ID3,
      TMP_MESSAGING_CONVERSATION_ID3,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3,
      TMP_MESSAGING_OPERATION3,
      TMP_MESSAGING_CONSUMER_ID3,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY3,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY3,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP3,
      TMP_MESSAGING_KAFKA_CLIENT_ID3,
      TMP_MESSAGING_KAFKA_PARTITION3,
      TMP_MESSAGING_KAFKA_TOMBSTONE3,
      TMP_RPC_SYSTEM3,
      TMP_RPC_SERVICE3,
      TMP_RPC_METHOD3,
      TMP_RPC_GRPC_STATUS_CODE3,
      TMP_RPC_JSONRPC_VERSION3,
      TMP_RPC_JSONRPC_REQUEST_ID3,
      TMP_RPC_JSONRPC_ERROR_CODE3,
      TMP_RPC_JSONRPC_ERROR_MESSAGE3,
      TMP_MESSAGE_TYPE3,
      TMP_MESSAGE_ID3,
      TMP_MESSAGE_COMPRESSED_SIZE3,
      TMP_MESSAGE_UNCOMPRESSED_SIZE3
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL3 = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL3 = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL3 = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE3 = "oracle";
    TMP_DBSYSTEMVALUES_DB23 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL3 = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT3 = "redshift";
    TMP_DBSYSTEMVALUES_HIVE3 = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE3 = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB3 = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS3 = "progress";
    TMP_DBSYSTEMVALUES_MAXDB3 = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB3 = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES3 = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL3 = "firstsql";
    TMP_DBSYSTEMVALUES_EDB3 = "edb";
    TMP_DBSYSTEMVALUES_CACHE3 = "cache";
    TMP_DBSYSTEMVALUES_ADABAS3 = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD3 = "firebird";
    TMP_DBSYSTEMVALUES_DERBY3 = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER3 = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX3 = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB3 = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE3 = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB3 = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA3 = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE3 = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE3 = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE3 = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE3 = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA3 = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA3 = "vertica";
    TMP_DBSYSTEMVALUES_H23 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION3 = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA3 = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE3 = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB3 = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS3 = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE3 = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB3 = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB3 = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB3 = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J3 = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE3 = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH3 = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED3 = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB3 = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL3 = TMP_DBSYSTEMVALUES_OTHER_SQL3;
    DBSYSTEMVALUES_MSSQL3 = TMP_DBSYSTEMVALUES_MSSQL3;
    DBSYSTEMVALUES_MYSQL3 = TMP_DBSYSTEMVALUES_MYSQL3;
    DBSYSTEMVALUES_ORACLE3 = TMP_DBSYSTEMVALUES_ORACLE3;
    DBSYSTEMVALUES_DB23 = TMP_DBSYSTEMVALUES_DB23;
    DBSYSTEMVALUES_POSTGRESQL3 = TMP_DBSYSTEMVALUES_POSTGRESQL3;
    DBSYSTEMVALUES_REDSHIFT3 = TMP_DBSYSTEMVALUES_REDSHIFT3;
    DBSYSTEMVALUES_HIVE3 = TMP_DBSYSTEMVALUES_HIVE3;
    DBSYSTEMVALUES_CLOUDSCAPE3 = TMP_DBSYSTEMVALUES_CLOUDSCAPE3;
    DBSYSTEMVALUES_HSQLDB3 = TMP_DBSYSTEMVALUES_HSQLDB3;
    DBSYSTEMVALUES_PROGRESS3 = TMP_DBSYSTEMVALUES_PROGRESS3;
    DBSYSTEMVALUES_MAXDB3 = TMP_DBSYSTEMVALUES_MAXDB3;
    DBSYSTEMVALUES_HANADB3 = TMP_DBSYSTEMVALUES_HANADB3;
    DBSYSTEMVALUES_INGRES3 = TMP_DBSYSTEMVALUES_INGRES3;
    DBSYSTEMVALUES_FIRSTSQL3 = TMP_DBSYSTEMVALUES_FIRSTSQL3;
    DBSYSTEMVALUES_EDB3 = TMP_DBSYSTEMVALUES_EDB3;
    DBSYSTEMVALUES_CACHE3 = TMP_DBSYSTEMVALUES_CACHE3;
    DBSYSTEMVALUES_ADABAS3 = TMP_DBSYSTEMVALUES_ADABAS3;
    DBSYSTEMVALUES_FIREBIRD3 = TMP_DBSYSTEMVALUES_FIREBIRD3;
    DBSYSTEMVALUES_DERBY3 = TMP_DBSYSTEMVALUES_DERBY3;
    DBSYSTEMVALUES_FILEMAKER3 = TMP_DBSYSTEMVALUES_FILEMAKER3;
    DBSYSTEMVALUES_INFORMIX3 = TMP_DBSYSTEMVALUES_INFORMIX3;
    DBSYSTEMVALUES_INSTANTDB3 = TMP_DBSYSTEMVALUES_INSTANTDB3;
    DBSYSTEMVALUES_INTERBASE3 = TMP_DBSYSTEMVALUES_INTERBASE3;
    DBSYSTEMVALUES_MARIADB3 = TMP_DBSYSTEMVALUES_MARIADB3;
    DBSYSTEMVALUES_NETEZZA3 = TMP_DBSYSTEMVALUES_NETEZZA3;
    DBSYSTEMVALUES_PERVASIVE3 = TMP_DBSYSTEMVALUES_PERVASIVE3;
    DBSYSTEMVALUES_POINTBASE3 = TMP_DBSYSTEMVALUES_POINTBASE3;
    DBSYSTEMVALUES_SQLITE3 = TMP_DBSYSTEMVALUES_SQLITE3;
    DBSYSTEMVALUES_SYBASE3 = TMP_DBSYSTEMVALUES_SYBASE3;
    DBSYSTEMVALUES_TERADATA3 = TMP_DBSYSTEMVALUES_TERADATA3;
    DBSYSTEMVALUES_VERTICA3 = TMP_DBSYSTEMVALUES_VERTICA3;
    DBSYSTEMVALUES_H23 = TMP_DBSYSTEMVALUES_H23;
    DBSYSTEMVALUES_COLDFUSION3 = TMP_DBSYSTEMVALUES_COLDFUSION3;
    DBSYSTEMVALUES_CASSANDRA3 = TMP_DBSYSTEMVALUES_CASSANDRA3;
    DBSYSTEMVALUES_HBASE3 = TMP_DBSYSTEMVALUES_HBASE3;
    DBSYSTEMVALUES_MONGODB3 = TMP_DBSYSTEMVALUES_MONGODB3;
    DBSYSTEMVALUES_REDIS3 = TMP_DBSYSTEMVALUES_REDIS3;
    DBSYSTEMVALUES_COUCHBASE3 = TMP_DBSYSTEMVALUES_COUCHBASE3;
    DBSYSTEMVALUES_COUCHDB3 = TMP_DBSYSTEMVALUES_COUCHDB3;
    DBSYSTEMVALUES_COSMOSDB3 = TMP_DBSYSTEMVALUES_COSMOSDB3;
    DBSYSTEMVALUES_DYNAMODB3 = TMP_DBSYSTEMVALUES_DYNAMODB3;
    DBSYSTEMVALUES_NEO4J3 = TMP_DBSYSTEMVALUES_NEO4J3;
    DBSYSTEMVALUES_GEODE3 = TMP_DBSYSTEMVALUES_GEODE3;
    DBSYSTEMVALUES_ELASTICSEARCH3 = TMP_DBSYSTEMVALUES_ELASTICSEARCH3;
    DBSYSTEMVALUES_MEMCACHED3 = TMP_DBSYSTEMVALUES_MEMCACHED3;
    DBSYSTEMVALUES_COCKROACHDB3 = TMP_DBSYSTEMVALUES_COCKROACHDB3;
    DbSystemValues3 = /* @__PURE__ */ createConstMap3([
      TMP_DBSYSTEMVALUES_OTHER_SQL3,
      TMP_DBSYSTEMVALUES_MSSQL3,
      TMP_DBSYSTEMVALUES_MYSQL3,
      TMP_DBSYSTEMVALUES_ORACLE3,
      TMP_DBSYSTEMVALUES_DB23,
      TMP_DBSYSTEMVALUES_POSTGRESQL3,
      TMP_DBSYSTEMVALUES_REDSHIFT3,
      TMP_DBSYSTEMVALUES_HIVE3,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE3,
      TMP_DBSYSTEMVALUES_HSQLDB3,
      TMP_DBSYSTEMVALUES_PROGRESS3,
      TMP_DBSYSTEMVALUES_MAXDB3,
      TMP_DBSYSTEMVALUES_HANADB3,
      TMP_DBSYSTEMVALUES_INGRES3,
      TMP_DBSYSTEMVALUES_FIRSTSQL3,
      TMP_DBSYSTEMVALUES_EDB3,
      TMP_DBSYSTEMVALUES_CACHE3,
      TMP_DBSYSTEMVALUES_ADABAS3,
      TMP_DBSYSTEMVALUES_FIREBIRD3,
      TMP_DBSYSTEMVALUES_DERBY3,
      TMP_DBSYSTEMVALUES_FILEMAKER3,
      TMP_DBSYSTEMVALUES_INFORMIX3,
      TMP_DBSYSTEMVALUES_INSTANTDB3,
      TMP_DBSYSTEMVALUES_INTERBASE3,
      TMP_DBSYSTEMVALUES_MARIADB3,
      TMP_DBSYSTEMVALUES_NETEZZA3,
      TMP_DBSYSTEMVALUES_PERVASIVE3,
      TMP_DBSYSTEMVALUES_POINTBASE3,
      TMP_DBSYSTEMVALUES_SQLITE3,
      TMP_DBSYSTEMVALUES_SYBASE3,
      TMP_DBSYSTEMVALUES_TERADATA3,
      TMP_DBSYSTEMVALUES_VERTICA3,
      TMP_DBSYSTEMVALUES_H23,
      TMP_DBSYSTEMVALUES_COLDFUSION3,
      TMP_DBSYSTEMVALUES_CASSANDRA3,
      TMP_DBSYSTEMVALUES_HBASE3,
      TMP_DBSYSTEMVALUES_MONGODB3,
      TMP_DBSYSTEMVALUES_REDIS3,
      TMP_DBSYSTEMVALUES_COUCHBASE3,
      TMP_DBSYSTEMVALUES_COUCHDB3,
      TMP_DBSYSTEMVALUES_COSMOSDB3,
      TMP_DBSYSTEMVALUES_DYNAMODB3,
      TMP_DBSYSTEMVALUES_NEO4J3,
      TMP_DBSYSTEMVALUES_GEODE3,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH3,
      TMP_DBSYSTEMVALUES_MEMCACHED3,
      TMP_DBSYSTEMVALUES_COCKROACHDB3
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL3 = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3 = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3 = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3 = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE3 = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO3 = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE3 = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3 = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY3 = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3 = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3 = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL3;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE3;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO3;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE3;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY3;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3;
    DbCassandraConsistencyLevelValues3 = /* @__PURE__ */ createConstMap3([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE3 = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP3 = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB3 = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER3 = "timer";
    TMP_FAASTRIGGERVALUES_OTHER3 = "other";
    FAASTRIGGERVALUES_DATASOURCE3 = TMP_FAASTRIGGERVALUES_DATASOURCE3;
    FAASTRIGGERVALUES_HTTP3 = TMP_FAASTRIGGERVALUES_HTTP3;
    FAASTRIGGERVALUES_PUBSUB3 = TMP_FAASTRIGGERVALUES_PUBSUB3;
    FAASTRIGGERVALUES_TIMER3 = TMP_FAASTRIGGERVALUES_TIMER3;
    FAASTRIGGERVALUES_OTHER3 = TMP_FAASTRIGGERVALUES_OTHER3;
    FaasTriggerValues3 = /* @__PURE__ */ createConstMap3([
      TMP_FAASTRIGGERVALUES_DATASOURCE3,
      TMP_FAASTRIGGERVALUES_HTTP3,
      TMP_FAASTRIGGERVALUES_PUBSUB3,
      TMP_FAASTRIGGERVALUES_TIMER3,
      TMP_FAASTRIGGERVALUES_OTHER3
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT3 = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT3 = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE3 = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT3 = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT3;
    FAASDOCUMENTOPERATIONVALUES_EDIT3 = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT3;
    FAASDOCUMENTOPERATIONVALUES_DELETE3 = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE3;
    FaasDocumentOperationValues3 = /* @__PURE__ */ createConstMap3([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT3,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT3,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE3
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3 = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS3 = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE3 = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP3 = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3 = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3;
    FAASINVOKEDPROVIDERVALUES_AWS3 = TMP_FAASINVOKEDPROVIDERVALUES_AWS3;
    FAASINVOKEDPROVIDERVALUES_AZURE3 = TMP_FAASINVOKEDPROVIDERVALUES_AZURE3;
    FAASINVOKEDPROVIDERVALUES_GCP3 = TMP_FAASINVOKEDPROVIDERVALUES_GCP3;
    FaasInvokedProviderValues3 = /* @__PURE__ */ createConstMap3([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS3,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE3,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP3
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP3 = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP3 = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP3 = "ip";
    TMP_NETTRANSPORTVALUES_UNIX3 = "unix";
    TMP_NETTRANSPORTVALUES_PIPE3 = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC3 = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER3 = "other";
    NETTRANSPORTVALUES_IP_TCP3 = TMP_NETTRANSPORTVALUES_IP_TCP3;
    NETTRANSPORTVALUES_IP_UDP3 = TMP_NETTRANSPORTVALUES_IP_UDP3;
    NETTRANSPORTVALUES_IP3 = TMP_NETTRANSPORTVALUES_IP3;
    NETTRANSPORTVALUES_UNIX3 = TMP_NETTRANSPORTVALUES_UNIX3;
    NETTRANSPORTVALUES_PIPE3 = TMP_NETTRANSPORTVALUES_PIPE3;
    NETTRANSPORTVALUES_INPROC3 = TMP_NETTRANSPORTVALUES_INPROC3;
    NETTRANSPORTVALUES_OTHER3 = TMP_NETTRANSPORTVALUES_OTHER3;
    NetTransportValues3 = /* @__PURE__ */ createConstMap3([
      TMP_NETTRANSPORTVALUES_IP_TCP3,
      TMP_NETTRANSPORTVALUES_IP_UDP3,
      TMP_NETTRANSPORTVALUES_IP3,
      TMP_NETTRANSPORTVALUES_UNIX3,
      TMP_NETTRANSPORTVALUES_PIPE3,
      TMP_NETTRANSPORTVALUES_INPROC3,
      TMP_NETTRANSPORTVALUES_OTHER3
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI3 = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED3 = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL3 = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3 = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3 = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI3 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI3;
    NETHOSTCONNECTIONTYPEVALUES_WIRED3 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED3;
    NETHOSTCONNECTIONTYPEVALUES_CELL3 = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL3;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3;
    NetHostConnectionTypeValues3 = /* @__PURE__ */ createConstMap3([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI3,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED3,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL3,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3 = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3 = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3 = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3 = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3 = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3 = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3 = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3 = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3 = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3 = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3 = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE3 = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3 = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3 = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM3 = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3 = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3 = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR3 = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3 = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3 = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE3;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM3;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR3;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3;
    NetHostConnectionSubtypeValues3 = /* @__PURE__ */ createConstMap3([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_03 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_13 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_03 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY3 = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC3 = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_03 = TMP_HTTPFLAVORVALUES_HTTP_1_03;
    HTTPFLAVORVALUES_HTTP_1_13 = TMP_HTTPFLAVORVALUES_HTTP_1_13;
    HTTPFLAVORVALUES_HTTP_2_03 = TMP_HTTPFLAVORVALUES_HTTP_2_03;
    HTTPFLAVORVALUES_SPDY3 = TMP_HTTPFLAVORVALUES_SPDY3;
    HTTPFLAVORVALUES_QUIC3 = TMP_HTTPFLAVORVALUES_QUIC3;
    HttpFlavorValues3 = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_03,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_13,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_03,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY3,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC3
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE3 = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC3 = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE3 = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE3;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC3 = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC3;
    MessagingDestinationKindValues3 = /* @__PURE__ */ createConstMap3([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE3,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC3
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE3 = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS3 = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE3 = TMP_MESSAGINGOPERATIONVALUES_RECEIVE3;
    MESSAGINGOPERATIONVALUES_PROCESS3 = TMP_MESSAGINGOPERATIONVALUES_PROCESS3;
    MessagingOperationValues3 = /* @__PURE__ */ createConstMap3([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE3,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS3
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK3 = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED3 = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN3 = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3 = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3 = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND3 = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3 = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3 = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3 = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3 = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED3 = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3 = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3 = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL3 = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3 = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS3 = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3 = 16;
    RPCGRPCSTATUSCODEVALUES_OK3 = TMP_RPCGRPCSTATUSCODEVALUES_OK3;
    RPCGRPCSTATUSCODEVALUES_CANCELLED3 = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED3;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN3 = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN3;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3 = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3 = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND3 = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND3;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3 = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3 = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3 = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3 = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3;
    RPCGRPCSTATUSCODEVALUES_ABORTED3 = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED3;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3 = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3 = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3;
    RPCGRPCSTATUSCODEVALUES_INTERNAL3 = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL3;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3 = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS3 = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS3;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3 = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3;
    RpcGrpcStatusCodeValues3 = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK3,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED3,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN3,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND3,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED3,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL3,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS3,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3
    };
    TMP_MESSAGETYPEVALUES_SENT3 = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED3 = "RECEIVED";
    MESSAGETYPEVALUES_SENT3 = TMP_MESSAGETYPEVALUES_SENT3;
    MESSAGETYPEVALUES_RECEIVED3 = TMP_MESSAGETYPEVALUES_RECEIVED3;
    MessageTypeValues3 = /* @__PURE__ */ createConstMap3([
      TMP_MESSAGETYPEVALUES_SENT3,
      TMP_MESSAGETYPEVALUES_RECEIVED3
    ]);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace4 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes3();
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER3, TMP_CLOUD_ACCOUNT_ID3, TMP_CLOUD_REGION3, TMP_CLOUD_AVAILABILITY_ZONE3, TMP_CLOUD_PLATFORM3, TMP_AWS_ECS_CONTAINER_ARN3, TMP_AWS_ECS_CLUSTER_ARN3, TMP_AWS_ECS_LAUNCHTYPE3, TMP_AWS_ECS_TASK_ARN3, TMP_AWS_ECS_TASK_FAMILY3, TMP_AWS_ECS_TASK_REVISION3, TMP_AWS_EKS_CLUSTER_ARN3, TMP_AWS_LOG_GROUP_NAMES3, TMP_AWS_LOG_GROUP_ARNS3, TMP_AWS_LOG_STREAM_NAMES3, TMP_AWS_LOG_STREAM_ARNS3, TMP_CONTAINER_NAME3, TMP_CONTAINER_ID3, TMP_CONTAINER_RUNTIME3, TMP_CONTAINER_IMAGE_NAME3, TMP_CONTAINER_IMAGE_TAG3, TMP_DEPLOYMENT_ENVIRONMENT3, TMP_DEVICE_ID3, TMP_DEVICE_MODEL_IDENTIFIER3, TMP_DEVICE_MODEL_NAME3, TMP_FAAS_NAME3, TMP_FAAS_ID3, TMP_FAAS_VERSION3, TMP_FAAS_INSTANCE3, TMP_FAAS_MAX_MEMORY3, TMP_HOST_ID3, TMP_HOST_NAME3, TMP_HOST_TYPE3, TMP_HOST_ARCH3, TMP_HOST_IMAGE_NAME3, TMP_HOST_IMAGE_ID3, TMP_HOST_IMAGE_VERSION3, TMP_K8S_CLUSTER_NAME3, TMP_K8S_NODE_NAME3, TMP_K8S_NODE_UID3, TMP_K8S_NAMESPACE_NAME3, TMP_K8S_POD_UID3, TMP_K8S_POD_NAME3, TMP_K8S_CONTAINER_NAME3, TMP_K8S_REPLICASET_UID3, TMP_K8S_REPLICASET_NAME3, TMP_K8S_DEPLOYMENT_UID3, TMP_K8S_DEPLOYMENT_NAME3, TMP_K8S_STATEFULSET_UID3, TMP_K8S_STATEFULSET_NAME3, TMP_K8S_DAEMONSET_UID3, TMP_K8S_DAEMONSET_NAME3, TMP_K8S_JOB_UID3, TMP_K8S_JOB_NAME3, TMP_K8S_CRONJOB_UID3, TMP_K8S_CRONJOB_NAME3, TMP_OS_TYPE3, TMP_OS_DESCRIPTION3, TMP_OS_NAME3, TMP_OS_VERSION3, TMP_PROCESS_PID3, TMP_PROCESS_EXECUTABLE_NAME3, TMP_PROCESS_EXECUTABLE_PATH3, TMP_PROCESS_COMMAND3, TMP_PROCESS_COMMAND_LINE3, TMP_PROCESS_COMMAND_ARGS3, TMP_PROCESS_OWNER3, TMP_PROCESS_RUNTIME_NAME3, TMP_PROCESS_RUNTIME_VERSION3, TMP_PROCESS_RUNTIME_DESCRIPTION3, TMP_SERVICE_NAME3, TMP_SERVICE_NAMESPACE3, TMP_SERVICE_INSTANCE_ID3, TMP_SERVICE_VERSION3, TMP_TELEMETRY_SDK_NAME3, TMP_TELEMETRY_SDK_LANGUAGE3, TMP_TELEMETRY_SDK_VERSION3, TMP_TELEMETRY_AUTO_VERSION3, TMP_WEBENGINE_NAME3, TMP_WEBENGINE_VERSION3, TMP_WEBENGINE_DESCRIPTION3, SEMRESATTRS_CLOUD_PROVIDER3, SEMRESATTRS_CLOUD_ACCOUNT_ID3, SEMRESATTRS_CLOUD_REGION3, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE3, SEMRESATTRS_CLOUD_PLATFORM3, SEMRESATTRS_AWS_ECS_CONTAINER_ARN3, SEMRESATTRS_AWS_ECS_CLUSTER_ARN3, SEMRESATTRS_AWS_ECS_LAUNCHTYPE3, SEMRESATTRS_AWS_ECS_TASK_ARN3, SEMRESATTRS_AWS_ECS_TASK_FAMILY3, SEMRESATTRS_AWS_ECS_TASK_REVISION3, SEMRESATTRS_AWS_EKS_CLUSTER_ARN3, SEMRESATTRS_AWS_LOG_GROUP_NAMES3, SEMRESATTRS_AWS_LOG_GROUP_ARNS3, SEMRESATTRS_AWS_LOG_STREAM_NAMES3, SEMRESATTRS_AWS_LOG_STREAM_ARNS3, SEMRESATTRS_CONTAINER_NAME3, SEMRESATTRS_CONTAINER_ID3, SEMRESATTRS_CONTAINER_RUNTIME3, SEMRESATTRS_CONTAINER_IMAGE_NAME3, SEMRESATTRS_CONTAINER_IMAGE_TAG3, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT3, SEMRESATTRS_DEVICE_ID3, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER3, SEMRESATTRS_DEVICE_MODEL_NAME3, SEMRESATTRS_FAAS_NAME3, SEMRESATTRS_FAAS_ID3, SEMRESATTRS_FAAS_VERSION3, SEMRESATTRS_FAAS_INSTANCE3, SEMRESATTRS_FAAS_MAX_MEMORY3, SEMRESATTRS_HOST_ID3, SEMRESATTRS_HOST_NAME3, SEMRESATTRS_HOST_TYPE3, SEMRESATTRS_HOST_ARCH3, SEMRESATTRS_HOST_IMAGE_NAME3, SEMRESATTRS_HOST_IMAGE_ID3, SEMRESATTRS_HOST_IMAGE_VERSION3, SEMRESATTRS_K8S_CLUSTER_NAME3, SEMRESATTRS_K8S_NODE_NAME3, SEMRESATTRS_K8S_NODE_UID3, SEMRESATTRS_K8S_NAMESPACE_NAME3, SEMRESATTRS_K8S_POD_UID3, SEMRESATTRS_K8S_POD_NAME3, SEMRESATTRS_K8S_CONTAINER_NAME3, SEMRESATTRS_K8S_REPLICASET_UID3, SEMRESATTRS_K8S_REPLICASET_NAME3, SEMRESATTRS_K8S_DEPLOYMENT_UID3, SEMRESATTRS_K8S_DEPLOYMENT_NAME3, SEMRESATTRS_K8S_STATEFULSET_UID3, SEMRESATTRS_K8S_STATEFULSET_NAME3, SEMRESATTRS_K8S_DAEMONSET_UID3, SEMRESATTRS_K8S_DAEMONSET_NAME3, SEMRESATTRS_K8S_JOB_UID3, SEMRESATTRS_K8S_JOB_NAME3, SEMRESATTRS_K8S_CRONJOB_UID3, SEMRESATTRS_K8S_CRONJOB_NAME3, SEMRESATTRS_OS_TYPE3, SEMRESATTRS_OS_DESCRIPTION3, SEMRESATTRS_OS_NAME3, SEMRESATTRS_OS_VERSION3, SEMRESATTRS_PROCESS_PID3, SEMRESATTRS_PROCESS_EXECUTABLE_NAME3, SEMRESATTRS_PROCESS_EXECUTABLE_PATH3, SEMRESATTRS_PROCESS_COMMAND3, SEMRESATTRS_PROCESS_COMMAND_LINE3, SEMRESATTRS_PROCESS_COMMAND_ARGS3, SEMRESATTRS_PROCESS_OWNER3, SEMRESATTRS_PROCESS_RUNTIME_NAME3, SEMRESATTRS_PROCESS_RUNTIME_VERSION3, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION3, SEMRESATTRS_SERVICE_NAME3, SEMRESATTRS_SERVICE_NAMESPACE3, SEMRESATTRS_SERVICE_INSTANCE_ID3, SEMRESATTRS_SERVICE_VERSION3, SEMRESATTRS_TELEMETRY_SDK_NAME3, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE3, SEMRESATTRS_TELEMETRY_SDK_VERSION3, SEMRESATTRS_TELEMETRY_AUTO_VERSION3, SEMRESATTRS_WEBENGINE_NAME3, SEMRESATTRS_WEBENGINE_VERSION3, SEMRESATTRS_WEBENGINE_DESCRIPTION3, SemanticResourceAttributes3, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD3, TMP_CLOUDPROVIDERVALUES_AWS3, TMP_CLOUDPROVIDERVALUES_AZURE3, TMP_CLOUDPROVIDERVALUES_GCP3, CLOUDPROVIDERVALUES_ALIBABA_CLOUD3, CLOUDPROVIDERVALUES_AWS3, CLOUDPROVIDERVALUES_AZURE3, CLOUDPROVIDERVALUES_GCP3, CloudProviderValues3, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3, TMP_CLOUDPLATFORMVALUES_AWS_EC23, TMP_CLOUDPLATFORMVALUES_AWS_ECS3, TMP_CLOUDPLATFORMVALUES_AWS_EKS3, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA3, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3, TMP_CLOUDPLATFORMVALUES_AZURE_VM3, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3, TMP_CLOUDPLATFORMVALUES_AZURE_AKS3, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE3, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3, CLOUDPLATFORMVALUES_AWS_EC23, CLOUDPLATFORMVALUES_AWS_ECS3, CLOUDPLATFORMVALUES_AWS_EKS3, CLOUDPLATFORMVALUES_AWS_LAMBDA3, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3, CLOUDPLATFORMVALUES_AZURE_VM3, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3, CLOUDPLATFORMVALUES_AZURE_AKS3, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3, CLOUDPLATFORMVALUES_GCP_APP_ENGINE3, CloudPlatformValues3, TMP_AWSECSLAUNCHTYPEVALUES_EC23, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE3, AWSECSLAUNCHTYPEVALUES_EC23, AWSECSLAUNCHTYPEVALUES_FARGATE3, AwsEcsLaunchtypeValues3, TMP_HOSTARCHVALUES_AMD643, TMP_HOSTARCHVALUES_ARM323, TMP_HOSTARCHVALUES_ARM643, TMP_HOSTARCHVALUES_IA643, TMP_HOSTARCHVALUES_PPC323, TMP_HOSTARCHVALUES_PPC643, TMP_HOSTARCHVALUES_X863, HOSTARCHVALUES_AMD643, HOSTARCHVALUES_ARM323, HOSTARCHVALUES_ARM643, HOSTARCHVALUES_IA643, HOSTARCHVALUES_PPC323, HOSTARCHVALUES_PPC643, HOSTARCHVALUES_X863, HostArchValues3, TMP_OSTYPEVALUES_WINDOWS3, TMP_OSTYPEVALUES_LINUX3, TMP_OSTYPEVALUES_DARWIN3, TMP_OSTYPEVALUES_FREEBSD3, TMP_OSTYPEVALUES_NETBSD3, TMP_OSTYPEVALUES_OPENBSD3, TMP_OSTYPEVALUES_DRAGONFLYBSD3, TMP_OSTYPEVALUES_HPUX3, TMP_OSTYPEVALUES_AIX3, TMP_OSTYPEVALUES_SOLARIS3, TMP_OSTYPEVALUES_Z_OS3, OSTYPEVALUES_WINDOWS3, OSTYPEVALUES_LINUX3, OSTYPEVALUES_DARWIN3, OSTYPEVALUES_FREEBSD3, OSTYPEVALUES_NETBSD3, OSTYPEVALUES_OPENBSD3, OSTYPEVALUES_DRAGONFLYBSD3, OSTYPEVALUES_HPUX3, OSTYPEVALUES_AIX3, OSTYPEVALUES_SOLARIS3, OSTYPEVALUES_Z_OS3, OsTypeValues3, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP3, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET3, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG3, TMP_TELEMETRYSDKLANGUAGEVALUES_GO3, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA3, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS3, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP3, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON3, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY3, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS3, TELEMETRYSDKLANGUAGEVALUES_CPP3, TELEMETRYSDKLANGUAGEVALUES_DOTNET3, TELEMETRYSDKLANGUAGEVALUES_ERLANG3, TELEMETRYSDKLANGUAGEVALUES_GO3, TELEMETRYSDKLANGUAGEVALUES_JAVA3, TELEMETRYSDKLANGUAGEVALUES_NODEJS3, TELEMETRYSDKLANGUAGEVALUES_PHP3, TELEMETRYSDKLANGUAGEVALUES_PYTHON3, TELEMETRYSDKLANGUAGEVALUES_RUBY3, TELEMETRYSDKLANGUAGEVALUES_WEBJS3, TelemetrySdkLanguageValues3;
var init_SemanticResourceAttributes3 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils5();
    TMP_CLOUD_PROVIDER3 = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID3 = "cloud.account.id";
    TMP_CLOUD_REGION3 = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE3 = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM3 = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN3 = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN3 = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE3 = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN3 = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY3 = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION3 = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN3 = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES3 = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS3 = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES3 = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS3 = "aws.log.stream.arns";
    TMP_CONTAINER_NAME3 = "container.name";
    TMP_CONTAINER_ID3 = "container.id";
    TMP_CONTAINER_RUNTIME3 = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME3 = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG3 = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT3 = "deployment.environment";
    TMP_DEVICE_ID3 = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER3 = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME3 = "device.model.name";
    TMP_FAAS_NAME3 = "faas.name";
    TMP_FAAS_ID3 = "faas.id";
    TMP_FAAS_VERSION3 = "faas.version";
    TMP_FAAS_INSTANCE3 = "faas.instance";
    TMP_FAAS_MAX_MEMORY3 = "faas.max_memory";
    TMP_HOST_ID3 = "host.id";
    TMP_HOST_NAME3 = "host.name";
    TMP_HOST_TYPE3 = "host.type";
    TMP_HOST_ARCH3 = "host.arch";
    TMP_HOST_IMAGE_NAME3 = "host.image.name";
    TMP_HOST_IMAGE_ID3 = "host.image.id";
    TMP_HOST_IMAGE_VERSION3 = "host.image.version";
    TMP_K8S_CLUSTER_NAME3 = "k8s.cluster.name";
    TMP_K8S_NODE_NAME3 = "k8s.node.name";
    TMP_K8S_NODE_UID3 = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME3 = "k8s.namespace.name";
    TMP_K8S_POD_UID3 = "k8s.pod.uid";
    TMP_K8S_POD_NAME3 = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME3 = "k8s.container.name";
    TMP_K8S_REPLICASET_UID3 = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME3 = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID3 = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME3 = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID3 = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME3 = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID3 = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME3 = "k8s.daemonset.name";
    TMP_K8S_JOB_UID3 = "k8s.job.uid";
    TMP_K8S_JOB_NAME3 = "k8s.job.name";
    TMP_K8S_CRONJOB_UID3 = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME3 = "k8s.cronjob.name";
    TMP_OS_TYPE3 = "os.type";
    TMP_OS_DESCRIPTION3 = "os.description";
    TMP_OS_NAME3 = "os.name";
    TMP_OS_VERSION3 = "os.version";
    TMP_PROCESS_PID3 = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME3 = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH3 = "process.executable.path";
    TMP_PROCESS_COMMAND3 = "process.command";
    TMP_PROCESS_COMMAND_LINE3 = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS3 = "process.command_args";
    TMP_PROCESS_OWNER3 = "process.owner";
    TMP_PROCESS_RUNTIME_NAME3 = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION3 = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION3 = "process.runtime.description";
    TMP_SERVICE_NAME3 = "service.name";
    TMP_SERVICE_NAMESPACE3 = "service.namespace";
    TMP_SERVICE_INSTANCE_ID3 = "service.instance.id";
    TMP_SERVICE_VERSION3 = "service.version";
    TMP_TELEMETRY_SDK_NAME3 = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE3 = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION3 = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION3 = "telemetry.auto.version";
    TMP_WEBENGINE_NAME3 = "webengine.name";
    TMP_WEBENGINE_VERSION3 = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION3 = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER3 = TMP_CLOUD_PROVIDER3;
    SEMRESATTRS_CLOUD_ACCOUNT_ID3 = TMP_CLOUD_ACCOUNT_ID3;
    SEMRESATTRS_CLOUD_REGION3 = TMP_CLOUD_REGION3;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE3 = TMP_CLOUD_AVAILABILITY_ZONE3;
    SEMRESATTRS_CLOUD_PLATFORM3 = TMP_CLOUD_PLATFORM3;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN3 = TMP_AWS_ECS_CONTAINER_ARN3;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN3 = TMP_AWS_ECS_CLUSTER_ARN3;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE3 = TMP_AWS_ECS_LAUNCHTYPE3;
    SEMRESATTRS_AWS_ECS_TASK_ARN3 = TMP_AWS_ECS_TASK_ARN3;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY3 = TMP_AWS_ECS_TASK_FAMILY3;
    SEMRESATTRS_AWS_ECS_TASK_REVISION3 = TMP_AWS_ECS_TASK_REVISION3;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN3 = TMP_AWS_EKS_CLUSTER_ARN3;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES3 = TMP_AWS_LOG_GROUP_NAMES3;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS3 = TMP_AWS_LOG_GROUP_ARNS3;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES3 = TMP_AWS_LOG_STREAM_NAMES3;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS3 = TMP_AWS_LOG_STREAM_ARNS3;
    SEMRESATTRS_CONTAINER_NAME3 = TMP_CONTAINER_NAME3;
    SEMRESATTRS_CONTAINER_ID3 = TMP_CONTAINER_ID3;
    SEMRESATTRS_CONTAINER_RUNTIME3 = TMP_CONTAINER_RUNTIME3;
    SEMRESATTRS_CONTAINER_IMAGE_NAME3 = TMP_CONTAINER_IMAGE_NAME3;
    SEMRESATTRS_CONTAINER_IMAGE_TAG3 = TMP_CONTAINER_IMAGE_TAG3;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT3 = TMP_DEPLOYMENT_ENVIRONMENT3;
    SEMRESATTRS_DEVICE_ID3 = TMP_DEVICE_ID3;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER3 = TMP_DEVICE_MODEL_IDENTIFIER3;
    SEMRESATTRS_DEVICE_MODEL_NAME3 = TMP_DEVICE_MODEL_NAME3;
    SEMRESATTRS_FAAS_NAME3 = TMP_FAAS_NAME3;
    SEMRESATTRS_FAAS_ID3 = TMP_FAAS_ID3;
    SEMRESATTRS_FAAS_VERSION3 = TMP_FAAS_VERSION3;
    SEMRESATTRS_FAAS_INSTANCE3 = TMP_FAAS_INSTANCE3;
    SEMRESATTRS_FAAS_MAX_MEMORY3 = TMP_FAAS_MAX_MEMORY3;
    SEMRESATTRS_HOST_ID3 = TMP_HOST_ID3;
    SEMRESATTRS_HOST_NAME3 = TMP_HOST_NAME3;
    SEMRESATTRS_HOST_TYPE3 = TMP_HOST_TYPE3;
    SEMRESATTRS_HOST_ARCH3 = TMP_HOST_ARCH3;
    SEMRESATTRS_HOST_IMAGE_NAME3 = TMP_HOST_IMAGE_NAME3;
    SEMRESATTRS_HOST_IMAGE_ID3 = TMP_HOST_IMAGE_ID3;
    SEMRESATTRS_HOST_IMAGE_VERSION3 = TMP_HOST_IMAGE_VERSION3;
    SEMRESATTRS_K8S_CLUSTER_NAME3 = TMP_K8S_CLUSTER_NAME3;
    SEMRESATTRS_K8S_NODE_NAME3 = TMP_K8S_NODE_NAME3;
    SEMRESATTRS_K8S_NODE_UID3 = TMP_K8S_NODE_UID3;
    SEMRESATTRS_K8S_NAMESPACE_NAME3 = TMP_K8S_NAMESPACE_NAME3;
    SEMRESATTRS_K8S_POD_UID3 = TMP_K8S_POD_UID3;
    SEMRESATTRS_K8S_POD_NAME3 = TMP_K8S_POD_NAME3;
    SEMRESATTRS_K8S_CONTAINER_NAME3 = TMP_K8S_CONTAINER_NAME3;
    SEMRESATTRS_K8S_REPLICASET_UID3 = TMP_K8S_REPLICASET_UID3;
    SEMRESATTRS_K8S_REPLICASET_NAME3 = TMP_K8S_REPLICASET_NAME3;
    SEMRESATTRS_K8S_DEPLOYMENT_UID3 = TMP_K8S_DEPLOYMENT_UID3;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME3 = TMP_K8S_DEPLOYMENT_NAME3;
    SEMRESATTRS_K8S_STATEFULSET_UID3 = TMP_K8S_STATEFULSET_UID3;
    SEMRESATTRS_K8S_STATEFULSET_NAME3 = TMP_K8S_STATEFULSET_NAME3;
    SEMRESATTRS_K8S_DAEMONSET_UID3 = TMP_K8S_DAEMONSET_UID3;
    SEMRESATTRS_K8S_DAEMONSET_NAME3 = TMP_K8S_DAEMONSET_NAME3;
    SEMRESATTRS_K8S_JOB_UID3 = TMP_K8S_JOB_UID3;
    SEMRESATTRS_K8S_JOB_NAME3 = TMP_K8S_JOB_NAME3;
    SEMRESATTRS_K8S_CRONJOB_UID3 = TMP_K8S_CRONJOB_UID3;
    SEMRESATTRS_K8S_CRONJOB_NAME3 = TMP_K8S_CRONJOB_NAME3;
    SEMRESATTRS_OS_TYPE3 = TMP_OS_TYPE3;
    SEMRESATTRS_OS_DESCRIPTION3 = TMP_OS_DESCRIPTION3;
    SEMRESATTRS_OS_NAME3 = TMP_OS_NAME3;
    SEMRESATTRS_OS_VERSION3 = TMP_OS_VERSION3;
    SEMRESATTRS_PROCESS_PID3 = TMP_PROCESS_PID3;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME3 = TMP_PROCESS_EXECUTABLE_NAME3;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH3 = TMP_PROCESS_EXECUTABLE_PATH3;
    SEMRESATTRS_PROCESS_COMMAND3 = TMP_PROCESS_COMMAND3;
    SEMRESATTRS_PROCESS_COMMAND_LINE3 = TMP_PROCESS_COMMAND_LINE3;
    SEMRESATTRS_PROCESS_COMMAND_ARGS3 = TMP_PROCESS_COMMAND_ARGS3;
    SEMRESATTRS_PROCESS_OWNER3 = TMP_PROCESS_OWNER3;
    SEMRESATTRS_PROCESS_RUNTIME_NAME3 = TMP_PROCESS_RUNTIME_NAME3;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION3 = TMP_PROCESS_RUNTIME_VERSION3;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION3 = TMP_PROCESS_RUNTIME_DESCRIPTION3;
    SEMRESATTRS_SERVICE_NAME3 = TMP_SERVICE_NAME3;
    SEMRESATTRS_SERVICE_NAMESPACE3 = TMP_SERVICE_NAMESPACE3;
    SEMRESATTRS_SERVICE_INSTANCE_ID3 = TMP_SERVICE_INSTANCE_ID3;
    SEMRESATTRS_SERVICE_VERSION3 = TMP_SERVICE_VERSION3;
    SEMRESATTRS_TELEMETRY_SDK_NAME3 = TMP_TELEMETRY_SDK_NAME3;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE3 = TMP_TELEMETRY_SDK_LANGUAGE3;
    SEMRESATTRS_TELEMETRY_SDK_VERSION3 = TMP_TELEMETRY_SDK_VERSION3;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION3 = TMP_TELEMETRY_AUTO_VERSION3;
    SEMRESATTRS_WEBENGINE_NAME3 = TMP_WEBENGINE_NAME3;
    SEMRESATTRS_WEBENGINE_VERSION3 = TMP_WEBENGINE_VERSION3;
    SEMRESATTRS_WEBENGINE_DESCRIPTION3 = TMP_WEBENGINE_DESCRIPTION3;
    SemanticResourceAttributes3 = /* @__PURE__ */ createConstMap3([
      TMP_CLOUD_PROVIDER3,
      TMP_CLOUD_ACCOUNT_ID3,
      TMP_CLOUD_REGION3,
      TMP_CLOUD_AVAILABILITY_ZONE3,
      TMP_CLOUD_PLATFORM3,
      TMP_AWS_ECS_CONTAINER_ARN3,
      TMP_AWS_ECS_CLUSTER_ARN3,
      TMP_AWS_ECS_LAUNCHTYPE3,
      TMP_AWS_ECS_TASK_ARN3,
      TMP_AWS_ECS_TASK_FAMILY3,
      TMP_AWS_ECS_TASK_REVISION3,
      TMP_AWS_EKS_CLUSTER_ARN3,
      TMP_AWS_LOG_GROUP_NAMES3,
      TMP_AWS_LOG_GROUP_ARNS3,
      TMP_AWS_LOG_STREAM_NAMES3,
      TMP_AWS_LOG_STREAM_ARNS3,
      TMP_CONTAINER_NAME3,
      TMP_CONTAINER_ID3,
      TMP_CONTAINER_RUNTIME3,
      TMP_CONTAINER_IMAGE_NAME3,
      TMP_CONTAINER_IMAGE_TAG3,
      TMP_DEPLOYMENT_ENVIRONMENT3,
      TMP_DEVICE_ID3,
      TMP_DEVICE_MODEL_IDENTIFIER3,
      TMP_DEVICE_MODEL_NAME3,
      TMP_FAAS_NAME3,
      TMP_FAAS_ID3,
      TMP_FAAS_VERSION3,
      TMP_FAAS_INSTANCE3,
      TMP_FAAS_MAX_MEMORY3,
      TMP_HOST_ID3,
      TMP_HOST_NAME3,
      TMP_HOST_TYPE3,
      TMP_HOST_ARCH3,
      TMP_HOST_IMAGE_NAME3,
      TMP_HOST_IMAGE_ID3,
      TMP_HOST_IMAGE_VERSION3,
      TMP_K8S_CLUSTER_NAME3,
      TMP_K8S_NODE_NAME3,
      TMP_K8S_NODE_UID3,
      TMP_K8S_NAMESPACE_NAME3,
      TMP_K8S_POD_UID3,
      TMP_K8S_POD_NAME3,
      TMP_K8S_CONTAINER_NAME3,
      TMP_K8S_REPLICASET_UID3,
      TMP_K8S_REPLICASET_NAME3,
      TMP_K8S_DEPLOYMENT_UID3,
      TMP_K8S_DEPLOYMENT_NAME3,
      TMP_K8S_STATEFULSET_UID3,
      TMP_K8S_STATEFULSET_NAME3,
      TMP_K8S_DAEMONSET_UID3,
      TMP_K8S_DAEMONSET_NAME3,
      TMP_K8S_JOB_UID3,
      TMP_K8S_JOB_NAME3,
      TMP_K8S_CRONJOB_UID3,
      TMP_K8S_CRONJOB_NAME3,
      TMP_OS_TYPE3,
      TMP_OS_DESCRIPTION3,
      TMP_OS_NAME3,
      TMP_OS_VERSION3,
      TMP_PROCESS_PID3,
      TMP_PROCESS_EXECUTABLE_NAME3,
      TMP_PROCESS_EXECUTABLE_PATH3,
      TMP_PROCESS_COMMAND3,
      TMP_PROCESS_COMMAND_LINE3,
      TMP_PROCESS_COMMAND_ARGS3,
      TMP_PROCESS_OWNER3,
      TMP_PROCESS_RUNTIME_NAME3,
      TMP_PROCESS_RUNTIME_VERSION3,
      TMP_PROCESS_RUNTIME_DESCRIPTION3,
      TMP_SERVICE_NAME3,
      TMP_SERVICE_NAMESPACE3,
      TMP_SERVICE_INSTANCE_ID3,
      TMP_SERVICE_VERSION3,
      TMP_TELEMETRY_SDK_NAME3,
      TMP_TELEMETRY_SDK_LANGUAGE3,
      TMP_TELEMETRY_SDK_VERSION3,
      TMP_TELEMETRY_AUTO_VERSION3,
      TMP_WEBENGINE_NAME3,
      TMP_WEBENGINE_VERSION3,
      TMP_WEBENGINE_DESCRIPTION3
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD3 = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS3 = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE3 = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP3 = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD3 = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD3;
    CLOUDPROVIDERVALUES_AWS3 = TMP_CLOUDPROVIDERVALUES_AWS3;
    CLOUDPROVIDERVALUES_AZURE3 = TMP_CLOUDPROVIDERVALUES_AZURE3;
    CLOUDPROVIDERVALUES_GCP3 = TMP_CLOUDPROVIDERVALUES_GCP3;
    CloudProviderValues3 = /* @__PURE__ */ createConstMap3([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD3,
      TMP_CLOUDPROVIDERVALUES_AWS3,
      TMP_CLOUDPROVIDERVALUES_AZURE3,
      TMP_CLOUDPROVIDERVALUES_GCP3
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3 = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3 = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC23 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS3 = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS3 = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA3 = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3 = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM3 = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3 = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS3 = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3 = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3 = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3 = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3 = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3 = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3 = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE3 = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3;
    CLOUDPLATFORMVALUES_AWS_EC23 = TMP_CLOUDPLATFORMVALUES_AWS_EC23;
    CLOUDPLATFORMVALUES_AWS_ECS3 = TMP_CLOUDPLATFORMVALUES_AWS_ECS3;
    CLOUDPLATFORMVALUES_AWS_EKS3 = TMP_CLOUDPLATFORMVALUES_AWS_EKS3;
    CLOUDPLATFORMVALUES_AWS_LAMBDA3 = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA3;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3 = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3;
    CLOUDPLATFORMVALUES_AZURE_VM3 = TMP_CLOUDPLATFORMVALUES_AZURE_VM3;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3 = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3;
    CLOUDPLATFORMVALUES_AZURE_AKS3 = TMP_CLOUDPLATFORMVALUES_AZURE_AKS3;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3 = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3 = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3 = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3 = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE3 = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE3;
    CloudPlatformValues3 = /* @__PURE__ */ createConstMap3([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3,
      TMP_CLOUDPLATFORMVALUES_AWS_EC23,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS3,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS3,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA3,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM3,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS3,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE3
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC23 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE3 = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC23 = TMP_AWSECSLAUNCHTYPEVALUES_EC23;
    AWSECSLAUNCHTYPEVALUES_FARGATE3 = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE3;
    AwsEcsLaunchtypeValues3 = /* @__PURE__ */ createConstMap3([
      TMP_AWSECSLAUNCHTYPEVALUES_EC23,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE3
    ]);
    TMP_HOSTARCHVALUES_AMD643 = "amd64";
    TMP_HOSTARCHVALUES_ARM323 = "arm32";
    TMP_HOSTARCHVALUES_ARM643 = "arm64";
    TMP_HOSTARCHVALUES_IA643 = "ia64";
    TMP_HOSTARCHVALUES_PPC323 = "ppc32";
    TMP_HOSTARCHVALUES_PPC643 = "ppc64";
    TMP_HOSTARCHVALUES_X863 = "x86";
    HOSTARCHVALUES_AMD643 = TMP_HOSTARCHVALUES_AMD643;
    HOSTARCHVALUES_ARM323 = TMP_HOSTARCHVALUES_ARM323;
    HOSTARCHVALUES_ARM643 = TMP_HOSTARCHVALUES_ARM643;
    HOSTARCHVALUES_IA643 = TMP_HOSTARCHVALUES_IA643;
    HOSTARCHVALUES_PPC323 = TMP_HOSTARCHVALUES_PPC323;
    HOSTARCHVALUES_PPC643 = TMP_HOSTARCHVALUES_PPC643;
    HOSTARCHVALUES_X863 = TMP_HOSTARCHVALUES_X863;
    HostArchValues3 = /* @__PURE__ */ createConstMap3([
      TMP_HOSTARCHVALUES_AMD643,
      TMP_HOSTARCHVALUES_ARM323,
      TMP_HOSTARCHVALUES_ARM643,
      TMP_HOSTARCHVALUES_IA643,
      TMP_HOSTARCHVALUES_PPC323,
      TMP_HOSTARCHVALUES_PPC643,
      TMP_HOSTARCHVALUES_X863
    ]);
    TMP_OSTYPEVALUES_WINDOWS3 = "windows";
    TMP_OSTYPEVALUES_LINUX3 = "linux";
    TMP_OSTYPEVALUES_DARWIN3 = "darwin";
    TMP_OSTYPEVALUES_FREEBSD3 = "freebsd";
    TMP_OSTYPEVALUES_NETBSD3 = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD3 = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD3 = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX3 = "hpux";
    TMP_OSTYPEVALUES_AIX3 = "aix";
    TMP_OSTYPEVALUES_SOLARIS3 = "solaris";
    TMP_OSTYPEVALUES_Z_OS3 = "z_os";
    OSTYPEVALUES_WINDOWS3 = TMP_OSTYPEVALUES_WINDOWS3;
    OSTYPEVALUES_LINUX3 = TMP_OSTYPEVALUES_LINUX3;
    OSTYPEVALUES_DARWIN3 = TMP_OSTYPEVALUES_DARWIN3;
    OSTYPEVALUES_FREEBSD3 = TMP_OSTYPEVALUES_FREEBSD3;
    OSTYPEVALUES_NETBSD3 = TMP_OSTYPEVALUES_NETBSD3;
    OSTYPEVALUES_OPENBSD3 = TMP_OSTYPEVALUES_OPENBSD3;
    OSTYPEVALUES_DRAGONFLYBSD3 = TMP_OSTYPEVALUES_DRAGONFLYBSD3;
    OSTYPEVALUES_HPUX3 = TMP_OSTYPEVALUES_HPUX3;
    OSTYPEVALUES_AIX3 = TMP_OSTYPEVALUES_AIX3;
    OSTYPEVALUES_SOLARIS3 = TMP_OSTYPEVALUES_SOLARIS3;
    OSTYPEVALUES_Z_OS3 = TMP_OSTYPEVALUES_Z_OS3;
    OsTypeValues3 = /* @__PURE__ */ createConstMap3([
      TMP_OSTYPEVALUES_WINDOWS3,
      TMP_OSTYPEVALUES_LINUX3,
      TMP_OSTYPEVALUES_DARWIN3,
      TMP_OSTYPEVALUES_FREEBSD3,
      TMP_OSTYPEVALUES_NETBSD3,
      TMP_OSTYPEVALUES_OPENBSD3,
      TMP_OSTYPEVALUES_DRAGONFLYBSD3,
      TMP_OSTYPEVALUES_HPUX3,
      TMP_OSTYPEVALUES_AIX3,
      TMP_OSTYPEVALUES_SOLARIS3,
      TMP_OSTYPEVALUES_Z_OS3
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP3 = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET3 = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG3 = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO3 = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA3 = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS3 = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP3 = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON3 = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY3 = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS3 = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP3 = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP3;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET3 = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET3;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG3 = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG3;
    TELEMETRYSDKLANGUAGEVALUES_GO3 = TMP_TELEMETRYSDKLANGUAGEVALUES_GO3;
    TELEMETRYSDKLANGUAGEVALUES_JAVA3 = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA3;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS3 = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS3;
    TELEMETRYSDKLANGUAGEVALUES_PHP3 = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP3;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON3 = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON3;
    TELEMETRYSDKLANGUAGEVALUES_RUBY3 = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY3;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS3 = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS3;
    TelemetrySdkLanguageValues3 = /* @__PURE__ */ createConstMap3([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY3,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS3
    ]);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource3 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes3();
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT3, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED3, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED3, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED3, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED3, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE3, ATTR_ASPNETCORE_RATE_LIMITING_POLICY3, ATTR_ASPNETCORE_RATE_LIMITING_RESULT3, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED3, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER3, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER3, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED3, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED3, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK3, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS3, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE3, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS3, ATTR_CLIENT_ADDRESS3, ATTR_CLIENT_PORT3, ATTR_DOTNET_GC_HEAP_GENERATION, DOTNET_GC_HEAP_GENERATION_VALUE_GEN0, DOTNET_GC_HEAP_GENERATION_VALUE_GEN1, DOTNET_GC_HEAP_GENERATION_VALUE_GEN2, DOTNET_GC_HEAP_GENERATION_VALUE_LOH, DOTNET_GC_HEAP_GENERATION_VALUE_POH, ATTR_ERROR_TYPE3, ERROR_TYPE_VALUE_OTHER3, ATTR_EXCEPTION_ESCAPED3, ATTR_EXCEPTION_MESSAGE3, ATTR_EXCEPTION_STACKTRACE3, ATTR_EXCEPTION_TYPE3, ATTR_HTTP_REQUEST_HEADER3, ATTR_HTTP_REQUEST_METHOD3, HTTP_REQUEST_METHOD_VALUE_OTHER3, HTTP_REQUEST_METHOD_VALUE_CONNECT3, HTTP_REQUEST_METHOD_VALUE_DELETE3, HTTP_REQUEST_METHOD_VALUE_GET3, HTTP_REQUEST_METHOD_VALUE_HEAD3, HTTP_REQUEST_METHOD_VALUE_OPTIONS3, HTTP_REQUEST_METHOD_VALUE_PATCH3, HTTP_REQUEST_METHOD_VALUE_POST3, HTTP_REQUEST_METHOD_VALUE_PUT3, HTTP_REQUEST_METHOD_VALUE_TRACE3, ATTR_HTTP_REQUEST_METHOD_ORIGINAL3, ATTR_HTTP_REQUEST_RESEND_COUNT3, ATTR_HTTP_RESPONSE_HEADER3, ATTR_HTTP_RESPONSE_STATUS_CODE3, ATTR_HTTP_ROUTE3, ATTR_JVM_GC_ACTION3, ATTR_JVM_GC_NAME3, ATTR_JVM_MEMORY_POOL_NAME3, ATTR_JVM_MEMORY_TYPE3, JVM_MEMORY_TYPE_VALUE_HEAP3, JVM_MEMORY_TYPE_VALUE_NON_HEAP3, ATTR_JVM_THREAD_DAEMON3, ATTR_JVM_THREAD_STATE3, JVM_THREAD_STATE_VALUE_BLOCKED3, JVM_THREAD_STATE_VALUE_NEW3, JVM_THREAD_STATE_VALUE_RUNNABLE3, JVM_THREAD_STATE_VALUE_TERMINATED3, JVM_THREAD_STATE_VALUE_TIMED_WAITING3, JVM_THREAD_STATE_VALUE_WAITING3, ATTR_NETWORK_LOCAL_ADDRESS3, ATTR_NETWORK_LOCAL_PORT3, ATTR_NETWORK_PEER_ADDRESS3, ATTR_NETWORK_PEER_PORT3, ATTR_NETWORK_PROTOCOL_NAME3, ATTR_NETWORK_PROTOCOL_VERSION3, ATTR_NETWORK_TRANSPORT3, NETWORK_TRANSPORT_VALUE_PIPE3, NETWORK_TRANSPORT_VALUE_QUIC3, NETWORK_TRANSPORT_VALUE_TCP3, NETWORK_TRANSPORT_VALUE_UDP3, NETWORK_TRANSPORT_VALUE_UNIX3, ATTR_NETWORK_TYPE3, NETWORK_TYPE_VALUE_IPV43, NETWORK_TYPE_VALUE_IPV63, ATTR_OTEL_SCOPE_NAME3, ATTR_OTEL_SCOPE_VERSION3, ATTR_OTEL_STATUS_CODE3, OTEL_STATUS_CODE_VALUE_ERROR3, OTEL_STATUS_CODE_VALUE_OK3, ATTR_OTEL_STATUS_DESCRIPTION3, ATTR_SERVER_ADDRESS3, ATTR_SERVER_PORT3, ATTR_SERVICE_NAME3, ATTR_SERVICE_VERSION3, ATTR_SIGNALR_CONNECTION_STATUS3, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN3, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE3, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT3, ATTR_SIGNALR_TRANSPORT3, SIGNALR_TRANSPORT_VALUE_LONG_POLLING3, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS3, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS3, ATTR_TELEMETRY_SDK_LANGUAGE3, TELEMETRY_SDK_LANGUAGE_VALUE_CPP3, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET3, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG3, TELEMETRY_SDK_LANGUAGE_VALUE_GO3, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA3, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS3, TELEMETRY_SDK_LANGUAGE_VALUE_PHP3, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON3, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY3, TELEMETRY_SDK_LANGUAGE_VALUE_RUST3, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT3, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS3, ATTR_TELEMETRY_SDK_NAME3, ATTR_TELEMETRY_SDK_VERSION3, ATTR_URL_FRAGMENT3, ATTR_URL_FULL3, ATTR_URL_PATH3, ATTR_URL_QUERY3, ATTR_URL_SCHEME3, ATTR_USER_AGENT_ORIGINAL3;
var init_stable_attributes3 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT3 = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED3 = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED3 = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED3 = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED3 = "unhandled";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE3 = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY3 = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT3 = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED3 = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER3 = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER3 = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED3 = "request_canceled";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED3 = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK3 = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS3 = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE3 = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS3 = "success";
    ATTR_CLIENT_ADDRESS3 = "client.address";
    ATTR_CLIENT_PORT3 = "client.port";
    ATTR_DOTNET_GC_HEAP_GENERATION = "dotnet.gc.heap.generation";
    DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = "gen0";
    DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = "gen1";
    DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = "gen2";
    DOTNET_GC_HEAP_GENERATION_VALUE_LOH = "loh";
    DOTNET_GC_HEAP_GENERATION_VALUE_POH = "poh";
    ATTR_ERROR_TYPE3 = "error.type";
    ERROR_TYPE_VALUE_OTHER3 = "_OTHER";
    ATTR_EXCEPTION_ESCAPED3 = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE3 = "exception.message";
    ATTR_EXCEPTION_STACKTRACE3 = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE3 = "exception.type";
    ATTR_HTTP_REQUEST_HEADER3 = (key) => `http.request.header.${key}`;
    ATTR_HTTP_REQUEST_METHOD3 = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER3 = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT3 = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE3 = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET3 = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD3 = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS3 = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH3 = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST3 = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT3 = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE3 = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL3 = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT3 = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER3 = (key) => `http.response.header.${key}`;
    ATTR_HTTP_RESPONSE_STATUS_CODE3 = "http.response.status_code";
    ATTR_HTTP_ROUTE3 = "http.route";
    ATTR_JVM_GC_ACTION3 = "jvm.gc.action";
    ATTR_JVM_GC_NAME3 = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME3 = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE3 = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP3 = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP3 = "non_heap";
    ATTR_JVM_THREAD_DAEMON3 = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE3 = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED3 = "blocked";
    JVM_THREAD_STATE_VALUE_NEW3 = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE3 = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED3 = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING3 = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING3 = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS3 = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT3 = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS3 = "network.peer.address";
    ATTR_NETWORK_PEER_PORT3 = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME3 = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION3 = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT3 = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE3 = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC3 = "quic";
    NETWORK_TRANSPORT_VALUE_TCP3 = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP3 = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX3 = "unix";
    ATTR_NETWORK_TYPE3 = "network.type";
    NETWORK_TYPE_VALUE_IPV43 = "ipv4";
    NETWORK_TYPE_VALUE_IPV63 = "ipv6";
    ATTR_OTEL_SCOPE_NAME3 = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION3 = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE3 = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR3 = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK3 = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION3 = "otel.status_description";
    ATTR_SERVER_ADDRESS3 = "server.address";
    ATTR_SERVER_PORT3 = "server.port";
    ATTR_SERVICE_NAME3 = "service.name";
    ATTR_SERVICE_VERSION3 = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS3 = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN3 = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE3 = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT3 = "timeout";
    ATTR_SIGNALR_TRANSPORT3 = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING3 = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS3 = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS3 = "web_sockets";
    ATTR_TELEMETRY_SDK_LANGUAGE3 = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP3 = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET3 = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG3 = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO3 = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA3 = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS3 = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP3 = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON3 = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY3 = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST3 = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT3 = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS3 = "webjs";
    ATTR_TELEMETRY_SDK_NAME3 = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION3 = "telemetry.sdk.version";
    ATTR_URL_FRAGMENT3 = "url.fragment";
    ATTR_URL_FULL3 = "url.full";
    ATTR_URL_PATH3 = "url.path";
    ATTR_URL_QUERY3 = "url.query";
    ATTR_URL_SCHEME3 = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL3 = "user_agent.original";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS3, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES3, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS3, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE3, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION3, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS3, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS3, METRIC_DOTNET_ASSEMBLY_COUNT, METRIC_DOTNET_EXCEPTIONS, METRIC_DOTNET_GC_COLLECTIONS, METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED, METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE, METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE, METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE, METRIC_DOTNET_GC_PAUSE_TIME, METRIC_DOTNET_JIT_COMPILATION_TIME, METRIC_DOTNET_JIT_COMPILED_IL_SIZE, METRIC_DOTNET_JIT_COMPILED_METHODS, METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS, METRIC_DOTNET_PROCESS_CPU_COUNT, METRIC_DOTNET_PROCESS_CPU_TIME, METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET, METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH, METRIC_DOTNET_THREAD_POOL_THREAD_COUNT, METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT, METRIC_DOTNET_TIMER_COUNT, METRIC_HTTP_CLIENT_REQUEST_DURATION3, METRIC_HTTP_SERVER_REQUEST_DURATION3, METRIC_JVM_CLASS_COUNT3, METRIC_JVM_CLASS_LOADED3, METRIC_JVM_CLASS_UNLOADED3, METRIC_JVM_CPU_COUNT3, METRIC_JVM_CPU_RECENT_UTILIZATION3, METRIC_JVM_CPU_TIME3, METRIC_JVM_GC_DURATION3, METRIC_JVM_MEMORY_COMMITTED3, METRIC_JVM_MEMORY_LIMIT3, METRIC_JVM_MEMORY_USED3, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC3, METRIC_JVM_THREAD_COUNT3, METRIC_KESTREL_ACTIVE_CONNECTIONS3, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES3, METRIC_KESTREL_CONNECTION_DURATION3, METRIC_KESTREL_QUEUED_CONNECTIONS3, METRIC_KESTREL_QUEUED_REQUESTS3, METRIC_KESTREL_REJECTED_CONNECTIONS3, METRIC_KESTREL_TLS_HANDSHAKE_DURATION3, METRIC_KESTREL_UPGRADED_CONNECTIONS3, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS3, METRIC_SIGNALR_SERVER_CONNECTION_DURATION3;
var init_stable_metrics3 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS3 = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES3 = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS3 = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE3 = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION3 = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS3 = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS3 = "aspnetcore.routing.match_attempts";
    METRIC_DOTNET_ASSEMBLY_COUNT = "dotnet.assembly.count";
    METRIC_DOTNET_EXCEPTIONS = "dotnet.exceptions";
    METRIC_DOTNET_GC_COLLECTIONS = "dotnet.gc.collections";
    METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = "dotnet.gc.heap.total_allocated";
    METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = "dotnet.gc.last_collection.heap.fragmentation.size";
    METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = "dotnet.gc.last_collection.heap.size";
    METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = "dotnet.gc.last_collection.memory.committed_size";
    METRIC_DOTNET_GC_PAUSE_TIME = "dotnet.gc.pause.time";
    METRIC_DOTNET_JIT_COMPILATION_TIME = "dotnet.jit.compilation.time";
    METRIC_DOTNET_JIT_COMPILED_IL_SIZE = "dotnet.jit.compiled_il.size";
    METRIC_DOTNET_JIT_COMPILED_METHODS = "dotnet.jit.compiled_methods";
    METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = "dotnet.monitor.lock_contentions";
    METRIC_DOTNET_PROCESS_CPU_COUNT = "dotnet.process.cpu.count";
    METRIC_DOTNET_PROCESS_CPU_TIME = "dotnet.process.cpu.time";
    METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = "dotnet.process.memory.working_set";
    METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = "dotnet.thread_pool.queue.length";
    METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = "dotnet.thread_pool.thread.count";
    METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = "dotnet.thread_pool.work_item.count";
    METRIC_DOTNET_TIMER_COUNT = "dotnet.timer.count";
    METRIC_HTTP_CLIENT_REQUEST_DURATION3 = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION3 = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT3 = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED3 = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED3 = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT3 = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION3 = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME3 = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION3 = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED3 = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT3 = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED3 = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC3 = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT3 = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS3 = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES3 = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION3 = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS3 = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS3 = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS3 = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION3 = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS3 = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS3 = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION3 = "signalr.server.connection.duration";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED3,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED3,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED3,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED3,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED3,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER3,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER3,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED3,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE3,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS3,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT3,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE3,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY3,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT3,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED3,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK3,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS3,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS3,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT3,
  ATTR_DOTNET_GC_HEAP_GENERATION: () => ATTR_DOTNET_GC_HEAP_GENERATION,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE3,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED3,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE3,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE3,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE3,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER3,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD3,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL3,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT3,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER3,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE3,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE3,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION3,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME3,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME3,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE3,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON3,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE3,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS3,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT3,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS3,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT3,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME3,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION3,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT3,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE3,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME3,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION3,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE3,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION3,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS3,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT3,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME3,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION3,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS3,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT3,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE3,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME3,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION3,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT3,
  ATTR_URL_FULL: () => ATTR_URL_FULL3,
  ATTR_URL_PATH: () => ATTR_URL_PATH3,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY3,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME3,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL3,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC23,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE3,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues3,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS3,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC3,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC23,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS3,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS3,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK3,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA3,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS3,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE3,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES3,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS3,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM3,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE3,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS3,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN3,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE3,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE3,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD3,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS3,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE3,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP3,
  CloudPlatformValues: () => CloudPlatformValues3,
  CloudProviderValues: () => CloudProviderValues3,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL3,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY3,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM3,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE3,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM3,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL3,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE3,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM3,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL3,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE3,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO3,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS3,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE3,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA3,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE3,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB3,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION3,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB3,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE3,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB3,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB23,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY3,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB3,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB3,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH3,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER3,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD3,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL3,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE3,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H23,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB3,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE3,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE3,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB3,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX3,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES3,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB3,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE3,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB3,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB3,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED3,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB3,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL3,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL3,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J3,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA3,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE3,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL3,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE3,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE3,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL3,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS3,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS3,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT3,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE3,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE3,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA3,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA3,
  DOTNET_GC_HEAP_GENERATION_VALUE_GEN0: () => DOTNET_GC_HEAP_GENERATION_VALUE_GEN0,
  DOTNET_GC_HEAP_GENERATION_VALUE_GEN1: () => DOTNET_GC_HEAP_GENERATION_VALUE_GEN1,
  DOTNET_GC_HEAP_GENERATION_VALUE_GEN2: () => DOTNET_GC_HEAP_GENERATION_VALUE_GEN2,
  DOTNET_GC_HEAP_GENERATION_VALUE_LOH: () => DOTNET_GC_HEAP_GENERATION_VALUE_LOH,
  DOTNET_GC_HEAP_GENERATION_VALUE_POH: () => DOTNET_GC_HEAP_GENERATION_VALUE_POH,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues3,
  DbSystemValues: () => DbSystemValues3,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER3,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE3,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT3,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT3,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD3,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS3,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE3,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP3,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE3,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP3,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER3,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB3,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER3,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues3,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues3,
  FaasTriggerValues: () => FaasTriggerValues3,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD643,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM323,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM643,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA643,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC323,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC643,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X863,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_03,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_13,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_03,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC3,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY3,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT3,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE3,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET3,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD3,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS3,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER3,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH3,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST3,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT3,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE3,
  HostArchValues: () => HostArchValues3,
  HttpFlavorValues: () => HttpFlavorValues3,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP3,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP3,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED3,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW3,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE3,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED3,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING3,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING3,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED3,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT3,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE3,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC3,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS3,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE3,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS3,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES3,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS3,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS3,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION3,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE3,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS3,
  METRIC_DOTNET_ASSEMBLY_COUNT: () => METRIC_DOTNET_ASSEMBLY_COUNT,
  METRIC_DOTNET_EXCEPTIONS: () => METRIC_DOTNET_EXCEPTIONS,
  METRIC_DOTNET_GC_COLLECTIONS: () => METRIC_DOTNET_GC_COLLECTIONS,
  METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED: () => METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED,
  METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE: () => METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE,
  METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE: () => METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE,
  METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE: () => METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE,
  METRIC_DOTNET_GC_PAUSE_TIME: () => METRIC_DOTNET_GC_PAUSE_TIME,
  METRIC_DOTNET_JIT_COMPILATION_TIME: () => METRIC_DOTNET_JIT_COMPILATION_TIME,
  METRIC_DOTNET_JIT_COMPILED_IL_SIZE: () => METRIC_DOTNET_JIT_COMPILED_IL_SIZE,
  METRIC_DOTNET_JIT_COMPILED_METHODS: () => METRIC_DOTNET_JIT_COMPILED_METHODS,
  METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS: () => METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS,
  METRIC_DOTNET_PROCESS_CPU_COUNT: () => METRIC_DOTNET_PROCESS_CPU_COUNT,
  METRIC_DOTNET_PROCESS_CPU_TIME: () => METRIC_DOTNET_PROCESS_CPU_TIME,
  METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET: () => METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET,
  METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH: () => METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH,
  METRIC_DOTNET_THREAD_POOL_THREAD_COUNT: () => METRIC_DOTNET_THREAD_POOL_THREAD_COUNT,
  METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT: () => METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT,
  METRIC_DOTNET_TIMER_COUNT: () => METRIC_DOTNET_TIMER_COUNT,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION3,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION3,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT3,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED3,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED3,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT3,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION3,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME3,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION3,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED3,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT3,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED3,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC3,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT3,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS3,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES3,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION3,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS3,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS3,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS3,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION3,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS3,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS3,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION3,
  MessageTypeValues: () => MessageTypeValues3,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues3,
  MessagingOperationValues: () => MessagingOperationValues3,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT3,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE3,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD3,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_03,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A3,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B3,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS3,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM3,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP3,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN3,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN3,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE3,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR3,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA3,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS3,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL3,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE3,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN3,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI3,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED3,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC3,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP3,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP3,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP3,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER3,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE3,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX3,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE3,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC3,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP3,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP3,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX3,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV43,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV63,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues3,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues3,
  NetTransportValues: () => NetTransportValues3,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX3,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN3,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD3,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD3,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX3,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX3,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD3,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD3,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS3,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS3,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS3,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR3,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK3,
  OsTypeValues: () => OsTypeValues3,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED3,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS3,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED3,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS3,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED3,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION3,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL3,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT3,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND3,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK3,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE3,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED3,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED3,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED3,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE3,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED3,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN3,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues3,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET3,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS3,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ3,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY3,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT3,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE3,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES3,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES3,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME3,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS3,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT3,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES3,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION3,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY3,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY3,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT3,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD3,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT3,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT3,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT3,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES3,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS3,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN3,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH3,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION3,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO3,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE3,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL3,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC3,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID3,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE3,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE3,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE3,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT3,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE3,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING3,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE3,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME3,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION3,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME3,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME3,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION3,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX3,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE3,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT3,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM3,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER3,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID3,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE3,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE3,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED3,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE3,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE3,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE3,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART3,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON3,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION3,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME3,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION3,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME3,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION3,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME3,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER3,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION3,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME3,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER3,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP3,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR3,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST3,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD3,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH3,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED3,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH3,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED3,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE3,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME3,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME3,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE3,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET3,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL3,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT3,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE3,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID3,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE3,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE3,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID3,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID3,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION3,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND3,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID3,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP3,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY3,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION3,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE3,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID3,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES3,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES3,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION3,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL3,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION3,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY3,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM3,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION3,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL3,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC3,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC3,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC3,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME3,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE3,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE3,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP3,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME3,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT3,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP3,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME3,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT3,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT3,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE3,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE3,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE3,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE3,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID3,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION3,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD3,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE3,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM3,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID3,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME3,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN3,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN3,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE3,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN3,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY3,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION3,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN3,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS3,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES3,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS3,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES3,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID3,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE3,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM3,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER3,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION3,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID3,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME3,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG3,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME3,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME3,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT3,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID3,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER3,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME3,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID3,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE3,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY3,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME3,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION3,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH3,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID3,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID3,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME3,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION3,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME3,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE3,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME3,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME3,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME3,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID3,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME3,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID3,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME3,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID3,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME3,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID3,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME3,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME3,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID3,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME3,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID3,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME3,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID3,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME3,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID3,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION3,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME3,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE3,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION3,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND3,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS3,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE3,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME3,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH3,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER3,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID3,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION3,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME3,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION3,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID3,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME3,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE3,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION3,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION3,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE3,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME3,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION3,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION3,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME3,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION3,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN3,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE3,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT3,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING3,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS3,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS3,
  SemanticAttributes: () => SemanticAttributes3,
  SemanticResourceAttributes: () => SemanticResourceAttributes3,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP3,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET3,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG3,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO3,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA3,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS3,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP3,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON3,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY3,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS3,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP3,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET3,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG3,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO3,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA3,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS3,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP3,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON3,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY3,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST3,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT3,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS3,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues3
});
var init_esm4 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace4();
    init_resource3();
    init_stable_attributes3();
    init_stable_metrics3();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap4(values) {
  var res = {};
  var len = values.length;
  for (var lp = 0; lp < len; lp++) {
    var val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils6 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN4, TMP_DB_SYSTEM4, TMP_DB_CONNECTION_STRING4, TMP_DB_USER4, TMP_DB_JDBC_DRIVER_CLASSNAME4, TMP_DB_NAME4, TMP_DB_STATEMENT4, TMP_DB_OPERATION4, TMP_DB_MSSQL_INSTANCE_NAME4, TMP_DB_CASSANDRA_KEYSPACE4, TMP_DB_CASSANDRA_PAGE_SIZE4, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL4, TMP_DB_CASSANDRA_TABLE4, TMP_DB_CASSANDRA_IDEMPOTENCE4, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4, TMP_DB_CASSANDRA_COORDINATOR_ID4, TMP_DB_CASSANDRA_COORDINATOR_DC4, TMP_DB_HBASE_NAMESPACE4, TMP_DB_REDIS_DATABASE_INDEX4, TMP_DB_MONGODB_COLLECTION4, TMP_DB_SQL_TABLE4, TMP_EXCEPTION_TYPE4, TMP_EXCEPTION_MESSAGE4, TMP_EXCEPTION_STACKTRACE4, TMP_EXCEPTION_ESCAPED4, TMP_FAAS_TRIGGER4, TMP_FAAS_EXECUTION4, TMP_FAAS_DOCUMENT_COLLECTION4, TMP_FAAS_DOCUMENT_OPERATION4, TMP_FAAS_DOCUMENT_TIME4, TMP_FAAS_DOCUMENT_NAME4, TMP_FAAS_TIME4, TMP_FAAS_CRON4, TMP_FAAS_COLDSTART4, TMP_FAAS_INVOKED_NAME4, TMP_FAAS_INVOKED_PROVIDER4, TMP_FAAS_INVOKED_REGION4, TMP_NET_TRANSPORT4, TMP_NET_PEER_IP4, TMP_NET_PEER_PORT4, TMP_NET_PEER_NAME4, TMP_NET_HOST_IP4, TMP_NET_HOST_PORT4, TMP_NET_HOST_NAME4, TMP_NET_HOST_CONNECTION_TYPE4, TMP_NET_HOST_CONNECTION_SUBTYPE4, TMP_NET_HOST_CARRIER_NAME4, TMP_NET_HOST_CARRIER_MCC4, TMP_NET_HOST_CARRIER_MNC4, TMP_NET_HOST_CARRIER_ICC4, TMP_PEER_SERVICE4, TMP_ENDUSER_ID4, TMP_ENDUSER_ROLE4, TMP_ENDUSER_SCOPE4, TMP_THREAD_ID4, TMP_THREAD_NAME4, TMP_CODE_FUNCTION4, TMP_CODE_NAMESPACE4, TMP_CODE_FILEPATH4, TMP_CODE_LINENO4, TMP_HTTP_METHOD4, TMP_HTTP_URL4, TMP_HTTP_TARGET4, TMP_HTTP_HOST4, TMP_HTTP_SCHEME4, TMP_HTTP_STATUS_CODE4, TMP_HTTP_FLAVOR4, TMP_HTTP_USER_AGENT4, TMP_HTTP_REQUEST_CONTENT_LENGTH4, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4, TMP_HTTP_RESPONSE_CONTENT_LENGTH4, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4, TMP_HTTP_SERVER_NAME4, TMP_HTTP_ROUTE4, TMP_HTTP_CLIENT_IP4, TMP_AWS_DYNAMODB_TABLE_NAMES4, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY4, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4, TMP_AWS_DYNAMODB_CONSISTENT_READ4, TMP_AWS_DYNAMODB_PROJECTION4, TMP_AWS_DYNAMODB_LIMIT4, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET4, TMP_AWS_DYNAMODB_INDEX_NAME4, TMP_AWS_DYNAMODB_SELECT4, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4, TMP_AWS_DYNAMODB_TABLE_COUNT4, TMP_AWS_DYNAMODB_SCAN_FORWARD4, TMP_AWS_DYNAMODB_SEGMENT4, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS4, TMP_AWS_DYNAMODB_COUNT4, TMP_AWS_DYNAMODB_SCANNED_COUNT4, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4, TMP_MESSAGING_SYSTEM4, TMP_MESSAGING_DESTINATION4, TMP_MESSAGING_DESTINATION_KIND4, TMP_MESSAGING_TEMP_DESTINATION4, TMP_MESSAGING_PROTOCOL4, TMP_MESSAGING_PROTOCOL_VERSION4, TMP_MESSAGING_URL4, TMP_MESSAGING_MESSAGE_ID4, TMP_MESSAGING_CONVERSATION_ID4, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4, TMP_MESSAGING_OPERATION4, TMP_MESSAGING_CONSUMER_ID4, TMP_MESSAGING_RABBITMQ_ROUTING_KEY4, TMP_MESSAGING_KAFKA_MESSAGE_KEY4, TMP_MESSAGING_KAFKA_CONSUMER_GROUP4, TMP_MESSAGING_KAFKA_CLIENT_ID4, TMP_MESSAGING_KAFKA_PARTITION4, TMP_MESSAGING_KAFKA_TOMBSTONE4, TMP_RPC_SYSTEM4, TMP_RPC_SERVICE4, TMP_RPC_METHOD4, TMP_RPC_GRPC_STATUS_CODE4, TMP_RPC_JSONRPC_VERSION4, TMP_RPC_JSONRPC_REQUEST_ID4, TMP_RPC_JSONRPC_ERROR_CODE4, TMP_RPC_JSONRPC_ERROR_MESSAGE4, TMP_MESSAGE_TYPE4, TMP_MESSAGE_ID4, TMP_MESSAGE_COMPRESSED_SIZE4, TMP_MESSAGE_UNCOMPRESSED_SIZE4, SEMATTRS_AWS_LAMBDA_INVOKED_ARN4, SEMATTRS_DB_SYSTEM4, SEMATTRS_DB_CONNECTION_STRING4, SEMATTRS_DB_USER4, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME4, SEMATTRS_DB_NAME4, SEMATTRS_DB_STATEMENT4, SEMATTRS_DB_OPERATION4, SEMATTRS_DB_MSSQL_INSTANCE_NAME4, SEMATTRS_DB_CASSANDRA_KEYSPACE4, SEMATTRS_DB_CASSANDRA_PAGE_SIZE4, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL4, SEMATTRS_DB_CASSANDRA_TABLE4, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE4, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID4, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC4, SEMATTRS_DB_HBASE_NAMESPACE4, SEMATTRS_DB_REDIS_DATABASE_INDEX4, SEMATTRS_DB_MONGODB_COLLECTION4, SEMATTRS_DB_SQL_TABLE4, SEMATTRS_EXCEPTION_TYPE4, SEMATTRS_EXCEPTION_MESSAGE4, SEMATTRS_EXCEPTION_STACKTRACE4, SEMATTRS_EXCEPTION_ESCAPED4, SEMATTRS_FAAS_TRIGGER4, SEMATTRS_FAAS_EXECUTION4, SEMATTRS_FAAS_DOCUMENT_COLLECTION4, SEMATTRS_FAAS_DOCUMENT_OPERATION4, SEMATTRS_FAAS_DOCUMENT_TIME4, SEMATTRS_FAAS_DOCUMENT_NAME4, SEMATTRS_FAAS_TIME4, SEMATTRS_FAAS_CRON4, SEMATTRS_FAAS_COLDSTART4, SEMATTRS_FAAS_INVOKED_NAME4, SEMATTRS_FAAS_INVOKED_PROVIDER4, SEMATTRS_FAAS_INVOKED_REGION4, SEMATTRS_NET_TRANSPORT4, SEMATTRS_NET_PEER_IP4, SEMATTRS_NET_PEER_PORT4, SEMATTRS_NET_PEER_NAME4, SEMATTRS_NET_HOST_IP4, SEMATTRS_NET_HOST_PORT4, SEMATTRS_NET_HOST_NAME4, SEMATTRS_NET_HOST_CONNECTION_TYPE4, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE4, SEMATTRS_NET_HOST_CARRIER_NAME4, SEMATTRS_NET_HOST_CARRIER_MCC4, SEMATTRS_NET_HOST_CARRIER_MNC4, SEMATTRS_NET_HOST_CARRIER_ICC4, SEMATTRS_PEER_SERVICE4, SEMATTRS_ENDUSER_ID4, SEMATTRS_ENDUSER_ROLE4, SEMATTRS_ENDUSER_SCOPE4, SEMATTRS_THREAD_ID4, SEMATTRS_THREAD_NAME4, SEMATTRS_CODE_FUNCTION4, SEMATTRS_CODE_NAMESPACE4, SEMATTRS_CODE_FILEPATH4, SEMATTRS_CODE_LINENO4, SEMATTRS_HTTP_METHOD4, SEMATTRS_HTTP_URL4, SEMATTRS_HTTP_TARGET4, SEMATTRS_HTTP_HOST4, SEMATTRS_HTTP_SCHEME4, SEMATTRS_HTTP_STATUS_CODE4, SEMATTRS_HTTP_FLAVOR4, SEMATTRS_HTTP_USER_AGENT4, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH4, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH4, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4, SEMATTRS_HTTP_SERVER_NAME4, SEMATTRS_HTTP_ROUTE4, SEMATTRS_HTTP_CLIENT_IP4, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES4, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY4, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ4, SEMATTRS_AWS_DYNAMODB_PROJECTION4, SEMATTRS_AWS_DYNAMODB_LIMIT4, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET4, SEMATTRS_AWS_DYNAMODB_INDEX_NAME4, SEMATTRS_AWS_DYNAMODB_SELECT4, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT4, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD4, SEMATTRS_AWS_DYNAMODB_SEGMENT4, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS4, SEMATTRS_AWS_DYNAMODB_COUNT4, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT4, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4, SEMATTRS_MESSAGING_SYSTEM4, SEMATTRS_MESSAGING_DESTINATION4, SEMATTRS_MESSAGING_DESTINATION_KIND4, SEMATTRS_MESSAGING_TEMP_DESTINATION4, SEMATTRS_MESSAGING_PROTOCOL4, SEMATTRS_MESSAGING_PROTOCOL_VERSION4, SEMATTRS_MESSAGING_URL4, SEMATTRS_MESSAGING_MESSAGE_ID4, SEMATTRS_MESSAGING_CONVERSATION_ID4, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4, SEMATTRS_MESSAGING_OPERATION4, SEMATTRS_MESSAGING_CONSUMER_ID4, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY4, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY4, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP4, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID4, SEMATTRS_MESSAGING_KAFKA_PARTITION4, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE4, SEMATTRS_RPC_SYSTEM4, SEMATTRS_RPC_SERVICE4, SEMATTRS_RPC_METHOD4, SEMATTRS_RPC_GRPC_STATUS_CODE4, SEMATTRS_RPC_JSONRPC_VERSION4, SEMATTRS_RPC_JSONRPC_REQUEST_ID4, SEMATTRS_RPC_JSONRPC_ERROR_CODE4, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE4, SEMATTRS_MESSAGE_TYPE4, SEMATTRS_MESSAGE_ID4, SEMATTRS_MESSAGE_COMPRESSED_SIZE4, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE4, SemanticAttributes4, TMP_DBSYSTEMVALUES_OTHER_SQL4, TMP_DBSYSTEMVALUES_MSSQL4, TMP_DBSYSTEMVALUES_MYSQL4, TMP_DBSYSTEMVALUES_ORACLE4, TMP_DBSYSTEMVALUES_DB24, TMP_DBSYSTEMVALUES_POSTGRESQL4, TMP_DBSYSTEMVALUES_REDSHIFT4, TMP_DBSYSTEMVALUES_HIVE4, TMP_DBSYSTEMVALUES_CLOUDSCAPE4, TMP_DBSYSTEMVALUES_HSQLDB4, TMP_DBSYSTEMVALUES_PROGRESS4, TMP_DBSYSTEMVALUES_MAXDB4, TMP_DBSYSTEMVALUES_HANADB4, TMP_DBSYSTEMVALUES_INGRES4, TMP_DBSYSTEMVALUES_FIRSTSQL4, TMP_DBSYSTEMVALUES_EDB4, TMP_DBSYSTEMVALUES_CACHE4, TMP_DBSYSTEMVALUES_ADABAS4, TMP_DBSYSTEMVALUES_FIREBIRD4, TMP_DBSYSTEMVALUES_DERBY4, TMP_DBSYSTEMVALUES_FILEMAKER4, TMP_DBSYSTEMVALUES_INFORMIX4, TMP_DBSYSTEMVALUES_INSTANTDB4, TMP_DBSYSTEMVALUES_INTERBASE4, TMP_DBSYSTEMVALUES_MARIADB4, TMP_DBSYSTEMVALUES_NETEZZA4, TMP_DBSYSTEMVALUES_PERVASIVE4, TMP_DBSYSTEMVALUES_POINTBASE4, TMP_DBSYSTEMVALUES_SQLITE4, TMP_DBSYSTEMVALUES_SYBASE4, TMP_DBSYSTEMVALUES_TERADATA4, TMP_DBSYSTEMVALUES_VERTICA4, TMP_DBSYSTEMVALUES_H24, TMP_DBSYSTEMVALUES_COLDFUSION4, TMP_DBSYSTEMVALUES_CASSANDRA4, TMP_DBSYSTEMVALUES_HBASE4, TMP_DBSYSTEMVALUES_MONGODB4, TMP_DBSYSTEMVALUES_REDIS4, TMP_DBSYSTEMVALUES_COUCHBASE4, TMP_DBSYSTEMVALUES_COUCHDB4, TMP_DBSYSTEMVALUES_COSMOSDB4, TMP_DBSYSTEMVALUES_DYNAMODB4, TMP_DBSYSTEMVALUES_NEO4J4, TMP_DBSYSTEMVALUES_GEODE4, TMP_DBSYSTEMVALUES_ELASTICSEARCH4, TMP_DBSYSTEMVALUES_MEMCACHED4, TMP_DBSYSTEMVALUES_COCKROACHDB4, DBSYSTEMVALUES_OTHER_SQL4, DBSYSTEMVALUES_MSSQL4, DBSYSTEMVALUES_MYSQL4, DBSYSTEMVALUES_ORACLE4, DBSYSTEMVALUES_DB24, DBSYSTEMVALUES_POSTGRESQL4, DBSYSTEMVALUES_REDSHIFT4, DBSYSTEMVALUES_HIVE4, DBSYSTEMVALUES_CLOUDSCAPE4, DBSYSTEMVALUES_HSQLDB4, DBSYSTEMVALUES_PROGRESS4, DBSYSTEMVALUES_MAXDB4, DBSYSTEMVALUES_HANADB4, DBSYSTEMVALUES_INGRES4, DBSYSTEMVALUES_FIRSTSQL4, DBSYSTEMVALUES_EDB4, DBSYSTEMVALUES_CACHE4, DBSYSTEMVALUES_ADABAS4, DBSYSTEMVALUES_FIREBIRD4, DBSYSTEMVALUES_DERBY4, DBSYSTEMVALUES_FILEMAKER4, DBSYSTEMVALUES_INFORMIX4, DBSYSTEMVALUES_INSTANTDB4, DBSYSTEMVALUES_INTERBASE4, DBSYSTEMVALUES_MARIADB4, DBSYSTEMVALUES_NETEZZA4, DBSYSTEMVALUES_PERVASIVE4, DBSYSTEMVALUES_POINTBASE4, DBSYSTEMVALUES_SQLITE4, DBSYSTEMVALUES_SYBASE4, DBSYSTEMVALUES_TERADATA4, DBSYSTEMVALUES_VERTICA4, DBSYSTEMVALUES_H24, DBSYSTEMVALUES_COLDFUSION4, DBSYSTEMVALUES_CASSANDRA4, DBSYSTEMVALUES_HBASE4, DBSYSTEMVALUES_MONGODB4, DBSYSTEMVALUES_REDIS4, DBSYSTEMVALUES_COUCHBASE4, DBSYSTEMVALUES_COUCHDB4, DBSYSTEMVALUES_COSMOSDB4, DBSYSTEMVALUES_DYNAMODB4, DBSYSTEMVALUES_NEO4J4, DBSYSTEMVALUES_GEODE4, DBSYSTEMVALUES_ELASTICSEARCH4, DBSYSTEMVALUES_MEMCACHED4, DBSYSTEMVALUES_COCKROACHDB4, DbSystemValues4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4, DBCASSANDRACONSISTENCYLEVELVALUES_ALL4, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4, DBCASSANDRACONSISTENCYLEVELVALUES_ONE4, DBCASSANDRACONSISTENCYLEVELVALUES_TWO4, DBCASSANDRACONSISTENCYLEVELVALUES_THREE4, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4, DBCASSANDRACONSISTENCYLEVELVALUES_ANY4, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4, DbCassandraConsistencyLevelValues4, TMP_FAASTRIGGERVALUES_DATASOURCE4, TMP_FAASTRIGGERVALUES_HTTP4, TMP_FAASTRIGGERVALUES_PUBSUB4, TMP_FAASTRIGGERVALUES_TIMER4, TMP_FAASTRIGGERVALUES_OTHER4, FAASTRIGGERVALUES_DATASOURCE4, FAASTRIGGERVALUES_HTTP4, FAASTRIGGERVALUES_PUBSUB4, FAASTRIGGERVALUES_TIMER4, FAASTRIGGERVALUES_OTHER4, FaasTriggerValues4, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT4, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT4, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE4, FAASDOCUMENTOPERATIONVALUES_INSERT4, FAASDOCUMENTOPERATIONVALUES_EDIT4, FAASDOCUMENTOPERATIONVALUES_DELETE4, FaasDocumentOperationValues4, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4, TMP_FAASINVOKEDPROVIDERVALUES_AWS4, TMP_FAASINVOKEDPROVIDERVALUES_AZURE4, TMP_FAASINVOKEDPROVIDERVALUES_GCP4, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4, FAASINVOKEDPROVIDERVALUES_AWS4, FAASINVOKEDPROVIDERVALUES_AZURE4, FAASINVOKEDPROVIDERVALUES_GCP4, FaasInvokedProviderValues4, TMP_NETTRANSPORTVALUES_IP_TCP4, TMP_NETTRANSPORTVALUES_IP_UDP4, TMP_NETTRANSPORTVALUES_IP4, TMP_NETTRANSPORTVALUES_UNIX4, TMP_NETTRANSPORTVALUES_PIPE4, TMP_NETTRANSPORTVALUES_INPROC4, TMP_NETTRANSPORTVALUES_OTHER4, NETTRANSPORTVALUES_IP_TCP4, NETTRANSPORTVALUES_IP_UDP4, NETTRANSPORTVALUES_IP4, NETTRANSPORTVALUES_UNIX4, NETTRANSPORTVALUES_PIPE4, NETTRANSPORTVALUES_INPROC4, NETTRANSPORTVALUES_OTHER4, NetTransportValues4, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI4, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED4, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL4, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4, NETHOSTCONNECTIONTYPEVALUES_WIFI4, NETHOSTCONNECTIONTYPEVALUES_WIRED4, NETHOSTCONNECTIONTYPEVALUES_CELL4, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4, NetHostConnectionTypeValues4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4, NETHOSTCONNECTIONSUBTYPEVALUES_LTE4, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4, NETHOSTCONNECTIONSUBTYPEVALUES_GSM4, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4, NETHOSTCONNECTIONSUBTYPEVALUES_NR4, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4, NetHostConnectionSubtypeValues4, TMP_HTTPFLAVORVALUES_HTTP_1_04, TMP_HTTPFLAVORVALUES_HTTP_1_14, TMP_HTTPFLAVORVALUES_HTTP_2_04, TMP_HTTPFLAVORVALUES_SPDY4, TMP_HTTPFLAVORVALUES_QUIC4, HTTPFLAVORVALUES_HTTP_1_04, HTTPFLAVORVALUES_HTTP_1_14, HTTPFLAVORVALUES_HTTP_2_04, HTTPFLAVORVALUES_SPDY4, HTTPFLAVORVALUES_QUIC4, HttpFlavorValues4, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE4, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC4, MESSAGINGDESTINATIONKINDVALUES_QUEUE4, MESSAGINGDESTINATIONKINDVALUES_TOPIC4, MessagingDestinationKindValues4, TMP_MESSAGINGOPERATIONVALUES_RECEIVE4, TMP_MESSAGINGOPERATIONVALUES_PROCESS4, MESSAGINGOPERATIONVALUES_RECEIVE4, MESSAGINGOPERATIONVALUES_PROCESS4, MessagingOperationValues4, TMP_RPCGRPCSTATUSCODEVALUES_OK4, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED4, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN4, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND4, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED4, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL4, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS4, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4, RPCGRPCSTATUSCODEVALUES_OK4, RPCGRPCSTATUSCODEVALUES_CANCELLED4, RPCGRPCSTATUSCODEVALUES_UNKNOWN4, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4, RPCGRPCSTATUSCODEVALUES_NOT_FOUND4, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4, RPCGRPCSTATUSCODEVALUES_ABORTED4, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4, RPCGRPCSTATUSCODEVALUES_INTERNAL4, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4, RPCGRPCSTATUSCODEVALUES_DATA_LOSS4, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4, RpcGrpcStatusCodeValues4, TMP_MESSAGETYPEVALUES_SENT4, TMP_MESSAGETYPEVALUES_RECEIVED4, MESSAGETYPEVALUES_SENT4, MESSAGETYPEVALUES_RECEIVED4, MessageTypeValues4;
var init_SemanticAttributes4 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils6();
    TMP_AWS_LAMBDA_INVOKED_ARN4 = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM4 = "db.system";
    TMP_DB_CONNECTION_STRING4 = "db.connection_string";
    TMP_DB_USER4 = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME4 = "db.jdbc.driver_classname";
    TMP_DB_NAME4 = "db.name";
    TMP_DB_STATEMENT4 = "db.statement";
    TMP_DB_OPERATION4 = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME4 = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE4 = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE4 = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL4 = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE4 = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE4 = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4 = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID4 = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC4 = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE4 = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX4 = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION4 = "db.mongodb.collection";
    TMP_DB_SQL_TABLE4 = "db.sql.table";
    TMP_EXCEPTION_TYPE4 = "exception.type";
    TMP_EXCEPTION_MESSAGE4 = "exception.message";
    TMP_EXCEPTION_STACKTRACE4 = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED4 = "exception.escaped";
    TMP_FAAS_TRIGGER4 = "faas.trigger";
    TMP_FAAS_EXECUTION4 = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION4 = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION4 = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME4 = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME4 = "faas.document.name";
    TMP_FAAS_TIME4 = "faas.time";
    TMP_FAAS_CRON4 = "faas.cron";
    TMP_FAAS_COLDSTART4 = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME4 = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER4 = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION4 = "faas.invoked_region";
    TMP_NET_TRANSPORT4 = "net.transport";
    TMP_NET_PEER_IP4 = "net.peer.ip";
    TMP_NET_PEER_PORT4 = "net.peer.port";
    TMP_NET_PEER_NAME4 = "net.peer.name";
    TMP_NET_HOST_IP4 = "net.host.ip";
    TMP_NET_HOST_PORT4 = "net.host.port";
    TMP_NET_HOST_NAME4 = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE4 = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE4 = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME4 = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC4 = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC4 = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC4 = "net.host.carrier.icc";
    TMP_PEER_SERVICE4 = "peer.service";
    TMP_ENDUSER_ID4 = "enduser.id";
    TMP_ENDUSER_ROLE4 = "enduser.role";
    TMP_ENDUSER_SCOPE4 = "enduser.scope";
    TMP_THREAD_ID4 = "thread.id";
    TMP_THREAD_NAME4 = "thread.name";
    TMP_CODE_FUNCTION4 = "code.function";
    TMP_CODE_NAMESPACE4 = "code.namespace";
    TMP_CODE_FILEPATH4 = "code.filepath";
    TMP_CODE_LINENO4 = "code.lineno";
    TMP_HTTP_METHOD4 = "http.method";
    TMP_HTTP_URL4 = "http.url";
    TMP_HTTP_TARGET4 = "http.target";
    TMP_HTTP_HOST4 = "http.host";
    TMP_HTTP_SCHEME4 = "http.scheme";
    TMP_HTTP_STATUS_CODE4 = "http.status_code";
    TMP_HTTP_FLAVOR4 = "http.flavor";
    TMP_HTTP_USER_AGENT4 = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH4 = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4 = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH4 = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4 = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME4 = "http.server_name";
    TMP_HTTP_ROUTE4 = "http.route";
    TMP_HTTP_CLIENT_IP4 = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES4 = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY4 = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4 = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4 = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4 = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ4 = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION4 = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT4 = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET4 = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME4 = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT4 = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4 = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4 = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4 = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT4 = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD4 = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT4 = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS4 = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT4 = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT4 = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4 = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4 = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM4 = "messaging.system";
    TMP_MESSAGING_DESTINATION4 = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND4 = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION4 = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL4 = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION4 = "messaging.protocol_version";
    TMP_MESSAGING_URL4 = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID4 = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID4 = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4 = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4 = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION4 = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID4 = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY4 = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY4 = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP4 = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID4 = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION4 = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE4 = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM4 = "rpc.system";
    TMP_RPC_SERVICE4 = "rpc.service";
    TMP_RPC_METHOD4 = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE4 = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION4 = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID4 = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE4 = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE4 = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE4 = "message.type";
    TMP_MESSAGE_ID4 = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE4 = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE4 = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN4 = TMP_AWS_LAMBDA_INVOKED_ARN4;
    SEMATTRS_DB_SYSTEM4 = TMP_DB_SYSTEM4;
    SEMATTRS_DB_CONNECTION_STRING4 = TMP_DB_CONNECTION_STRING4;
    SEMATTRS_DB_USER4 = TMP_DB_USER4;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME4 = TMP_DB_JDBC_DRIVER_CLASSNAME4;
    SEMATTRS_DB_NAME4 = TMP_DB_NAME4;
    SEMATTRS_DB_STATEMENT4 = TMP_DB_STATEMENT4;
    SEMATTRS_DB_OPERATION4 = TMP_DB_OPERATION4;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME4 = TMP_DB_MSSQL_INSTANCE_NAME4;
    SEMATTRS_DB_CASSANDRA_KEYSPACE4 = TMP_DB_CASSANDRA_KEYSPACE4;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE4 = TMP_DB_CASSANDRA_PAGE_SIZE4;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL4 = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL4;
    SEMATTRS_DB_CASSANDRA_TABLE4 = TMP_DB_CASSANDRA_TABLE4;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE4 = TMP_DB_CASSANDRA_IDEMPOTENCE4;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4 = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID4 = TMP_DB_CASSANDRA_COORDINATOR_ID4;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC4 = TMP_DB_CASSANDRA_COORDINATOR_DC4;
    SEMATTRS_DB_HBASE_NAMESPACE4 = TMP_DB_HBASE_NAMESPACE4;
    SEMATTRS_DB_REDIS_DATABASE_INDEX4 = TMP_DB_REDIS_DATABASE_INDEX4;
    SEMATTRS_DB_MONGODB_COLLECTION4 = TMP_DB_MONGODB_COLLECTION4;
    SEMATTRS_DB_SQL_TABLE4 = TMP_DB_SQL_TABLE4;
    SEMATTRS_EXCEPTION_TYPE4 = TMP_EXCEPTION_TYPE4;
    SEMATTRS_EXCEPTION_MESSAGE4 = TMP_EXCEPTION_MESSAGE4;
    SEMATTRS_EXCEPTION_STACKTRACE4 = TMP_EXCEPTION_STACKTRACE4;
    SEMATTRS_EXCEPTION_ESCAPED4 = TMP_EXCEPTION_ESCAPED4;
    SEMATTRS_FAAS_TRIGGER4 = TMP_FAAS_TRIGGER4;
    SEMATTRS_FAAS_EXECUTION4 = TMP_FAAS_EXECUTION4;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION4 = TMP_FAAS_DOCUMENT_COLLECTION4;
    SEMATTRS_FAAS_DOCUMENT_OPERATION4 = TMP_FAAS_DOCUMENT_OPERATION4;
    SEMATTRS_FAAS_DOCUMENT_TIME4 = TMP_FAAS_DOCUMENT_TIME4;
    SEMATTRS_FAAS_DOCUMENT_NAME4 = TMP_FAAS_DOCUMENT_NAME4;
    SEMATTRS_FAAS_TIME4 = TMP_FAAS_TIME4;
    SEMATTRS_FAAS_CRON4 = TMP_FAAS_CRON4;
    SEMATTRS_FAAS_COLDSTART4 = TMP_FAAS_COLDSTART4;
    SEMATTRS_FAAS_INVOKED_NAME4 = TMP_FAAS_INVOKED_NAME4;
    SEMATTRS_FAAS_INVOKED_PROVIDER4 = TMP_FAAS_INVOKED_PROVIDER4;
    SEMATTRS_FAAS_INVOKED_REGION4 = TMP_FAAS_INVOKED_REGION4;
    SEMATTRS_NET_TRANSPORT4 = TMP_NET_TRANSPORT4;
    SEMATTRS_NET_PEER_IP4 = TMP_NET_PEER_IP4;
    SEMATTRS_NET_PEER_PORT4 = TMP_NET_PEER_PORT4;
    SEMATTRS_NET_PEER_NAME4 = TMP_NET_PEER_NAME4;
    SEMATTRS_NET_HOST_IP4 = TMP_NET_HOST_IP4;
    SEMATTRS_NET_HOST_PORT4 = TMP_NET_HOST_PORT4;
    SEMATTRS_NET_HOST_NAME4 = TMP_NET_HOST_NAME4;
    SEMATTRS_NET_HOST_CONNECTION_TYPE4 = TMP_NET_HOST_CONNECTION_TYPE4;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE4 = TMP_NET_HOST_CONNECTION_SUBTYPE4;
    SEMATTRS_NET_HOST_CARRIER_NAME4 = TMP_NET_HOST_CARRIER_NAME4;
    SEMATTRS_NET_HOST_CARRIER_MCC4 = TMP_NET_HOST_CARRIER_MCC4;
    SEMATTRS_NET_HOST_CARRIER_MNC4 = TMP_NET_HOST_CARRIER_MNC4;
    SEMATTRS_NET_HOST_CARRIER_ICC4 = TMP_NET_HOST_CARRIER_ICC4;
    SEMATTRS_PEER_SERVICE4 = TMP_PEER_SERVICE4;
    SEMATTRS_ENDUSER_ID4 = TMP_ENDUSER_ID4;
    SEMATTRS_ENDUSER_ROLE4 = TMP_ENDUSER_ROLE4;
    SEMATTRS_ENDUSER_SCOPE4 = TMP_ENDUSER_SCOPE4;
    SEMATTRS_THREAD_ID4 = TMP_THREAD_ID4;
    SEMATTRS_THREAD_NAME4 = TMP_THREAD_NAME4;
    SEMATTRS_CODE_FUNCTION4 = TMP_CODE_FUNCTION4;
    SEMATTRS_CODE_NAMESPACE4 = TMP_CODE_NAMESPACE4;
    SEMATTRS_CODE_FILEPATH4 = TMP_CODE_FILEPATH4;
    SEMATTRS_CODE_LINENO4 = TMP_CODE_LINENO4;
    SEMATTRS_HTTP_METHOD4 = TMP_HTTP_METHOD4;
    SEMATTRS_HTTP_URL4 = TMP_HTTP_URL4;
    SEMATTRS_HTTP_TARGET4 = TMP_HTTP_TARGET4;
    SEMATTRS_HTTP_HOST4 = TMP_HTTP_HOST4;
    SEMATTRS_HTTP_SCHEME4 = TMP_HTTP_SCHEME4;
    SEMATTRS_HTTP_STATUS_CODE4 = TMP_HTTP_STATUS_CODE4;
    SEMATTRS_HTTP_FLAVOR4 = TMP_HTTP_FLAVOR4;
    SEMATTRS_HTTP_USER_AGENT4 = TMP_HTTP_USER_AGENT4;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH4 = TMP_HTTP_REQUEST_CONTENT_LENGTH4;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4 = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH4 = TMP_HTTP_RESPONSE_CONTENT_LENGTH4;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4 = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4;
    SEMATTRS_HTTP_SERVER_NAME4 = TMP_HTTP_SERVER_NAME4;
    SEMATTRS_HTTP_ROUTE4 = TMP_HTTP_ROUTE4;
    SEMATTRS_HTTP_CLIENT_IP4 = TMP_HTTP_CLIENT_IP4;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES4 = TMP_AWS_DYNAMODB_TABLE_NAMES4;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY4 = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY4;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4 = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4 = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4 = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ4 = TMP_AWS_DYNAMODB_CONSISTENT_READ4;
    SEMATTRS_AWS_DYNAMODB_PROJECTION4 = TMP_AWS_DYNAMODB_PROJECTION4;
    SEMATTRS_AWS_DYNAMODB_LIMIT4 = TMP_AWS_DYNAMODB_LIMIT4;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET4 = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET4;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME4 = TMP_AWS_DYNAMODB_INDEX_NAME4;
    SEMATTRS_AWS_DYNAMODB_SELECT4 = TMP_AWS_DYNAMODB_SELECT4;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4 = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4 = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT4 = TMP_AWS_DYNAMODB_TABLE_COUNT4;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD4 = TMP_AWS_DYNAMODB_SCAN_FORWARD4;
    SEMATTRS_AWS_DYNAMODB_SEGMENT4 = TMP_AWS_DYNAMODB_SEGMENT4;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS4 = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS4;
    SEMATTRS_AWS_DYNAMODB_COUNT4 = TMP_AWS_DYNAMODB_COUNT4;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT4 = TMP_AWS_DYNAMODB_SCANNED_COUNT4;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4 = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4;
    SEMATTRS_MESSAGING_SYSTEM4 = TMP_MESSAGING_SYSTEM4;
    SEMATTRS_MESSAGING_DESTINATION4 = TMP_MESSAGING_DESTINATION4;
    SEMATTRS_MESSAGING_DESTINATION_KIND4 = TMP_MESSAGING_DESTINATION_KIND4;
    SEMATTRS_MESSAGING_TEMP_DESTINATION4 = TMP_MESSAGING_TEMP_DESTINATION4;
    SEMATTRS_MESSAGING_PROTOCOL4 = TMP_MESSAGING_PROTOCOL4;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION4 = TMP_MESSAGING_PROTOCOL_VERSION4;
    SEMATTRS_MESSAGING_URL4 = TMP_MESSAGING_URL4;
    SEMATTRS_MESSAGING_MESSAGE_ID4 = TMP_MESSAGING_MESSAGE_ID4;
    SEMATTRS_MESSAGING_CONVERSATION_ID4 = TMP_MESSAGING_CONVERSATION_ID4;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4 = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4 = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4;
    SEMATTRS_MESSAGING_OPERATION4 = TMP_MESSAGING_OPERATION4;
    SEMATTRS_MESSAGING_CONSUMER_ID4 = TMP_MESSAGING_CONSUMER_ID4;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY4 = TMP_MESSAGING_RABBITMQ_ROUTING_KEY4;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY4 = TMP_MESSAGING_KAFKA_MESSAGE_KEY4;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP4 = TMP_MESSAGING_KAFKA_CONSUMER_GROUP4;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID4 = TMP_MESSAGING_KAFKA_CLIENT_ID4;
    SEMATTRS_MESSAGING_KAFKA_PARTITION4 = TMP_MESSAGING_KAFKA_PARTITION4;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE4 = TMP_MESSAGING_KAFKA_TOMBSTONE4;
    SEMATTRS_RPC_SYSTEM4 = TMP_RPC_SYSTEM4;
    SEMATTRS_RPC_SERVICE4 = TMP_RPC_SERVICE4;
    SEMATTRS_RPC_METHOD4 = TMP_RPC_METHOD4;
    SEMATTRS_RPC_GRPC_STATUS_CODE4 = TMP_RPC_GRPC_STATUS_CODE4;
    SEMATTRS_RPC_JSONRPC_VERSION4 = TMP_RPC_JSONRPC_VERSION4;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID4 = TMP_RPC_JSONRPC_REQUEST_ID4;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE4 = TMP_RPC_JSONRPC_ERROR_CODE4;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE4 = TMP_RPC_JSONRPC_ERROR_MESSAGE4;
    SEMATTRS_MESSAGE_TYPE4 = TMP_MESSAGE_TYPE4;
    SEMATTRS_MESSAGE_ID4 = TMP_MESSAGE_ID4;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE4 = TMP_MESSAGE_COMPRESSED_SIZE4;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE4 = TMP_MESSAGE_UNCOMPRESSED_SIZE4;
    SemanticAttributes4 = /* @__PURE__ */ createConstMap4([
      TMP_AWS_LAMBDA_INVOKED_ARN4,
      TMP_DB_SYSTEM4,
      TMP_DB_CONNECTION_STRING4,
      TMP_DB_USER4,
      TMP_DB_JDBC_DRIVER_CLASSNAME4,
      TMP_DB_NAME4,
      TMP_DB_STATEMENT4,
      TMP_DB_OPERATION4,
      TMP_DB_MSSQL_INSTANCE_NAME4,
      TMP_DB_CASSANDRA_KEYSPACE4,
      TMP_DB_CASSANDRA_PAGE_SIZE4,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL4,
      TMP_DB_CASSANDRA_TABLE4,
      TMP_DB_CASSANDRA_IDEMPOTENCE4,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4,
      TMP_DB_CASSANDRA_COORDINATOR_ID4,
      TMP_DB_CASSANDRA_COORDINATOR_DC4,
      TMP_DB_HBASE_NAMESPACE4,
      TMP_DB_REDIS_DATABASE_INDEX4,
      TMP_DB_MONGODB_COLLECTION4,
      TMP_DB_SQL_TABLE4,
      TMP_EXCEPTION_TYPE4,
      TMP_EXCEPTION_MESSAGE4,
      TMP_EXCEPTION_STACKTRACE4,
      TMP_EXCEPTION_ESCAPED4,
      TMP_FAAS_TRIGGER4,
      TMP_FAAS_EXECUTION4,
      TMP_FAAS_DOCUMENT_COLLECTION4,
      TMP_FAAS_DOCUMENT_OPERATION4,
      TMP_FAAS_DOCUMENT_TIME4,
      TMP_FAAS_DOCUMENT_NAME4,
      TMP_FAAS_TIME4,
      TMP_FAAS_CRON4,
      TMP_FAAS_COLDSTART4,
      TMP_FAAS_INVOKED_NAME4,
      TMP_FAAS_INVOKED_PROVIDER4,
      TMP_FAAS_INVOKED_REGION4,
      TMP_NET_TRANSPORT4,
      TMP_NET_PEER_IP4,
      TMP_NET_PEER_PORT4,
      TMP_NET_PEER_NAME4,
      TMP_NET_HOST_IP4,
      TMP_NET_HOST_PORT4,
      TMP_NET_HOST_NAME4,
      TMP_NET_HOST_CONNECTION_TYPE4,
      TMP_NET_HOST_CONNECTION_SUBTYPE4,
      TMP_NET_HOST_CARRIER_NAME4,
      TMP_NET_HOST_CARRIER_MCC4,
      TMP_NET_HOST_CARRIER_MNC4,
      TMP_NET_HOST_CARRIER_ICC4,
      TMP_PEER_SERVICE4,
      TMP_ENDUSER_ID4,
      TMP_ENDUSER_ROLE4,
      TMP_ENDUSER_SCOPE4,
      TMP_THREAD_ID4,
      TMP_THREAD_NAME4,
      TMP_CODE_FUNCTION4,
      TMP_CODE_NAMESPACE4,
      TMP_CODE_FILEPATH4,
      TMP_CODE_LINENO4,
      TMP_HTTP_METHOD4,
      TMP_HTTP_URL4,
      TMP_HTTP_TARGET4,
      TMP_HTTP_HOST4,
      TMP_HTTP_SCHEME4,
      TMP_HTTP_STATUS_CODE4,
      TMP_HTTP_FLAVOR4,
      TMP_HTTP_USER_AGENT4,
      TMP_HTTP_REQUEST_CONTENT_LENGTH4,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH4,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4,
      TMP_HTTP_SERVER_NAME4,
      TMP_HTTP_ROUTE4,
      TMP_HTTP_CLIENT_IP4,
      TMP_AWS_DYNAMODB_TABLE_NAMES4,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY4,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4,
      TMP_AWS_DYNAMODB_CONSISTENT_READ4,
      TMP_AWS_DYNAMODB_PROJECTION4,
      TMP_AWS_DYNAMODB_LIMIT4,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET4,
      TMP_AWS_DYNAMODB_INDEX_NAME4,
      TMP_AWS_DYNAMODB_SELECT4,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4,
      TMP_AWS_DYNAMODB_TABLE_COUNT4,
      TMP_AWS_DYNAMODB_SCAN_FORWARD4,
      TMP_AWS_DYNAMODB_SEGMENT4,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS4,
      TMP_AWS_DYNAMODB_COUNT4,
      TMP_AWS_DYNAMODB_SCANNED_COUNT4,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4,
      TMP_MESSAGING_SYSTEM4,
      TMP_MESSAGING_DESTINATION4,
      TMP_MESSAGING_DESTINATION_KIND4,
      TMP_MESSAGING_TEMP_DESTINATION4,
      TMP_MESSAGING_PROTOCOL4,
      TMP_MESSAGING_PROTOCOL_VERSION4,
      TMP_MESSAGING_URL4,
      TMP_MESSAGING_MESSAGE_ID4,
      TMP_MESSAGING_CONVERSATION_ID4,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4,
      TMP_MESSAGING_OPERATION4,
      TMP_MESSAGING_CONSUMER_ID4,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY4,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY4,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP4,
      TMP_MESSAGING_KAFKA_CLIENT_ID4,
      TMP_MESSAGING_KAFKA_PARTITION4,
      TMP_MESSAGING_KAFKA_TOMBSTONE4,
      TMP_RPC_SYSTEM4,
      TMP_RPC_SERVICE4,
      TMP_RPC_METHOD4,
      TMP_RPC_GRPC_STATUS_CODE4,
      TMP_RPC_JSONRPC_VERSION4,
      TMP_RPC_JSONRPC_REQUEST_ID4,
      TMP_RPC_JSONRPC_ERROR_CODE4,
      TMP_RPC_JSONRPC_ERROR_MESSAGE4,
      TMP_MESSAGE_TYPE4,
      TMP_MESSAGE_ID4,
      TMP_MESSAGE_COMPRESSED_SIZE4,
      TMP_MESSAGE_UNCOMPRESSED_SIZE4
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL4 = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL4 = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL4 = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE4 = "oracle";
    TMP_DBSYSTEMVALUES_DB24 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL4 = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT4 = "redshift";
    TMP_DBSYSTEMVALUES_HIVE4 = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE4 = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB4 = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS4 = "progress";
    TMP_DBSYSTEMVALUES_MAXDB4 = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB4 = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES4 = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL4 = "firstsql";
    TMP_DBSYSTEMVALUES_EDB4 = "edb";
    TMP_DBSYSTEMVALUES_CACHE4 = "cache";
    TMP_DBSYSTEMVALUES_ADABAS4 = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD4 = "firebird";
    TMP_DBSYSTEMVALUES_DERBY4 = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER4 = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX4 = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB4 = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE4 = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB4 = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA4 = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE4 = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE4 = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE4 = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE4 = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA4 = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA4 = "vertica";
    TMP_DBSYSTEMVALUES_H24 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION4 = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA4 = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE4 = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB4 = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS4 = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE4 = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB4 = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB4 = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB4 = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J4 = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE4 = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH4 = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED4 = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB4 = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL4 = TMP_DBSYSTEMVALUES_OTHER_SQL4;
    DBSYSTEMVALUES_MSSQL4 = TMP_DBSYSTEMVALUES_MSSQL4;
    DBSYSTEMVALUES_MYSQL4 = TMP_DBSYSTEMVALUES_MYSQL4;
    DBSYSTEMVALUES_ORACLE4 = TMP_DBSYSTEMVALUES_ORACLE4;
    DBSYSTEMVALUES_DB24 = TMP_DBSYSTEMVALUES_DB24;
    DBSYSTEMVALUES_POSTGRESQL4 = TMP_DBSYSTEMVALUES_POSTGRESQL4;
    DBSYSTEMVALUES_REDSHIFT4 = TMP_DBSYSTEMVALUES_REDSHIFT4;
    DBSYSTEMVALUES_HIVE4 = TMP_DBSYSTEMVALUES_HIVE4;
    DBSYSTEMVALUES_CLOUDSCAPE4 = TMP_DBSYSTEMVALUES_CLOUDSCAPE4;
    DBSYSTEMVALUES_HSQLDB4 = TMP_DBSYSTEMVALUES_HSQLDB4;
    DBSYSTEMVALUES_PROGRESS4 = TMP_DBSYSTEMVALUES_PROGRESS4;
    DBSYSTEMVALUES_MAXDB4 = TMP_DBSYSTEMVALUES_MAXDB4;
    DBSYSTEMVALUES_HANADB4 = TMP_DBSYSTEMVALUES_HANADB4;
    DBSYSTEMVALUES_INGRES4 = TMP_DBSYSTEMVALUES_INGRES4;
    DBSYSTEMVALUES_FIRSTSQL4 = TMP_DBSYSTEMVALUES_FIRSTSQL4;
    DBSYSTEMVALUES_EDB4 = TMP_DBSYSTEMVALUES_EDB4;
    DBSYSTEMVALUES_CACHE4 = TMP_DBSYSTEMVALUES_CACHE4;
    DBSYSTEMVALUES_ADABAS4 = TMP_DBSYSTEMVALUES_ADABAS4;
    DBSYSTEMVALUES_FIREBIRD4 = TMP_DBSYSTEMVALUES_FIREBIRD4;
    DBSYSTEMVALUES_DERBY4 = TMP_DBSYSTEMVALUES_DERBY4;
    DBSYSTEMVALUES_FILEMAKER4 = TMP_DBSYSTEMVALUES_FILEMAKER4;
    DBSYSTEMVALUES_INFORMIX4 = TMP_DBSYSTEMVALUES_INFORMIX4;
    DBSYSTEMVALUES_INSTANTDB4 = TMP_DBSYSTEMVALUES_INSTANTDB4;
    DBSYSTEMVALUES_INTERBASE4 = TMP_DBSYSTEMVALUES_INTERBASE4;
    DBSYSTEMVALUES_MARIADB4 = TMP_DBSYSTEMVALUES_MARIADB4;
    DBSYSTEMVALUES_NETEZZA4 = TMP_DBSYSTEMVALUES_NETEZZA4;
    DBSYSTEMVALUES_PERVASIVE4 = TMP_DBSYSTEMVALUES_PERVASIVE4;
    DBSYSTEMVALUES_POINTBASE4 = TMP_DBSYSTEMVALUES_POINTBASE4;
    DBSYSTEMVALUES_SQLITE4 = TMP_DBSYSTEMVALUES_SQLITE4;
    DBSYSTEMVALUES_SYBASE4 = TMP_DBSYSTEMVALUES_SYBASE4;
    DBSYSTEMVALUES_TERADATA4 = TMP_DBSYSTEMVALUES_TERADATA4;
    DBSYSTEMVALUES_VERTICA4 = TMP_DBSYSTEMVALUES_VERTICA4;
    DBSYSTEMVALUES_H24 = TMP_DBSYSTEMVALUES_H24;
    DBSYSTEMVALUES_COLDFUSION4 = TMP_DBSYSTEMVALUES_COLDFUSION4;
    DBSYSTEMVALUES_CASSANDRA4 = TMP_DBSYSTEMVALUES_CASSANDRA4;
    DBSYSTEMVALUES_HBASE4 = TMP_DBSYSTEMVALUES_HBASE4;
    DBSYSTEMVALUES_MONGODB4 = TMP_DBSYSTEMVALUES_MONGODB4;
    DBSYSTEMVALUES_REDIS4 = TMP_DBSYSTEMVALUES_REDIS4;
    DBSYSTEMVALUES_COUCHBASE4 = TMP_DBSYSTEMVALUES_COUCHBASE4;
    DBSYSTEMVALUES_COUCHDB4 = TMP_DBSYSTEMVALUES_COUCHDB4;
    DBSYSTEMVALUES_COSMOSDB4 = TMP_DBSYSTEMVALUES_COSMOSDB4;
    DBSYSTEMVALUES_DYNAMODB4 = TMP_DBSYSTEMVALUES_DYNAMODB4;
    DBSYSTEMVALUES_NEO4J4 = TMP_DBSYSTEMVALUES_NEO4J4;
    DBSYSTEMVALUES_GEODE4 = TMP_DBSYSTEMVALUES_GEODE4;
    DBSYSTEMVALUES_ELASTICSEARCH4 = TMP_DBSYSTEMVALUES_ELASTICSEARCH4;
    DBSYSTEMVALUES_MEMCACHED4 = TMP_DBSYSTEMVALUES_MEMCACHED4;
    DBSYSTEMVALUES_COCKROACHDB4 = TMP_DBSYSTEMVALUES_COCKROACHDB4;
    DbSystemValues4 = /* @__PURE__ */ createConstMap4([
      TMP_DBSYSTEMVALUES_OTHER_SQL4,
      TMP_DBSYSTEMVALUES_MSSQL4,
      TMP_DBSYSTEMVALUES_MYSQL4,
      TMP_DBSYSTEMVALUES_ORACLE4,
      TMP_DBSYSTEMVALUES_DB24,
      TMP_DBSYSTEMVALUES_POSTGRESQL4,
      TMP_DBSYSTEMVALUES_REDSHIFT4,
      TMP_DBSYSTEMVALUES_HIVE4,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE4,
      TMP_DBSYSTEMVALUES_HSQLDB4,
      TMP_DBSYSTEMVALUES_PROGRESS4,
      TMP_DBSYSTEMVALUES_MAXDB4,
      TMP_DBSYSTEMVALUES_HANADB4,
      TMP_DBSYSTEMVALUES_INGRES4,
      TMP_DBSYSTEMVALUES_FIRSTSQL4,
      TMP_DBSYSTEMVALUES_EDB4,
      TMP_DBSYSTEMVALUES_CACHE4,
      TMP_DBSYSTEMVALUES_ADABAS4,
      TMP_DBSYSTEMVALUES_FIREBIRD4,
      TMP_DBSYSTEMVALUES_DERBY4,
      TMP_DBSYSTEMVALUES_FILEMAKER4,
      TMP_DBSYSTEMVALUES_INFORMIX4,
      TMP_DBSYSTEMVALUES_INSTANTDB4,
      TMP_DBSYSTEMVALUES_INTERBASE4,
      TMP_DBSYSTEMVALUES_MARIADB4,
      TMP_DBSYSTEMVALUES_NETEZZA4,
      TMP_DBSYSTEMVALUES_PERVASIVE4,
      TMP_DBSYSTEMVALUES_POINTBASE4,
      TMP_DBSYSTEMVALUES_SQLITE4,
      TMP_DBSYSTEMVALUES_SYBASE4,
      TMP_DBSYSTEMVALUES_TERADATA4,
      TMP_DBSYSTEMVALUES_VERTICA4,
      TMP_DBSYSTEMVALUES_H24,
      TMP_DBSYSTEMVALUES_COLDFUSION4,
      TMP_DBSYSTEMVALUES_CASSANDRA4,
      TMP_DBSYSTEMVALUES_HBASE4,
      TMP_DBSYSTEMVALUES_MONGODB4,
      TMP_DBSYSTEMVALUES_REDIS4,
      TMP_DBSYSTEMVALUES_COUCHBASE4,
      TMP_DBSYSTEMVALUES_COUCHDB4,
      TMP_DBSYSTEMVALUES_COSMOSDB4,
      TMP_DBSYSTEMVALUES_DYNAMODB4,
      TMP_DBSYSTEMVALUES_NEO4J4,
      TMP_DBSYSTEMVALUES_GEODE4,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH4,
      TMP_DBSYSTEMVALUES_MEMCACHED4,
      TMP_DBSYSTEMVALUES_COCKROACHDB4
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL4 = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4 = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4 = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4 = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE4 = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO4 = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE4 = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4 = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY4 = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4 = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4 = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL4;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE4;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO4;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE4;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY4;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4;
    DbCassandraConsistencyLevelValues4 = /* @__PURE__ */ createConstMap4([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE4 = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP4 = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB4 = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER4 = "timer";
    TMP_FAASTRIGGERVALUES_OTHER4 = "other";
    FAASTRIGGERVALUES_DATASOURCE4 = TMP_FAASTRIGGERVALUES_DATASOURCE4;
    FAASTRIGGERVALUES_HTTP4 = TMP_FAASTRIGGERVALUES_HTTP4;
    FAASTRIGGERVALUES_PUBSUB4 = TMP_FAASTRIGGERVALUES_PUBSUB4;
    FAASTRIGGERVALUES_TIMER4 = TMP_FAASTRIGGERVALUES_TIMER4;
    FAASTRIGGERVALUES_OTHER4 = TMP_FAASTRIGGERVALUES_OTHER4;
    FaasTriggerValues4 = /* @__PURE__ */ createConstMap4([
      TMP_FAASTRIGGERVALUES_DATASOURCE4,
      TMP_FAASTRIGGERVALUES_HTTP4,
      TMP_FAASTRIGGERVALUES_PUBSUB4,
      TMP_FAASTRIGGERVALUES_TIMER4,
      TMP_FAASTRIGGERVALUES_OTHER4
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT4 = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT4 = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE4 = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT4 = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT4;
    FAASDOCUMENTOPERATIONVALUES_EDIT4 = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT4;
    FAASDOCUMENTOPERATIONVALUES_DELETE4 = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE4;
    FaasDocumentOperationValues4 = /* @__PURE__ */ createConstMap4([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT4,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT4,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE4
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4 = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS4 = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE4 = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP4 = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4 = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4;
    FAASINVOKEDPROVIDERVALUES_AWS4 = TMP_FAASINVOKEDPROVIDERVALUES_AWS4;
    FAASINVOKEDPROVIDERVALUES_AZURE4 = TMP_FAASINVOKEDPROVIDERVALUES_AZURE4;
    FAASINVOKEDPROVIDERVALUES_GCP4 = TMP_FAASINVOKEDPROVIDERVALUES_GCP4;
    FaasInvokedProviderValues4 = /* @__PURE__ */ createConstMap4([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS4,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE4,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP4
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP4 = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP4 = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP4 = "ip";
    TMP_NETTRANSPORTVALUES_UNIX4 = "unix";
    TMP_NETTRANSPORTVALUES_PIPE4 = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC4 = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER4 = "other";
    NETTRANSPORTVALUES_IP_TCP4 = TMP_NETTRANSPORTVALUES_IP_TCP4;
    NETTRANSPORTVALUES_IP_UDP4 = TMP_NETTRANSPORTVALUES_IP_UDP4;
    NETTRANSPORTVALUES_IP4 = TMP_NETTRANSPORTVALUES_IP4;
    NETTRANSPORTVALUES_UNIX4 = TMP_NETTRANSPORTVALUES_UNIX4;
    NETTRANSPORTVALUES_PIPE4 = TMP_NETTRANSPORTVALUES_PIPE4;
    NETTRANSPORTVALUES_INPROC4 = TMP_NETTRANSPORTVALUES_INPROC4;
    NETTRANSPORTVALUES_OTHER4 = TMP_NETTRANSPORTVALUES_OTHER4;
    NetTransportValues4 = /* @__PURE__ */ createConstMap4([
      TMP_NETTRANSPORTVALUES_IP_TCP4,
      TMP_NETTRANSPORTVALUES_IP_UDP4,
      TMP_NETTRANSPORTVALUES_IP4,
      TMP_NETTRANSPORTVALUES_UNIX4,
      TMP_NETTRANSPORTVALUES_PIPE4,
      TMP_NETTRANSPORTVALUES_INPROC4,
      TMP_NETTRANSPORTVALUES_OTHER4
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI4 = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED4 = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL4 = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4 = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4 = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI4 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI4;
    NETHOSTCONNECTIONTYPEVALUES_WIRED4 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED4;
    NETHOSTCONNECTIONTYPEVALUES_CELL4 = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL4;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4;
    NetHostConnectionTypeValues4 = /* @__PURE__ */ createConstMap4([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI4,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED4,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL4,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4 = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4 = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4 = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4 = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4 = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4 = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4 = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4 = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4 = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4 = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4 = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE4 = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4 = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4 = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM4 = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4 = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4 = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR4 = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4 = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4 = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE4;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM4;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR4;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4;
    NetHostConnectionSubtypeValues4 = /* @__PURE__ */ createConstMap4([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_04 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_14 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_04 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY4 = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC4 = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_04 = TMP_HTTPFLAVORVALUES_HTTP_1_04;
    HTTPFLAVORVALUES_HTTP_1_14 = TMP_HTTPFLAVORVALUES_HTTP_1_14;
    HTTPFLAVORVALUES_HTTP_2_04 = TMP_HTTPFLAVORVALUES_HTTP_2_04;
    HTTPFLAVORVALUES_SPDY4 = TMP_HTTPFLAVORVALUES_SPDY4;
    HTTPFLAVORVALUES_QUIC4 = TMP_HTTPFLAVORVALUES_QUIC4;
    HttpFlavorValues4 = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_04,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_14,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_04,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY4,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC4
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE4 = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC4 = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE4 = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE4;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC4 = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC4;
    MessagingDestinationKindValues4 = /* @__PURE__ */ createConstMap4([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE4,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC4
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE4 = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS4 = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE4 = TMP_MESSAGINGOPERATIONVALUES_RECEIVE4;
    MESSAGINGOPERATIONVALUES_PROCESS4 = TMP_MESSAGINGOPERATIONVALUES_PROCESS4;
    MessagingOperationValues4 = /* @__PURE__ */ createConstMap4([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE4,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS4
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK4 = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED4 = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN4 = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4 = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4 = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND4 = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4 = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4 = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4 = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4 = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED4 = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4 = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4 = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL4 = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4 = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS4 = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4 = 16;
    RPCGRPCSTATUSCODEVALUES_OK4 = TMP_RPCGRPCSTATUSCODEVALUES_OK4;
    RPCGRPCSTATUSCODEVALUES_CANCELLED4 = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED4;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN4 = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN4;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4 = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4 = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND4 = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND4;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4 = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4 = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4 = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4 = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4;
    RPCGRPCSTATUSCODEVALUES_ABORTED4 = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED4;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4 = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4 = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4;
    RPCGRPCSTATUSCODEVALUES_INTERNAL4 = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL4;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4 = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS4 = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS4;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4 = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4;
    RpcGrpcStatusCodeValues4 = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK4,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED4,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN4,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND4,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED4,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL4,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS4,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4
    };
    TMP_MESSAGETYPEVALUES_SENT4 = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED4 = "RECEIVED";
    MESSAGETYPEVALUES_SENT4 = TMP_MESSAGETYPEVALUES_SENT4;
    MESSAGETYPEVALUES_RECEIVED4 = TMP_MESSAGETYPEVALUES_RECEIVED4;
    MessageTypeValues4 = /* @__PURE__ */ createConstMap4([
      TMP_MESSAGETYPEVALUES_SENT4,
      TMP_MESSAGETYPEVALUES_RECEIVED4
    ]);
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace5 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes4();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER4, TMP_CLOUD_ACCOUNT_ID4, TMP_CLOUD_REGION4, TMP_CLOUD_AVAILABILITY_ZONE4, TMP_CLOUD_PLATFORM4, TMP_AWS_ECS_CONTAINER_ARN4, TMP_AWS_ECS_CLUSTER_ARN4, TMP_AWS_ECS_LAUNCHTYPE4, TMP_AWS_ECS_TASK_ARN4, TMP_AWS_ECS_TASK_FAMILY4, TMP_AWS_ECS_TASK_REVISION4, TMP_AWS_EKS_CLUSTER_ARN4, TMP_AWS_LOG_GROUP_NAMES4, TMP_AWS_LOG_GROUP_ARNS4, TMP_AWS_LOG_STREAM_NAMES4, TMP_AWS_LOG_STREAM_ARNS4, TMP_CONTAINER_NAME4, TMP_CONTAINER_ID4, TMP_CONTAINER_RUNTIME4, TMP_CONTAINER_IMAGE_NAME4, TMP_CONTAINER_IMAGE_TAG4, TMP_DEPLOYMENT_ENVIRONMENT4, TMP_DEVICE_ID4, TMP_DEVICE_MODEL_IDENTIFIER4, TMP_DEVICE_MODEL_NAME4, TMP_FAAS_NAME4, TMP_FAAS_ID4, TMP_FAAS_VERSION4, TMP_FAAS_INSTANCE4, TMP_FAAS_MAX_MEMORY4, TMP_HOST_ID4, TMP_HOST_NAME4, TMP_HOST_TYPE4, TMP_HOST_ARCH4, TMP_HOST_IMAGE_NAME4, TMP_HOST_IMAGE_ID4, TMP_HOST_IMAGE_VERSION4, TMP_K8S_CLUSTER_NAME4, TMP_K8S_NODE_NAME4, TMP_K8S_NODE_UID4, TMP_K8S_NAMESPACE_NAME4, TMP_K8S_POD_UID4, TMP_K8S_POD_NAME4, TMP_K8S_CONTAINER_NAME4, TMP_K8S_REPLICASET_UID4, TMP_K8S_REPLICASET_NAME4, TMP_K8S_DEPLOYMENT_UID4, TMP_K8S_DEPLOYMENT_NAME4, TMP_K8S_STATEFULSET_UID4, TMP_K8S_STATEFULSET_NAME4, TMP_K8S_DAEMONSET_UID4, TMP_K8S_DAEMONSET_NAME4, TMP_K8S_JOB_UID4, TMP_K8S_JOB_NAME4, TMP_K8S_CRONJOB_UID4, TMP_K8S_CRONJOB_NAME4, TMP_OS_TYPE4, TMP_OS_DESCRIPTION4, TMP_OS_NAME4, TMP_OS_VERSION4, TMP_PROCESS_PID4, TMP_PROCESS_EXECUTABLE_NAME4, TMP_PROCESS_EXECUTABLE_PATH4, TMP_PROCESS_COMMAND4, TMP_PROCESS_COMMAND_LINE4, TMP_PROCESS_COMMAND_ARGS4, TMP_PROCESS_OWNER4, TMP_PROCESS_RUNTIME_NAME4, TMP_PROCESS_RUNTIME_VERSION4, TMP_PROCESS_RUNTIME_DESCRIPTION4, TMP_SERVICE_NAME4, TMP_SERVICE_NAMESPACE4, TMP_SERVICE_INSTANCE_ID4, TMP_SERVICE_VERSION4, TMP_TELEMETRY_SDK_NAME4, TMP_TELEMETRY_SDK_LANGUAGE4, TMP_TELEMETRY_SDK_VERSION4, TMP_TELEMETRY_AUTO_VERSION4, TMP_WEBENGINE_NAME4, TMP_WEBENGINE_VERSION4, TMP_WEBENGINE_DESCRIPTION4, SEMRESATTRS_CLOUD_PROVIDER4, SEMRESATTRS_CLOUD_ACCOUNT_ID4, SEMRESATTRS_CLOUD_REGION4, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE4, SEMRESATTRS_CLOUD_PLATFORM4, SEMRESATTRS_AWS_ECS_CONTAINER_ARN4, SEMRESATTRS_AWS_ECS_CLUSTER_ARN4, SEMRESATTRS_AWS_ECS_LAUNCHTYPE4, SEMRESATTRS_AWS_ECS_TASK_ARN4, SEMRESATTRS_AWS_ECS_TASK_FAMILY4, SEMRESATTRS_AWS_ECS_TASK_REVISION4, SEMRESATTRS_AWS_EKS_CLUSTER_ARN4, SEMRESATTRS_AWS_LOG_GROUP_NAMES4, SEMRESATTRS_AWS_LOG_GROUP_ARNS4, SEMRESATTRS_AWS_LOG_STREAM_NAMES4, SEMRESATTRS_AWS_LOG_STREAM_ARNS4, SEMRESATTRS_CONTAINER_NAME4, SEMRESATTRS_CONTAINER_ID4, SEMRESATTRS_CONTAINER_RUNTIME4, SEMRESATTRS_CONTAINER_IMAGE_NAME4, SEMRESATTRS_CONTAINER_IMAGE_TAG4, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT4, SEMRESATTRS_DEVICE_ID4, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER4, SEMRESATTRS_DEVICE_MODEL_NAME4, SEMRESATTRS_FAAS_NAME4, SEMRESATTRS_FAAS_ID4, SEMRESATTRS_FAAS_VERSION4, SEMRESATTRS_FAAS_INSTANCE4, SEMRESATTRS_FAAS_MAX_MEMORY4, SEMRESATTRS_HOST_ID4, SEMRESATTRS_HOST_NAME4, SEMRESATTRS_HOST_TYPE4, SEMRESATTRS_HOST_ARCH4, SEMRESATTRS_HOST_IMAGE_NAME4, SEMRESATTRS_HOST_IMAGE_ID4, SEMRESATTRS_HOST_IMAGE_VERSION4, SEMRESATTRS_K8S_CLUSTER_NAME4, SEMRESATTRS_K8S_NODE_NAME4, SEMRESATTRS_K8S_NODE_UID4, SEMRESATTRS_K8S_NAMESPACE_NAME4, SEMRESATTRS_K8S_POD_UID4, SEMRESATTRS_K8S_POD_NAME4, SEMRESATTRS_K8S_CONTAINER_NAME4, SEMRESATTRS_K8S_REPLICASET_UID4, SEMRESATTRS_K8S_REPLICASET_NAME4, SEMRESATTRS_K8S_DEPLOYMENT_UID4, SEMRESATTRS_K8S_DEPLOYMENT_NAME4, SEMRESATTRS_K8S_STATEFULSET_UID4, SEMRESATTRS_K8S_STATEFULSET_NAME4, SEMRESATTRS_K8S_DAEMONSET_UID4, SEMRESATTRS_K8S_DAEMONSET_NAME4, SEMRESATTRS_K8S_JOB_UID4, SEMRESATTRS_K8S_JOB_NAME4, SEMRESATTRS_K8S_CRONJOB_UID4, SEMRESATTRS_K8S_CRONJOB_NAME4, SEMRESATTRS_OS_TYPE4, SEMRESATTRS_OS_DESCRIPTION4, SEMRESATTRS_OS_NAME4, SEMRESATTRS_OS_VERSION4, SEMRESATTRS_PROCESS_PID4, SEMRESATTRS_PROCESS_EXECUTABLE_NAME4, SEMRESATTRS_PROCESS_EXECUTABLE_PATH4, SEMRESATTRS_PROCESS_COMMAND4, SEMRESATTRS_PROCESS_COMMAND_LINE4, SEMRESATTRS_PROCESS_COMMAND_ARGS4, SEMRESATTRS_PROCESS_OWNER4, SEMRESATTRS_PROCESS_RUNTIME_NAME4, SEMRESATTRS_PROCESS_RUNTIME_VERSION4, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION4, SEMRESATTRS_SERVICE_NAME4, SEMRESATTRS_SERVICE_NAMESPACE4, SEMRESATTRS_SERVICE_INSTANCE_ID4, SEMRESATTRS_SERVICE_VERSION4, SEMRESATTRS_TELEMETRY_SDK_NAME4, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE4, SEMRESATTRS_TELEMETRY_SDK_VERSION4, SEMRESATTRS_TELEMETRY_AUTO_VERSION4, SEMRESATTRS_WEBENGINE_NAME4, SEMRESATTRS_WEBENGINE_VERSION4, SEMRESATTRS_WEBENGINE_DESCRIPTION4, SemanticResourceAttributes4, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD4, TMP_CLOUDPROVIDERVALUES_AWS4, TMP_CLOUDPROVIDERVALUES_AZURE4, TMP_CLOUDPROVIDERVALUES_GCP4, CLOUDPROVIDERVALUES_ALIBABA_CLOUD4, CLOUDPROVIDERVALUES_AWS4, CLOUDPROVIDERVALUES_AZURE4, CLOUDPROVIDERVALUES_GCP4, CloudProviderValues4, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4, TMP_CLOUDPLATFORMVALUES_AWS_EC24, TMP_CLOUDPLATFORMVALUES_AWS_ECS4, TMP_CLOUDPLATFORMVALUES_AWS_EKS4, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA4, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4, TMP_CLOUDPLATFORMVALUES_AZURE_VM4, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4, TMP_CLOUDPLATFORMVALUES_AZURE_AKS4, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE4, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4, CLOUDPLATFORMVALUES_AWS_EC24, CLOUDPLATFORMVALUES_AWS_ECS4, CLOUDPLATFORMVALUES_AWS_EKS4, CLOUDPLATFORMVALUES_AWS_LAMBDA4, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4, CLOUDPLATFORMVALUES_AZURE_VM4, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4, CLOUDPLATFORMVALUES_AZURE_AKS4, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4, CLOUDPLATFORMVALUES_GCP_APP_ENGINE4, CloudPlatformValues4, TMP_AWSECSLAUNCHTYPEVALUES_EC24, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE4, AWSECSLAUNCHTYPEVALUES_EC24, AWSECSLAUNCHTYPEVALUES_FARGATE4, AwsEcsLaunchtypeValues4, TMP_HOSTARCHVALUES_AMD644, TMP_HOSTARCHVALUES_ARM324, TMP_HOSTARCHVALUES_ARM644, TMP_HOSTARCHVALUES_IA644, TMP_HOSTARCHVALUES_PPC324, TMP_HOSTARCHVALUES_PPC644, TMP_HOSTARCHVALUES_X864, HOSTARCHVALUES_AMD644, HOSTARCHVALUES_ARM324, HOSTARCHVALUES_ARM644, HOSTARCHVALUES_IA644, HOSTARCHVALUES_PPC324, HOSTARCHVALUES_PPC644, HOSTARCHVALUES_X864, HostArchValues4, TMP_OSTYPEVALUES_WINDOWS4, TMP_OSTYPEVALUES_LINUX4, TMP_OSTYPEVALUES_DARWIN4, TMP_OSTYPEVALUES_FREEBSD4, TMP_OSTYPEVALUES_NETBSD4, TMP_OSTYPEVALUES_OPENBSD4, TMP_OSTYPEVALUES_DRAGONFLYBSD4, TMP_OSTYPEVALUES_HPUX4, TMP_OSTYPEVALUES_AIX4, TMP_OSTYPEVALUES_SOLARIS4, TMP_OSTYPEVALUES_Z_OS4, OSTYPEVALUES_WINDOWS4, OSTYPEVALUES_LINUX4, OSTYPEVALUES_DARWIN4, OSTYPEVALUES_FREEBSD4, OSTYPEVALUES_NETBSD4, OSTYPEVALUES_OPENBSD4, OSTYPEVALUES_DRAGONFLYBSD4, OSTYPEVALUES_HPUX4, OSTYPEVALUES_AIX4, OSTYPEVALUES_SOLARIS4, OSTYPEVALUES_Z_OS4, OsTypeValues4, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP4, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET4, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG4, TMP_TELEMETRYSDKLANGUAGEVALUES_GO4, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA4, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS4, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP4, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON4, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY4, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS4, TELEMETRYSDKLANGUAGEVALUES_CPP4, TELEMETRYSDKLANGUAGEVALUES_DOTNET4, TELEMETRYSDKLANGUAGEVALUES_ERLANG4, TELEMETRYSDKLANGUAGEVALUES_GO4, TELEMETRYSDKLANGUAGEVALUES_JAVA4, TELEMETRYSDKLANGUAGEVALUES_NODEJS4, TELEMETRYSDKLANGUAGEVALUES_PHP4, TELEMETRYSDKLANGUAGEVALUES_PYTHON4, TELEMETRYSDKLANGUAGEVALUES_RUBY4, TELEMETRYSDKLANGUAGEVALUES_WEBJS4, TelemetrySdkLanguageValues4;
var init_SemanticResourceAttributes4 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils6();
    TMP_CLOUD_PROVIDER4 = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID4 = "cloud.account.id";
    TMP_CLOUD_REGION4 = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE4 = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM4 = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN4 = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN4 = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE4 = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN4 = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY4 = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION4 = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN4 = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES4 = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS4 = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES4 = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS4 = "aws.log.stream.arns";
    TMP_CONTAINER_NAME4 = "container.name";
    TMP_CONTAINER_ID4 = "container.id";
    TMP_CONTAINER_RUNTIME4 = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME4 = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG4 = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT4 = "deployment.environment";
    TMP_DEVICE_ID4 = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER4 = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME4 = "device.model.name";
    TMP_FAAS_NAME4 = "faas.name";
    TMP_FAAS_ID4 = "faas.id";
    TMP_FAAS_VERSION4 = "faas.version";
    TMP_FAAS_INSTANCE4 = "faas.instance";
    TMP_FAAS_MAX_MEMORY4 = "faas.max_memory";
    TMP_HOST_ID4 = "host.id";
    TMP_HOST_NAME4 = "host.name";
    TMP_HOST_TYPE4 = "host.type";
    TMP_HOST_ARCH4 = "host.arch";
    TMP_HOST_IMAGE_NAME4 = "host.image.name";
    TMP_HOST_IMAGE_ID4 = "host.image.id";
    TMP_HOST_IMAGE_VERSION4 = "host.image.version";
    TMP_K8S_CLUSTER_NAME4 = "k8s.cluster.name";
    TMP_K8S_NODE_NAME4 = "k8s.node.name";
    TMP_K8S_NODE_UID4 = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME4 = "k8s.namespace.name";
    TMP_K8S_POD_UID4 = "k8s.pod.uid";
    TMP_K8S_POD_NAME4 = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME4 = "k8s.container.name";
    TMP_K8S_REPLICASET_UID4 = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME4 = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID4 = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME4 = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID4 = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME4 = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID4 = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME4 = "k8s.daemonset.name";
    TMP_K8S_JOB_UID4 = "k8s.job.uid";
    TMP_K8S_JOB_NAME4 = "k8s.job.name";
    TMP_K8S_CRONJOB_UID4 = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME4 = "k8s.cronjob.name";
    TMP_OS_TYPE4 = "os.type";
    TMP_OS_DESCRIPTION4 = "os.description";
    TMP_OS_NAME4 = "os.name";
    TMP_OS_VERSION4 = "os.version";
    TMP_PROCESS_PID4 = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME4 = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH4 = "process.executable.path";
    TMP_PROCESS_COMMAND4 = "process.command";
    TMP_PROCESS_COMMAND_LINE4 = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS4 = "process.command_args";
    TMP_PROCESS_OWNER4 = "process.owner";
    TMP_PROCESS_RUNTIME_NAME4 = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION4 = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION4 = "process.runtime.description";
    TMP_SERVICE_NAME4 = "service.name";
    TMP_SERVICE_NAMESPACE4 = "service.namespace";
    TMP_SERVICE_INSTANCE_ID4 = "service.instance.id";
    TMP_SERVICE_VERSION4 = "service.version";
    TMP_TELEMETRY_SDK_NAME4 = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE4 = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION4 = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION4 = "telemetry.auto.version";
    TMP_WEBENGINE_NAME4 = "webengine.name";
    TMP_WEBENGINE_VERSION4 = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION4 = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER4 = TMP_CLOUD_PROVIDER4;
    SEMRESATTRS_CLOUD_ACCOUNT_ID4 = TMP_CLOUD_ACCOUNT_ID4;
    SEMRESATTRS_CLOUD_REGION4 = TMP_CLOUD_REGION4;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE4 = TMP_CLOUD_AVAILABILITY_ZONE4;
    SEMRESATTRS_CLOUD_PLATFORM4 = TMP_CLOUD_PLATFORM4;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN4 = TMP_AWS_ECS_CONTAINER_ARN4;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN4 = TMP_AWS_ECS_CLUSTER_ARN4;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE4 = TMP_AWS_ECS_LAUNCHTYPE4;
    SEMRESATTRS_AWS_ECS_TASK_ARN4 = TMP_AWS_ECS_TASK_ARN4;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY4 = TMP_AWS_ECS_TASK_FAMILY4;
    SEMRESATTRS_AWS_ECS_TASK_REVISION4 = TMP_AWS_ECS_TASK_REVISION4;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN4 = TMP_AWS_EKS_CLUSTER_ARN4;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES4 = TMP_AWS_LOG_GROUP_NAMES4;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS4 = TMP_AWS_LOG_GROUP_ARNS4;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES4 = TMP_AWS_LOG_STREAM_NAMES4;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS4 = TMP_AWS_LOG_STREAM_ARNS4;
    SEMRESATTRS_CONTAINER_NAME4 = TMP_CONTAINER_NAME4;
    SEMRESATTRS_CONTAINER_ID4 = TMP_CONTAINER_ID4;
    SEMRESATTRS_CONTAINER_RUNTIME4 = TMP_CONTAINER_RUNTIME4;
    SEMRESATTRS_CONTAINER_IMAGE_NAME4 = TMP_CONTAINER_IMAGE_NAME4;
    SEMRESATTRS_CONTAINER_IMAGE_TAG4 = TMP_CONTAINER_IMAGE_TAG4;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT4 = TMP_DEPLOYMENT_ENVIRONMENT4;
    SEMRESATTRS_DEVICE_ID4 = TMP_DEVICE_ID4;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER4 = TMP_DEVICE_MODEL_IDENTIFIER4;
    SEMRESATTRS_DEVICE_MODEL_NAME4 = TMP_DEVICE_MODEL_NAME4;
    SEMRESATTRS_FAAS_NAME4 = TMP_FAAS_NAME4;
    SEMRESATTRS_FAAS_ID4 = TMP_FAAS_ID4;
    SEMRESATTRS_FAAS_VERSION4 = TMP_FAAS_VERSION4;
    SEMRESATTRS_FAAS_INSTANCE4 = TMP_FAAS_INSTANCE4;
    SEMRESATTRS_FAAS_MAX_MEMORY4 = TMP_FAAS_MAX_MEMORY4;
    SEMRESATTRS_HOST_ID4 = TMP_HOST_ID4;
    SEMRESATTRS_HOST_NAME4 = TMP_HOST_NAME4;
    SEMRESATTRS_HOST_TYPE4 = TMP_HOST_TYPE4;
    SEMRESATTRS_HOST_ARCH4 = TMP_HOST_ARCH4;
    SEMRESATTRS_HOST_IMAGE_NAME4 = TMP_HOST_IMAGE_NAME4;
    SEMRESATTRS_HOST_IMAGE_ID4 = TMP_HOST_IMAGE_ID4;
    SEMRESATTRS_HOST_IMAGE_VERSION4 = TMP_HOST_IMAGE_VERSION4;
    SEMRESATTRS_K8S_CLUSTER_NAME4 = TMP_K8S_CLUSTER_NAME4;
    SEMRESATTRS_K8S_NODE_NAME4 = TMP_K8S_NODE_NAME4;
    SEMRESATTRS_K8S_NODE_UID4 = TMP_K8S_NODE_UID4;
    SEMRESATTRS_K8S_NAMESPACE_NAME4 = TMP_K8S_NAMESPACE_NAME4;
    SEMRESATTRS_K8S_POD_UID4 = TMP_K8S_POD_UID4;
    SEMRESATTRS_K8S_POD_NAME4 = TMP_K8S_POD_NAME4;
    SEMRESATTRS_K8S_CONTAINER_NAME4 = TMP_K8S_CONTAINER_NAME4;
    SEMRESATTRS_K8S_REPLICASET_UID4 = TMP_K8S_REPLICASET_UID4;
    SEMRESATTRS_K8S_REPLICASET_NAME4 = TMP_K8S_REPLICASET_NAME4;
    SEMRESATTRS_K8S_DEPLOYMENT_UID4 = TMP_K8S_DEPLOYMENT_UID4;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME4 = TMP_K8S_DEPLOYMENT_NAME4;
    SEMRESATTRS_K8S_STATEFULSET_UID4 = TMP_K8S_STATEFULSET_UID4;
    SEMRESATTRS_K8S_STATEFULSET_NAME4 = TMP_K8S_STATEFULSET_NAME4;
    SEMRESATTRS_K8S_DAEMONSET_UID4 = TMP_K8S_DAEMONSET_UID4;
    SEMRESATTRS_K8S_DAEMONSET_NAME4 = TMP_K8S_DAEMONSET_NAME4;
    SEMRESATTRS_K8S_JOB_UID4 = TMP_K8S_JOB_UID4;
    SEMRESATTRS_K8S_JOB_NAME4 = TMP_K8S_JOB_NAME4;
    SEMRESATTRS_K8S_CRONJOB_UID4 = TMP_K8S_CRONJOB_UID4;
    SEMRESATTRS_K8S_CRONJOB_NAME4 = TMP_K8S_CRONJOB_NAME4;
    SEMRESATTRS_OS_TYPE4 = TMP_OS_TYPE4;
    SEMRESATTRS_OS_DESCRIPTION4 = TMP_OS_DESCRIPTION4;
    SEMRESATTRS_OS_NAME4 = TMP_OS_NAME4;
    SEMRESATTRS_OS_VERSION4 = TMP_OS_VERSION4;
    SEMRESATTRS_PROCESS_PID4 = TMP_PROCESS_PID4;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME4 = TMP_PROCESS_EXECUTABLE_NAME4;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH4 = TMP_PROCESS_EXECUTABLE_PATH4;
    SEMRESATTRS_PROCESS_COMMAND4 = TMP_PROCESS_COMMAND4;
    SEMRESATTRS_PROCESS_COMMAND_LINE4 = TMP_PROCESS_COMMAND_LINE4;
    SEMRESATTRS_PROCESS_COMMAND_ARGS4 = TMP_PROCESS_COMMAND_ARGS4;
    SEMRESATTRS_PROCESS_OWNER4 = TMP_PROCESS_OWNER4;
    SEMRESATTRS_PROCESS_RUNTIME_NAME4 = TMP_PROCESS_RUNTIME_NAME4;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION4 = TMP_PROCESS_RUNTIME_VERSION4;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION4 = TMP_PROCESS_RUNTIME_DESCRIPTION4;
    SEMRESATTRS_SERVICE_NAME4 = TMP_SERVICE_NAME4;
    SEMRESATTRS_SERVICE_NAMESPACE4 = TMP_SERVICE_NAMESPACE4;
    SEMRESATTRS_SERVICE_INSTANCE_ID4 = TMP_SERVICE_INSTANCE_ID4;
    SEMRESATTRS_SERVICE_VERSION4 = TMP_SERVICE_VERSION4;
    SEMRESATTRS_TELEMETRY_SDK_NAME4 = TMP_TELEMETRY_SDK_NAME4;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE4 = TMP_TELEMETRY_SDK_LANGUAGE4;
    SEMRESATTRS_TELEMETRY_SDK_VERSION4 = TMP_TELEMETRY_SDK_VERSION4;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION4 = TMP_TELEMETRY_AUTO_VERSION4;
    SEMRESATTRS_WEBENGINE_NAME4 = TMP_WEBENGINE_NAME4;
    SEMRESATTRS_WEBENGINE_VERSION4 = TMP_WEBENGINE_VERSION4;
    SEMRESATTRS_WEBENGINE_DESCRIPTION4 = TMP_WEBENGINE_DESCRIPTION4;
    SemanticResourceAttributes4 = /* @__PURE__ */ createConstMap4([
      TMP_CLOUD_PROVIDER4,
      TMP_CLOUD_ACCOUNT_ID4,
      TMP_CLOUD_REGION4,
      TMP_CLOUD_AVAILABILITY_ZONE4,
      TMP_CLOUD_PLATFORM4,
      TMP_AWS_ECS_CONTAINER_ARN4,
      TMP_AWS_ECS_CLUSTER_ARN4,
      TMP_AWS_ECS_LAUNCHTYPE4,
      TMP_AWS_ECS_TASK_ARN4,
      TMP_AWS_ECS_TASK_FAMILY4,
      TMP_AWS_ECS_TASK_REVISION4,
      TMP_AWS_EKS_CLUSTER_ARN4,
      TMP_AWS_LOG_GROUP_NAMES4,
      TMP_AWS_LOG_GROUP_ARNS4,
      TMP_AWS_LOG_STREAM_NAMES4,
      TMP_AWS_LOG_STREAM_ARNS4,
      TMP_CONTAINER_NAME4,
      TMP_CONTAINER_ID4,
      TMP_CONTAINER_RUNTIME4,
      TMP_CONTAINER_IMAGE_NAME4,
      TMP_CONTAINER_IMAGE_TAG4,
      TMP_DEPLOYMENT_ENVIRONMENT4,
      TMP_DEVICE_ID4,
      TMP_DEVICE_MODEL_IDENTIFIER4,
      TMP_DEVICE_MODEL_NAME4,
      TMP_FAAS_NAME4,
      TMP_FAAS_ID4,
      TMP_FAAS_VERSION4,
      TMP_FAAS_INSTANCE4,
      TMP_FAAS_MAX_MEMORY4,
      TMP_HOST_ID4,
      TMP_HOST_NAME4,
      TMP_HOST_TYPE4,
      TMP_HOST_ARCH4,
      TMP_HOST_IMAGE_NAME4,
      TMP_HOST_IMAGE_ID4,
      TMP_HOST_IMAGE_VERSION4,
      TMP_K8S_CLUSTER_NAME4,
      TMP_K8S_NODE_NAME4,
      TMP_K8S_NODE_UID4,
      TMP_K8S_NAMESPACE_NAME4,
      TMP_K8S_POD_UID4,
      TMP_K8S_POD_NAME4,
      TMP_K8S_CONTAINER_NAME4,
      TMP_K8S_REPLICASET_UID4,
      TMP_K8S_REPLICASET_NAME4,
      TMP_K8S_DEPLOYMENT_UID4,
      TMP_K8S_DEPLOYMENT_NAME4,
      TMP_K8S_STATEFULSET_UID4,
      TMP_K8S_STATEFULSET_NAME4,
      TMP_K8S_DAEMONSET_UID4,
      TMP_K8S_DAEMONSET_NAME4,
      TMP_K8S_JOB_UID4,
      TMP_K8S_JOB_NAME4,
      TMP_K8S_CRONJOB_UID4,
      TMP_K8S_CRONJOB_NAME4,
      TMP_OS_TYPE4,
      TMP_OS_DESCRIPTION4,
      TMP_OS_NAME4,
      TMP_OS_VERSION4,
      TMP_PROCESS_PID4,
      TMP_PROCESS_EXECUTABLE_NAME4,
      TMP_PROCESS_EXECUTABLE_PATH4,
      TMP_PROCESS_COMMAND4,
      TMP_PROCESS_COMMAND_LINE4,
      TMP_PROCESS_COMMAND_ARGS4,
      TMP_PROCESS_OWNER4,
      TMP_PROCESS_RUNTIME_NAME4,
      TMP_PROCESS_RUNTIME_VERSION4,
      TMP_PROCESS_RUNTIME_DESCRIPTION4,
      TMP_SERVICE_NAME4,
      TMP_SERVICE_NAMESPACE4,
      TMP_SERVICE_INSTANCE_ID4,
      TMP_SERVICE_VERSION4,
      TMP_TELEMETRY_SDK_NAME4,
      TMP_TELEMETRY_SDK_LANGUAGE4,
      TMP_TELEMETRY_SDK_VERSION4,
      TMP_TELEMETRY_AUTO_VERSION4,
      TMP_WEBENGINE_NAME4,
      TMP_WEBENGINE_VERSION4,
      TMP_WEBENGINE_DESCRIPTION4
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD4 = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS4 = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE4 = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP4 = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD4 = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD4;
    CLOUDPROVIDERVALUES_AWS4 = TMP_CLOUDPROVIDERVALUES_AWS4;
    CLOUDPROVIDERVALUES_AZURE4 = TMP_CLOUDPROVIDERVALUES_AZURE4;
    CLOUDPROVIDERVALUES_GCP4 = TMP_CLOUDPROVIDERVALUES_GCP4;
    CloudProviderValues4 = /* @__PURE__ */ createConstMap4([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD4,
      TMP_CLOUDPROVIDERVALUES_AWS4,
      TMP_CLOUDPROVIDERVALUES_AZURE4,
      TMP_CLOUDPROVIDERVALUES_GCP4
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4 = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4 = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC24 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS4 = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS4 = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA4 = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4 = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM4 = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4 = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS4 = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4 = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4 = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4 = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4 = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4 = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4 = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE4 = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4;
    CLOUDPLATFORMVALUES_AWS_EC24 = TMP_CLOUDPLATFORMVALUES_AWS_EC24;
    CLOUDPLATFORMVALUES_AWS_ECS4 = TMP_CLOUDPLATFORMVALUES_AWS_ECS4;
    CLOUDPLATFORMVALUES_AWS_EKS4 = TMP_CLOUDPLATFORMVALUES_AWS_EKS4;
    CLOUDPLATFORMVALUES_AWS_LAMBDA4 = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA4;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4 = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4;
    CLOUDPLATFORMVALUES_AZURE_VM4 = TMP_CLOUDPLATFORMVALUES_AZURE_VM4;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4 = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4;
    CLOUDPLATFORMVALUES_AZURE_AKS4 = TMP_CLOUDPLATFORMVALUES_AZURE_AKS4;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4 = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4 = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4 = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4 = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE4 = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE4;
    CloudPlatformValues4 = /* @__PURE__ */ createConstMap4([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4,
      TMP_CLOUDPLATFORMVALUES_AWS_EC24,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS4,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS4,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA4,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM4,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS4,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE4
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC24 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE4 = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC24 = TMP_AWSECSLAUNCHTYPEVALUES_EC24;
    AWSECSLAUNCHTYPEVALUES_FARGATE4 = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE4;
    AwsEcsLaunchtypeValues4 = /* @__PURE__ */ createConstMap4([
      TMP_AWSECSLAUNCHTYPEVALUES_EC24,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE4
    ]);
    TMP_HOSTARCHVALUES_AMD644 = "amd64";
    TMP_HOSTARCHVALUES_ARM324 = "arm32";
    TMP_HOSTARCHVALUES_ARM644 = "arm64";
    TMP_HOSTARCHVALUES_IA644 = "ia64";
    TMP_HOSTARCHVALUES_PPC324 = "ppc32";
    TMP_HOSTARCHVALUES_PPC644 = "ppc64";
    TMP_HOSTARCHVALUES_X864 = "x86";
    HOSTARCHVALUES_AMD644 = TMP_HOSTARCHVALUES_AMD644;
    HOSTARCHVALUES_ARM324 = TMP_HOSTARCHVALUES_ARM324;
    HOSTARCHVALUES_ARM644 = TMP_HOSTARCHVALUES_ARM644;
    HOSTARCHVALUES_IA644 = TMP_HOSTARCHVALUES_IA644;
    HOSTARCHVALUES_PPC324 = TMP_HOSTARCHVALUES_PPC324;
    HOSTARCHVALUES_PPC644 = TMP_HOSTARCHVALUES_PPC644;
    HOSTARCHVALUES_X864 = TMP_HOSTARCHVALUES_X864;
    HostArchValues4 = /* @__PURE__ */ createConstMap4([
      TMP_HOSTARCHVALUES_AMD644,
      TMP_HOSTARCHVALUES_ARM324,
      TMP_HOSTARCHVALUES_ARM644,
      TMP_HOSTARCHVALUES_IA644,
      TMP_HOSTARCHVALUES_PPC324,
      TMP_HOSTARCHVALUES_PPC644,
      TMP_HOSTARCHVALUES_X864
    ]);
    TMP_OSTYPEVALUES_WINDOWS4 = "windows";
    TMP_OSTYPEVALUES_LINUX4 = "linux";
    TMP_OSTYPEVALUES_DARWIN4 = "darwin";
    TMP_OSTYPEVALUES_FREEBSD4 = "freebsd";
    TMP_OSTYPEVALUES_NETBSD4 = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD4 = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD4 = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX4 = "hpux";
    TMP_OSTYPEVALUES_AIX4 = "aix";
    TMP_OSTYPEVALUES_SOLARIS4 = "solaris";
    TMP_OSTYPEVALUES_Z_OS4 = "z_os";
    OSTYPEVALUES_WINDOWS4 = TMP_OSTYPEVALUES_WINDOWS4;
    OSTYPEVALUES_LINUX4 = TMP_OSTYPEVALUES_LINUX4;
    OSTYPEVALUES_DARWIN4 = TMP_OSTYPEVALUES_DARWIN4;
    OSTYPEVALUES_FREEBSD4 = TMP_OSTYPEVALUES_FREEBSD4;
    OSTYPEVALUES_NETBSD4 = TMP_OSTYPEVALUES_NETBSD4;
    OSTYPEVALUES_OPENBSD4 = TMP_OSTYPEVALUES_OPENBSD4;
    OSTYPEVALUES_DRAGONFLYBSD4 = TMP_OSTYPEVALUES_DRAGONFLYBSD4;
    OSTYPEVALUES_HPUX4 = TMP_OSTYPEVALUES_HPUX4;
    OSTYPEVALUES_AIX4 = TMP_OSTYPEVALUES_AIX4;
    OSTYPEVALUES_SOLARIS4 = TMP_OSTYPEVALUES_SOLARIS4;
    OSTYPEVALUES_Z_OS4 = TMP_OSTYPEVALUES_Z_OS4;
    OsTypeValues4 = /* @__PURE__ */ createConstMap4([
      TMP_OSTYPEVALUES_WINDOWS4,
      TMP_OSTYPEVALUES_LINUX4,
      TMP_OSTYPEVALUES_DARWIN4,
      TMP_OSTYPEVALUES_FREEBSD4,
      TMP_OSTYPEVALUES_NETBSD4,
      TMP_OSTYPEVALUES_OPENBSD4,
      TMP_OSTYPEVALUES_DRAGONFLYBSD4,
      TMP_OSTYPEVALUES_HPUX4,
      TMP_OSTYPEVALUES_AIX4,
      TMP_OSTYPEVALUES_SOLARIS4,
      TMP_OSTYPEVALUES_Z_OS4
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP4 = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET4 = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG4 = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO4 = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA4 = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS4 = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP4 = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON4 = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY4 = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS4 = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP4 = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP4;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET4 = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET4;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG4 = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG4;
    TELEMETRYSDKLANGUAGEVALUES_GO4 = TMP_TELEMETRYSDKLANGUAGEVALUES_GO4;
    TELEMETRYSDKLANGUAGEVALUES_JAVA4 = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA4;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS4 = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS4;
    TELEMETRYSDKLANGUAGEVALUES_PHP4 = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP4;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON4 = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON4;
    TELEMETRYSDKLANGUAGEVALUES_RUBY4 = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY4;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS4 = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS4;
    TelemetrySdkLanguageValues4 = /* @__PURE__ */ createConstMap4([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY4,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS4
    ]);
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource4 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes4();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT4, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED4, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER4, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER4, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED4, ATTR_TELEMETRY_SDK_LANGUAGE4, TELEMETRY_SDK_LANGUAGE_VALUE_CPP4, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET4, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG4, TELEMETRY_SDK_LANGUAGE_VALUE_GO4, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA4, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS4, TELEMETRY_SDK_LANGUAGE_VALUE_PHP4, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON4, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY4, TELEMETRY_SDK_LANGUAGE_VALUE_RUST4, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT4, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS4, ATTR_TELEMETRY_SDK_NAME4, ATTR_TELEMETRY_SDK_VERSION4, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE4, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT4, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED4, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED4, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED4, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED4, ATTR_ASPNETCORE_RATE_LIMITING_POLICY4, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED4, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK4, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS4, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE4, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS4, ATTR_CLIENT_ADDRESS4, ATTR_CLIENT_PORT4, ATTR_ERROR_TYPE4, ERROR_TYPE_VALUE_OTHER4, ATTR_EXCEPTION_ESCAPED4, ATTR_EXCEPTION_MESSAGE4, ATTR_EXCEPTION_STACKTRACE4, ATTR_EXCEPTION_TYPE4, ATTR_HTTP_REQUEST_HEADER4, ATTR_HTTP_REQUEST_METHOD4, HTTP_REQUEST_METHOD_VALUE_OTHER4, HTTP_REQUEST_METHOD_VALUE_CONNECT4, HTTP_REQUEST_METHOD_VALUE_DELETE4, HTTP_REQUEST_METHOD_VALUE_GET4, HTTP_REQUEST_METHOD_VALUE_HEAD4, HTTP_REQUEST_METHOD_VALUE_OPTIONS4, HTTP_REQUEST_METHOD_VALUE_PATCH4, HTTP_REQUEST_METHOD_VALUE_POST4, HTTP_REQUEST_METHOD_VALUE_PUT4, HTTP_REQUEST_METHOD_VALUE_TRACE4, ATTR_HTTP_REQUEST_METHOD_ORIGINAL4, ATTR_HTTP_REQUEST_RESEND_COUNT4, ATTR_HTTP_RESPONSE_HEADER4, ATTR_HTTP_RESPONSE_STATUS_CODE4, ATTR_HTTP_ROUTE4, ATTR_JVM_GC_ACTION4, ATTR_JVM_GC_NAME4, ATTR_JVM_MEMORY_POOL_NAME4, ATTR_JVM_MEMORY_TYPE4, JVM_MEMORY_TYPE_VALUE_HEAP4, JVM_MEMORY_TYPE_VALUE_NON_HEAP4, ATTR_JVM_THREAD_DAEMON4, ATTR_JVM_THREAD_STATE4, JVM_THREAD_STATE_VALUE_BLOCKED4, JVM_THREAD_STATE_VALUE_NEW4, JVM_THREAD_STATE_VALUE_RUNNABLE4, JVM_THREAD_STATE_VALUE_TERMINATED4, JVM_THREAD_STATE_VALUE_TIMED_WAITING4, JVM_THREAD_STATE_VALUE_WAITING4, ATTR_NETWORK_LOCAL_ADDRESS4, ATTR_NETWORK_LOCAL_PORT4, ATTR_NETWORK_PEER_ADDRESS4, ATTR_NETWORK_PEER_PORT4, ATTR_NETWORK_PROTOCOL_NAME4, ATTR_NETWORK_PROTOCOL_VERSION4, ATTR_NETWORK_TRANSPORT4, NETWORK_TRANSPORT_VALUE_PIPE4, NETWORK_TRANSPORT_VALUE_QUIC4, NETWORK_TRANSPORT_VALUE_TCP4, NETWORK_TRANSPORT_VALUE_UDP4, NETWORK_TRANSPORT_VALUE_UNIX4, ATTR_NETWORK_TYPE4, NETWORK_TYPE_VALUE_IPV44, NETWORK_TYPE_VALUE_IPV64, ATTR_OTEL_SCOPE_NAME4, ATTR_OTEL_SCOPE_VERSION4, ATTR_OTEL_STATUS_CODE4, OTEL_STATUS_CODE_VALUE_ERROR4, OTEL_STATUS_CODE_VALUE_OK4, ATTR_OTEL_STATUS_DESCRIPTION4, ATTR_SERVER_ADDRESS4, ATTR_SERVER_PORT4, ATTR_SERVICE_NAME4, ATTR_SERVICE_VERSION4, ATTR_SIGNALR_CONNECTION_STATUS4, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN4, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE4, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT4, ATTR_SIGNALR_TRANSPORT4, SIGNALR_TRANSPORT_VALUE_LONG_POLLING4, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS4, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS4, ATTR_URL_FRAGMENT4, ATTR_URL_FULL4, ATTR_URL_PATH4, ATTR_URL_QUERY4, ATTR_URL_SCHEME4, ATTR_USER_AGENT_ORIGINAL4;
var init_stable_attributes4 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT4 = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED4 = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER4 = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER4 = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED4 = "request_canceled";
    ATTR_TELEMETRY_SDK_LANGUAGE4 = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP4 = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET4 = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG4 = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO4 = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA4 = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS4 = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP4 = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON4 = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY4 = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST4 = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT4 = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS4 = "webjs";
    ATTR_TELEMETRY_SDK_NAME4 = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION4 = "telemetry.sdk.version";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE4 = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT4 = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED4 = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED4 = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED4 = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED4 = "unhandled";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY4 = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED4 = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK4 = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS4 = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE4 = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS4 = "success";
    ATTR_CLIENT_ADDRESS4 = "client.address";
    ATTR_CLIENT_PORT4 = "client.port";
    ATTR_ERROR_TYPE4 = "error.type";
    ERROR_TYPE_VALUE_OTHER4 = "_OTHER";
    ATTR_EXCEPTION_ESCAPED4 = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE4 = "exception.message";
    ATTR_EXCEPTION_STACKTRACE4 = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE4 = "exception.type";
    ATTR_HTTP_REQUEST_HEADER4 = function(key) {
      return "http.request.header." + key;
    };
    ATTR_HTTP_REQUEST_METHOD4 = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER4 = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT4 = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE4 = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET4 = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD4 = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS4 = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH4 = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST4 = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT4 = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE4 = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL4 = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT4 = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER4 = function(key) {
      return "http.response.header." + key;
    };
    ATTR_HTTP_RESPONSE_STATUS_CODE4 = "http.response.status_code";
    ATTR_HTTP_ROUTE4 = "http.route";
    ATTR_JVM_GC_ACTION4 = "jvm.gc.action";
    ATTR_JVM_GC_NAME4 = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME4 = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE4 = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP4 = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP4 = "non_heap";
    ATTR_JVM_THREAD_DAEMON4 = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE4 = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED4 = "blocked";
    JVM_THREAD_STATE_VALUE_NEW4 = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE4 = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED4 = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING4 = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING4 = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS4 = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT4 = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS4 = "network.peer.address";
    ATTR_NETWORK_PEER_PORT4 = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME4 = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION4 = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT4 = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE4 = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC4 = "quic";
    NETWORK_TRANSPORT_VALUE_TCP4 = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP4 = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX4 = "unix";
    ATTR_NETWORK_TYPE4 = "network.type";
    NETWORK_TYPE_VALUE_IPV44 = "ipv4";
    NETWORK_TYPE_VALUE_IPV64 = "ipv6";
    ATTR_OTEL_SCOPE_NAME4 = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION4 = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE4 = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR4 = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK4 = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION4 = "otel.status_description";
    ATTR_SERVER_ADDRESS4 = "server.address";
    ATTR_SERVER_PORT4 = "server.port";
    ATTR_SERVICE_NAME4 = "service.name";
    ATTR_SERVICE_VERSION4 = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS4 = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN4 = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE4 = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT4 = "timeout";
    ATTR_SIGNALR_TRANSPORT4 = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING4 = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS4 = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS4 = "web_sockets";
    ATTR_URL_FRAGMENT4 = "url.fragment";
    ATTR_URL_FULL4 = "url.full";
    ATTR_URL_PATH4 = "url.path";
    ATTR_URL_QUERY4 = "url.query";
    ATTR_URL_SCHEME4 = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL4 = "user_agent.original";
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS4, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES4, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS4, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE4, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION4, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS4, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS4, METRIC_HTTP_CLIENT_REQUEST_DURATION4, METRIC_HTTP_SERVER_REQUEST_DURATION4, METRIC_JVM_CLASS_COUNT4, METRIC_JVM_CLASS_LOADED4, METRIC_JVM_CLASS_UNLOADED4, METRIC_JVM_CPU_COUNT4, METRIC_JVM_CPU_RECENT_UTILIZATION4, METRIC_JVM_CPU_TIME4, METRIC_JVM_GC_DURATION4, METRIC_JVM_MEMORY_COMMITTED4, METRIC_JVM_MEMORY_LIMIT4, METRIC_JVM_MEMORY_USED4, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC4, METRIC_JVM_THREAD_COUNT4, METRIC_KESTREL_ACTIVE_CONNECTIONS4, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES4, METRIC_KESTREL_CONNECTION_DURATION4, METRIC_KESTREL_QUEUED_CONNECTIONS4, METRIC_KESTREL_QUEUED_REQUESTS4, METRIC_KESTREL_REJECTED_CONNECTIONS4, METRIC_KESTREL_TLS_HANDSHAKE_DURATION4, METRIC_KESTREL_UPGRADED_CONNECTIONS4, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS4, METRIC_SIGNALR_SERVER_CONNECTION_DURATION4;
var init_stable_metrics4 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS4 = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES4 = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS4 = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE4 = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION4 = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS4 = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS4 = "aspnetcore.routing.match_attempts";
    METRIC_HTTP_CLIENT_REQUEST_DURATION4 = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION4 = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT4 = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED4 = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED4 = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT4 = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION4 = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME4 = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION4 = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED4 = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT4 = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED4 = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC4 = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT4 = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS4 = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES4 = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION4 = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS4 = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS4 = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS4 = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION4 = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS4 = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS4 = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION4 = "signalr.server.connection.duration";
  }
});

// node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED4,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED4,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED4,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED4,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED4,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER4,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER4,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED4,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE4,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS4,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT4,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE4,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY4,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT4,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED4,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK4,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS4,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS4,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT4,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE4,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED4,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE4,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE4,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE4,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER4,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD4,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL4,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT4,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER4,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE4,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE4,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION4,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME4,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME4,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE4,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON4,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE4,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS4,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT4,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS4,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT4,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME4,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION4,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT4,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE4,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME4,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION4,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE4,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION4,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS4,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT4,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME4,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION4,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS4,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT4,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE4,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME4,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION4,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT4,
  ATTR_URL_FULL: () => ATTR_URL_FULL4,
  ATTR_URL_PATH: () => ATTR_URL_PATH4,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY4,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME4,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL4,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC24,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE4,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues4,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS4,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC4,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC24,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS4,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS4,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK4,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA4,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS4,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE4,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES4,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS4,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM4,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE4,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS4,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN4,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE4,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE4,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD4,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS4,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE4,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP4,
  CloudPlatformValues: () => CloudPlatformValues4,
  CloudProviderValues: () => CloudProviderValues4,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL4,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY4,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM4,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE4,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM4,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL4,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE4,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM4,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL4,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE4,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO4,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS4,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE4,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA4,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE4,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB4,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION4,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB4,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE4,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB4,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB24,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY4,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB4,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB4,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH4,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER4,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD4,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL4,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE4,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H24,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB4,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE4,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE4,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB4,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX4,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES4,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB4,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE4,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB4,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB4,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED4,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB4,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL4,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL4,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J4,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA4,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE4,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL4,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE4,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE4,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL4,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS4,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS4,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT4,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE4,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE4,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA4,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA4,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues4,
  DbSystemValues: () => DbSystemValues4,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER4,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE4,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT4,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT4,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD4,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS4,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE4,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP4,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE4,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP4,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER4,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB4,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER4,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues4,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues4,
  FaasTriggerValues: () => FaasTriggerValues4,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD644,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM324,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM644,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA644,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC324,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC644,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X864,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_04,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_14,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_04,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC4,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY4,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT4,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE4,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET4,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD4,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS4,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER4,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH4,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST4,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT4,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE4,
  HostArchValues: () => HostArchValues4,
  HttpFlavorValues: () => HttpFlavorValues4,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP4,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP4,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED4,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW4,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE4,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED4,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING4,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING4,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED4,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT4,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE4,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC4,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS4,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE4,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS4,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES4,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS4,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS4,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION4,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE4,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS4,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION4,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION4,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT4,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED4,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED4,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT4,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION4,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME4,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION4,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED4,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT4,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED4,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC4,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT4,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS4,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES4,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION4,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS4,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS4,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS4,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION4,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS4,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS4,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION4,
  MessageTypeValues: () => MessageTypeValues4,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues4,
  MessagingOperationValues: () => MessagingOperationValues4,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT4,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE4,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD4,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_04,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A4,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B4,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS4,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM4,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP4,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN4,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN4,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE4,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR4,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA4,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS4,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL4,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE4,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN4,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI4,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED4,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC4,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP4,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP4,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP4,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER4,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE4,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX4,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE4,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC4,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP4,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP4,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX4,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV44,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV64,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues4,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues4,
  NetTransportValues: () => NetTransportValues4,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX4,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN4,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD4,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD4,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX4,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX4,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD4,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD4,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS4,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS4,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS4,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR4,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK4,
  OsTypeValues: () => OsTypeValues4,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED4,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS4,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED4,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS4,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED4,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION4,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL4,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT4,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND4,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK4,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE4,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED4,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED4,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED4,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE4,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED4,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN4,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues4,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET4,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS4,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ4,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY4,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT4,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE4,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES4,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES4,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME4,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS4,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT4,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES4,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION4,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY4,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY4,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT4,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD4,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT4,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT4,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT4,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES4,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS4,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN4,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH4,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION4,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO4,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE4,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL4,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC4,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID4,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE4,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE4,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE4,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT4,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE4,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING4,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE4,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME4,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION4,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME4,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME4,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION4,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX4,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE4,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT4,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM4,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER4,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID4,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE4,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE4,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED4,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE4,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE4,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE4,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART4,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON4,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION4,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME4,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION4,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME4,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION4,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME4,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER4,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION4,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME4,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER4,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP4,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR4,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST4,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD4,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH4,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED4,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH4,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED4,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE4,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME4,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME4,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE4,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET4,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL4,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT4,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE4,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID4,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE4,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE4,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID4,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID4,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION4,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND4,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID4,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP4,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY4,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION4,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE4,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID4,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES4,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES4,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION4,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL4,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION4,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY4,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM4,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION4,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL4,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC4,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC4,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC4,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME4,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE4,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE4,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP4,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME4,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT4,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP4,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME4,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT4,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT4,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE4,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE4,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE4,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE4,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID4,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION4,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD4,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE4,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM4,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID4,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME4,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN4,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN4,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE4,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN4,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY4,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION4,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN4,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS4,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES4,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS4,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES4,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID4,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE4,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM4,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER4,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION4,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID4,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME4,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG4,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME4,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME4,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT4,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID4,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER4,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME4,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID4,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE4,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY4,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME4,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION4,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH4,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID4,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID4,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME4,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION4,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME4,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE4,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME4,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME4,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME4,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID4,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME4,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID4,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME4,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID4,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME4,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID4,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME4,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME4,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID4,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME4,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID4,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME4,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID4,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME4,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID4,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION4,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME4,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE4,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION4,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND4,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS4,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE4,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME4,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH4,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER4,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID4,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION4,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME4,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION4,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID4,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME4,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE4,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION4,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION4,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE4,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME4,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION4,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION4,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME4,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION4,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN4,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE4,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT4,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING4,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS4,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS4,
  SemanticAttributes: () => SemanticAttributes4,
  SemanticResourceAttributes: () => SemanticResourceAttributes4,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP4,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET4,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG4,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO4,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA4,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS4,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP4,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON4,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY4,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS4,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP4,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET4,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG4,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO4,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA4,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS4,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP4,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON4,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY4,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST4,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT4,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS4,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues4
});
var init_esm5 = __esm({
  "node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace5();
    init_resource4();
    init_stable_attributes4();
    init_stable_metrics4();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js
var require_enums = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExceptionEventName = void 0;
    exports2.ExceptionEventName = "exception";
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js
var require_Span = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Span = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var semantic_conventions_1 = (init_esm5(), __toCommonJS(esm_exports5));
    var enums_1 = require_enums();
    var Span = class {
      /**
       * Constructs a new Span instance.
       *
       * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
       * */
      constructor(parentTracer, context3, spanName, spanContext, kind, parentSpanId, links = [], startTime, _deprecatedClock, attributes) {
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
          code: api_1.SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        const now = Date.now();
        this._performanceStartTime = core_1.otperformance.now();
        this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
        if (attributes != null) {
          this.setAttributes(attributes);
        }
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context3);
      }
      spanContext() {
        return this._spanContext;
      }
      setAttribute(key, value) {
        if (value == null || this._isSpanEnded())
          return this;
        if (key.length === 0) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          return this;
        }
        if (!(0, core_1.isAttributeValue)(value)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          this._droppedAttributesCount++;
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      }
      setAttributes(attributes) {
        for (const [k, v] of Object.entries(attributes)) {
          this.setAttribute(k, v);
        }
        return this;
      }
      /**
       *
       * @param name Span Name
       * @param [attributesOrStartTime] Span attributes or start time
       *     if type is {@type TimeInput} and 3rd param is undefined
       * @param [timeStamp] Specified time stamp for the event
       */
      addEvent(name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded())
          return this;
        if (this._spanLimits.eventCountLimit === 0) {
          api_1.diag.warn("No events allowed.");
          this._droppedEventsCount++;
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          if (this._droppedEventsCount === 0) {
            api_1.diag.debug("Dropping extra events.");
          }
          this.events.shift();
          this._droppedEventsCount++;
        }
        if ((0, core_1.isTimeInput)(attributesOrStartTime)) {
          if (!(0, core_1.isTimeInput)(timeStamp)) {
            timeStamp = attributesOrStartTime;
          }
          attributesOrStartTime = void 0;
        }
        const attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
        this.events.push({
          name,
          attributes,
          time: this._getTime(timeStamp),
          droppedAttributesCount: 0
        });
        return this;
      }
      addLink(link) {
        this.links.push(link);
        return this;
      }
      addLinks(links) {
        this.links.push(...links);
        return this;
      }
      setStatus(status) {
        if (this._isSpanEnded())
          return this;
        this.status = Object.assign({}, status);
        if (this.status.message != null && typeof status.message !== "string") {
          api_1.diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);
          delete this.status.message;
        }
        return this;
      }
      updateName(name) {
        if (this._isSpanEnded())
          return this;
        this.name = name;
        return this;
      }
      end(endTime) {
        if (this._isSpanEnded()) {
          api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
          return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
          this.endTime = this.startTime.slice();
          this._duration = [0, 0];
        }
        if (this._droppedEventsCount > 0) {
          api_1.diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
        }
        this._spanProcessor.onEnd(this);
      }
      _getTime(inp) {
        if (typeof inp === "number" && inp <= core_1.otperformance.now()) {
          return (0, core_1.hrTime)(inp + this._performanceOffset);
        }
        if (typeof inp === "number") {
          return (0, core_1.millisToHrTime)(inp);
        }
        if (inp instanceof Date) {
          return (0, core_1.millisToHrTime)(inp.getTime());
        }
        if ((0, core_1.isTimeInputHrTime)(inp)) {
          return inp;
        }
        if (this._startTimeProvided) {
          return (0, core_1.millisToHrTime)(Date.now());
        }
        const msDuration = core_1.otperformance.now() - this._performanceStartTime;
        return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
      }
      isRecording() {
        return this._ended === false;
      }
      recordException(exception, time) {
        const attributes = {};
        if (typeof exception === "string") {
          attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        if (attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] || attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE]) {
          this.addEvent(enums_1.ExceptionEventName, attributes, time);
        } else {
          api_1.diag.warn(`Failed to record an exception ${exception}`);
        }
      }
      get duration() {
        return this._duration;
      }
      get ended() {
        return this._ended;
      }
      get droppedAttributesCount() {
        return this._droppedAttributesCount;
      }
      get droppedEventsCount() {
        return this._droppedEventsCount;
      }
      get droppedLinksCount() {
        return this._droppedLinksCount;
      }
      _isSpanEnded() {
        if (this._ended) {
          api_1.diag.warn(`Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
        }
        return this._ended;
      }
      // Utility function to truncate given value within size
      // for value type of string, will truncate to given limit
      // for type of non-string, will return same value
      _truncateToLimitUtil(value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substring(0, limit);
      }
      /**
       * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
       * return string with truncated to {@code attributeValueLengthLimit} characters
       *
       * If the given attribute value is array of strings then
       * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
       *
       * Otherwise return same Attribute {@code value}
       *
       * @param value Attribute value
       * @returns truncated attribute value if required, otherwise same value
       */
      _truncateToSize(value) {
        const limit = this._attributeValueLengthLimit;
        if (limit <= 0) {
          api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`);
          return value;
        }
        if (typeof value === "string") {
          return this._truncateToLimitUtil(value, limit);
        }
        if (Array.isArray(value)) {
          return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
        }
        return value;
      }
    };
    exports2.Span = Span;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js
var require_Sampler = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SamplingDecision = void 0;
    var SamplingDecision3;
    (function(SamplingDecision4) {
      SamplingDecision4[SamplingDecision4["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision4[SamplingDecision4["RECORD"] = 1] = "RECORD";
      SamplingDecision4[SamplingDecision4["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision3 = exports2.SamplingDecision || (exports2.SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOffSampler = void 0;
    var Sampler_1 = require_Sampler();
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOnSampler = void 0;
    var Sampler_1 = require_Sampler();
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js
var require_ParentBasedSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    var ParentBasedSampler = class {
      constructor(config2) {
        var _a, _b, _c, _d;
        this._root = config2.root;
        if (!this._root) {
          (0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config2.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config2.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Sampler_1 = require_Sampler();
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          const pos = i * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/config.js
var require_config = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSamplerFromEnv = exports2.loadDefaultConfig = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    var ParentBasedSampler_1 = require_ParentBasedSampler2();
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
    var FALLBACK_OTEL_TRACES_SAMPLER = core_1.TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    function loadDefaultConfig() {
      const env = (0, core_1.getEnv)();
      return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 3e4,
        generalLimits: {
          attributeValueLengthLimit: env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: env.OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
          attributeValueLengthLimit: env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
          linkCountLimit: env.OTEL_SPAN_LINK_COUNT_LIMIT,
          eventCountLimit: env.OTEL_SPAN_EVENT_COUNT_LIMIT,
          attributePerEventCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
          attributePerLinkCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        },
        mergeResourceWithDefaults: true
      };
    }
    exports2.loadDefaultConfig = loadDefaultConfig;
    function buildSamplerFromEnv(environment = (0, core_1.getEnv)()) {
      switch (environment.OTEL_TRACES_SAMPLER) {
        case core_1.TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler_1.AlwaysOnSampler();
        case core_1.TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler_1.AlwaysOffSampler();
        case core_1.TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new AlwaysOnSampler_1.AlwaysOnSampler()
          });
        case core_1.TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new AlwaysOffSampler_1.AlwaysOffSampler()
          });
        case core_1.TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case core_1.TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
          });
        default:
          api_1.diag.error(`OTEL_TRACES_SAMPLER value "${environment.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}".`);
          return new AlwaysOnSampler_1.AlwaysOnSampler();
      }
    }
    exports2.buildSamplerFromEnv = buildSamplerFromEnv;
    function getSamplerProbabilityFromEnv(environment) {
      if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === "") {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      const probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      return probability;
    }
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js
var require_utility = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reconfigureLimits = exports2.mergeConfig = void 0;
    var config_1 = require_config();
    var core_1 = require_src();
    function mergeConfig(userConfig) {
      const perInstanceDefaults = {
        sampler: (0, config_1.buildSamplerFromEnv)()
      };
      const DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)();
      const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    exports2.mergeConfig = mergeConfig;
    function reconfigureLimits(userConfig) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const spanLimits = Object.assign({}, userConfig.spanLimits);
      const parsedEnvConfig = (0, core_1.getEnvWithoutDefaults)();
      spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : core_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
      spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : core_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
      return Object.assign({}, userConfig, { spanLimits });
    }
    exports2.reconfigureLimits = reconfigureLimits;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js
var require_BatchSpanProcessorBase = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BatchSpanProcessorBase = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var BatchSpanProcessorBase = class {
      constructor(_exporter, config2) {
        this._exporter = _exporter;
        this._isExporting = false;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        const env = (0, core_1.getEnv)();
        this._maxExportBatchSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxExportBatchSize) === "number" ? config2.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxQueueSize) === "number" ? config2.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.scheduledDelayMillis) === "number" ? config2.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.exportTimeoutMillis) === "number" ? config2.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
          api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
          this._maxExportBatchSize = this._maxQueueSize;
        }
      }
      forceFlush() {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      }
      // does nothing.
      onStart(_span, _parentContext) {
      }
      onEnd(span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return Promise.resolve().then(() => {
          return this.onShutdown();
        }).then(() => {
          return this._flushAll();
        }).then(() => {
          return this._exporter.shutdown();
        });
      }
      /** Add a span in the buffer. */
      _addToBuffer(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          if (this._droppedSpansCount === 0) {
            api_1.diag.debug("maxQueueSize reached, dropping spans");
          }
          this._droppedSpansCount++;
          return;
        }
        if (this._droppedSpansCount > 0) {
          api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
          this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      }
      /**
       * Send all spans to the exporter respecting the batch size limit
       * This function is used only on forceFlush or shutdown,
       * for all other cases _flush should be used
       * */
      _flushAll() {
        return new Promise((resolve2, reject) => {
          const promises = [];
          const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
          for (let i = 0, j = count; i < j; i++) {
            promises.push(this._flushOneBatch());
          }
          Promise.all(promises).then(() => {
            resolve2();
          }).catch(reject);
        });
      }
      _flushOneBatch() {
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise((resolve2, reject) => {
          const timer = setTimeout(() => {
            reject(new Error("Timeout"));
          }, this._exportTimeoutMillis);
          api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            let spans;
            if (this._finishedSpans.length <= this._maxExportBatchSize) {
              spans = this._finishedSpans;
              this._finishedSpans = [];
            } else {
              spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
            }
            const doExport = () => this._exporter.export(spans, (result) => {
              var _a;
              clearTimeout(timer);
              if (result.code === core_1.ExportResultCode.SUCCESS) {
                resolve2();
              } else {
                reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error("BatchSpanProcessor: span export failed"));
              }
            });
            let pendingResources = null;
            for (let i = 0, len = spans.length; i < len; i++) {
              const span = spans[i];
              if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
                pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];
                pendingResources.push(span.resource.waitForAsyncAttributes());
              }
            }
            if (pendingResources === null) {
              doExport();
            } else {
              Promise.all(pendingResources).then(doExport, (err) => {
                (0, core_1.globalErrorHandler)(err);
                reject(err);
              });
            }
          });
        });
      }
      _maybeStartTimer() {
        if (this._isExporting)
          return;
        const flush2 = () => {
          this._isExporting = true;
          this._flushOneBatch().finally(() => {
            this._isExporting = false;
            if (this._finishedSpans.length > 0) {
              this._clearTimer();
              this._maybeStartTimer();
            }
          }).catch((e) => {
            this._isExporting = false;
            (0, core_1.globalErrorHandler)(e);
          });
        };
        if (this._finishedSpans.length >= this._maxExportBatchSize) {
          return flush2();
        }
        if (this._timer !== void 0)
          return;
        this._timer = setTimeout(() => flush2(), this._scheduledDelayMillis);
        (0, core_1.unrefTimer)(this._timer);
      }
      _clearTimer() {
        if (this._timer !== void 0) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
      }
    };
    exports2.BatchSpanProcessorBase = BatchSpanProcessorBase;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js
var require_BatchSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BatchSpanProcessor = void 0;
    var BatchSpanProcessorBase_1 = require_BatchSpanProcessorBase();
    var BatchSpanProcessor = class extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
      onShutdown() {
      }
    };
    exports2.BatchSpanProcessor = BatchSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        }
        for (let i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js
var require_node5 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = exports2.BatchSpanProcessor = void 0;
    var BatchSpanProcessor_1 = require_BatchSpanProcessor();
    Object.defineProperty(exports2, "BatchSpanProcessor", { enumerable: true, get: function() {
      return BatchSpanProcessor_1.BatchSpanProcessor;
    } });
    var RandomIdGenerator_1 = require_RandomIdGenerator2();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return RandomIdGenerator_1.RandomIdGenerator;
    } });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js
var require_platform4 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = exports2.BatchSpanProcessor = void 0;
    var node_1 = require_node5();
    Object.defineProperty(exports2, "BatchSpanProcessor", { enumerable: true, get: function() {
      return node_1.BatchSpanProcessor;
    } });
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return node_1.RandomIdGenerator;
    } });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js
var require_Tracer = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tracer = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var Span_1 = require_Span();
    var utility_1 = require_utility();
    var platform_1 = require_platform4();
    var Tracer = class {
      /**
       * Constructs a new Tracer instance.
       */
      constructor(instrumentationLibrary, config2, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        const localConfig = (0, utility_1.mergeConfig)(config2);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config2.idGenerator || new platform_1.RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      /**
       * Starts a new Span or returns the default NoopSpan based on the sampling
       * decision.
       */
      startSpan(name, options = {}, context3 = api.context.active()) {
        var _a, _b, _c;
        if (options.root) {
          context3 = api.trace.deleteSpan(context3);
        }
        const parentSpan = api.trace.getSpan(context3);
        if ((0, core_1.isTracingSuppressed)(context3)) {
          api.diag.debug("Instrumentation suppressed, returning Noop Span");
          const nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
          return nonRecordingSpan;
        }
        const parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        const spanId = this._idGenerator.generateSpanId();
        let traceId;
        let traceState;
        let parentSpanId;
        if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
          traceId = this._idGenerator.generateTraceId();
        } else {
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        const spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;
        const links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map((link) => {
          return {
            context: link.context,
            attributes: (0, core_1.sanitizeAttributes)(link.attributes)
          };
        });
        const attributes = (0, core_1.sanitizeAttributes)(options.attributes);
        const samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
        const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
          api.diag.debug("Recording is off, propagating context in a non-recording span");
          const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
          return nonRecordingSpan;
        }
        const initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
        const span = new Span_1.Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime, void 0, initAttributes);
        return span;
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();
        const span = this.startSpan(name, opts, parentContext);
        const contextWithSpanSet = api.trace.setSpan(parentContext, span);
        return api.context.with(contextWithSpanSet, fn, void 0, span);
      }
      /** Returns the active {@link GeneralLimits}. */
      getGeneralLimits() {
        return this._generalLimits;
      }
      /** Returns the active {@link SpanLimits}. */
      getSpanLimits() {
        return this._spanLimits;
      }
      getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
      }
    };
    exports2.Tracer = Tracer;
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap5(values) {
  var res = {};
  var len = values.length;
  for (var lp = 0; lp < len; lp++) {
    var val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils7 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN5, TMP_DB_SYSTEM5, TMP_DB_CONNECTION_STRING5, TMP_DB_USER5, TMP_DB_JDBC_DRIVER_CLASSNAME5, TMP_DB_NAME5, TMP_DB_STATEMENT5, TMP_DB_OPERATION5, TMP_DB_MSSQL_INSTANCE_NAME5, TMP_DB_CASSANDRA_KEYSPACE5, TMP_DB_CASSANDRA_PAGE_SIZE5, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL5, TMP_DB_CASSANDRA_TABLE5, TMP_DB_CASSANDRA_IDEMPOTENCE5, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5, TMP_DB_CASSANDRA_COORDINATOR_ID5, TMP_DB_CASSANDRA_COORDINATOR_DC5, TMP_DB_HBASE_NAMESPACE5, TMP_DB_REDIS_DATABASE_INDEX5, TMP_DB_MONGODB_COLLECTION5, TMP_DB_SQL_TABLE5, TMP_EXCEPTION_TYPE5, TMP_EXCEPTION_MESSAGE5, TMP_EXCEPTION_STACKTRACE5, TMP_EXCEPTION_ESCAPED5, TMP_FAAS_TRIGGER5, TMP_FAAS_EXECUTION5, TMP_FAAS_DOCUMENT_COLLECTION5, TMP_FAAS_DOCUMENT_OPERATION5, TMP_FAAS_DOCUMENT_TIME5, TMP_FAAS_DOCUMENT_NAME5, TMP_FAAS_TIME5, TMP_FAAS_CRON5, TMP_FAAS_COLDSTART5, TMP_FAAS_INVOKED_NAME5, TMP_FAAS_INVOKED_PROVIDER5, TMP_FAAS_INVOKED_REGION5, TMP_NET_TRANSPORT5, TMP_NET_PEER_IP5, TMP_NET_PEER_PORT5, TMP_NET_PEER_NAME5, TMP_NET_HOST_IP5, TMP_NET_HOST_PORT5, TMP_NET_HOST_NAME5, TMP_NET_HOST_CONNECTION_TYPE5, TMP_NET_HOST_CONNECTION_SUBTYPE5, TMP_NET_HOST_CARRIER_NAME5, TMP_NET_HOST_CARRIER_MCC5, TMP_NET_HOST_CARRIER_MNC5, TMP_NET_HOST_CARRIER_ICC5, TMP_PEER_SERVICE5, TMP_ENDUSER_ID5, TMP_ENDUSER_ROLE5, TMP_ENDUSER_SCOPE5, TMP_THREAD_ID5, TMP_THREAD_NAME5, TMP_CODE_FUNCTION5, TMP_CODE_NAMESPACE5, TMP_CODE_FILEPATH5, TMP_CODE_LINENO5, TMP_HTTP_METHOD5, TMP_HTTP_URL5, TMP_HTTP_TARGET5, TMP_HTTP_HOST5, TMP_HTTP_SCHEME5, TMP_HTTP_STATUS_CODE5, TMP_HTTP_FLAVOR5, TMP_HTTP_USER_AGENT5, TMP_HTTP_REQUEST_CONTENT_LENGTH5, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5, TMP_HTTP_RESPONSE_CONTENT_LENGTH5, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5, TMP_HTTP_SERVER_NAME5, TMP_HTTP_ROUTE5, TMP_HTTP_CLIENT_IP5, TMP_AWS_DYNAMODB_TABLE_NAMES5, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY5, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5, TMP_AWS_DYNAMODB_CONSISTENT_READ5, TMP_AWS_DYNAMODB_PROJECTION5, TMP_AWS_DYNAMODB_LIMIT5, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET5, TMP_AWS_DYNAMODB_INDEX_NAME5, TMP_AWS_DYNAMODB_SELECT5, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5, TMP_AWS_DYNAMODB_TABLE_COUNT5, TMP_AWS_DYNAMODB_SCAN_FORWARD5, TMP_AWS_DYNAMODB_SEGMENT5, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS5, TMP_AWS_DYNAMODB_COUNT5, TMP_AWS_DYNAMODB_SCANNED_COUNT5, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5, TMP_MESSAGING_SYSTEM5, TMP_MESSAGING_DESTINATION5, TMP_MESSAGING_DESTINATION_KIND5, TMP_MESSAGING_TEMP_DESTINATION5, TMP_MESSAGING_PROTOCOL5, TMP_MESSAGING_PROTOCOL_VERSION5, TMP_MESSAGING_URL5, TMP_MESSAGING_MESSAGE_ID5, TMP_MESSAGING_CONVERSATION_ID5, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5, TMP_MESSAGING_OPERATION5, TMP_MESSAGING_CONSUMER_ID5, TMP_MESSAGING_RABBITMQ_ROUTING_KEY5, TMP_MESSAGING_KAFKA_MESSAGE_KEY5, TMP_MESSAGING_KAFKA_CONSUMER_GROUP5, TMP_MESSAGING_KAFKA_CLIENT_ID5, TMP_MESSAGING_KAFKA_PARTITION5, TMP_MESSAGING_KAFKA_TOMBSTONE5, TMP_RPC_SYSTEM5, TMP_RPC_SERVICE5, TMP_RPC_METHOD5, TMP_RPC_GRPC_STATUS_CODE5, TMP_RPC_JSONRPC_VERSION5, TMP_RPC_JSONRPC_REQUEST_ID5, TMP_RPC_JSONRPC_ERROR_CODE5, TMP_RPC_JSONRPC_ERROR_MESSAGE5, TMP_MESSAGE_TYPE5, TMP_MESSAGE_ID5, TMP_MESSAGE_COMPRESSED_SIZE5, TMP_MESSAGE_UNCOMPRESSED_SIZE5, SEMATTRS_AWS_LAMBDA_INVOKED_ARN5, SEMATTRS_DB_SYSTEM5, SEMATTRS_DB_CONNECTION_STRING5, SEMATTRS_DB_USER5, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME5, SEMATTRS_DB_NAME5, SEMATTRS_DB_STATEMENT5, SEMATTRS_DB_OPERATION5, SEMATTRS_DB_MSSQL_INSTANCE_NAME5, SEMATTRS_DB_CASSANDRA_KEYSPACE5, SEMATTRS_DB_CASSANDRA_PAGE_SIZE5, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL5, SEMATTRS_DB_CASSANDRA_TABLE5, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE5, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID5, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC5, SEMATTRS_DB_HBASE_NAMESPACE5, SEMATTRS_DB_REDIS_DATABASE_INDEX5, SEMATTRS_DB_MONGODB_COLLECTION5, SEMATTRS_DB_SQL_TABLE5, SEMATTRS_EXCEPTION_TYPE5, SEMATTRS_EXCEPTION_MESSAGE5, SEMATTRS_EXCEPTION_STACKTRACE5, SEMATTRS_EXCEPTION_ESCAPED5, SEMATTRS_FAAS_TRIGGER5, SEMATTRS_FAAS_EXECUTION5, SEMATTRS_FAAS_DOCUMENT_COLLECTION5, SEMATTRS_FAAS_DOCUMENT_OPERATION5, SEMATTRS_FAAS_DOCUMENT_TIME5, SEMATTRS_FAAS_DOCUMENT_NAME5, SEMATTRS_FAAS_TIME5, SEMATTRS_FAAS_CRON5, SEMATTRS_FAAS_COLDSTART5, SEMATTRS_FAAS_INVOKED_NAME5, SEMATTRS_FAAS_INVOKED_PROVIDER5, SEMATTRS_FAAS_INVOKED_REGION5, SEMATTRS_NET_TRANSPORT5, SEMATTRS_NET_PEER_IP5, SEMATTRS_NET_PEER_PORT5, SEMATTRS_NET_PEER_NAME5, SEMATTRS_NET_HOST_IP5, SEMATTRS_NET_HOST_PORT5, SEMATTRS_NET_HOST_NAME5, SEMATTRS_NET_HOST_CONNECTION_TYPE5, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE5, SEMATTRS_NET_HOST_CARRIER_NAME5, SEMATTRS_NET_HOST_CARRIER_MCC5, SEMATTRS_NET_HOST_CARRIER_MNC5, SEMATTRS_NET_HOST_CARRIER_ICC5, SEMATTRS_PEER_SERVICE5, SEMATTRS_ENDUSER_ID5, SEMATTRS_ENDUSER_ROLE5, SEMATTRS_ENDUSER_SCOPE5, SEMATTRS_THREAD_ID5, SEMATTRS_THREAD_NAME5, SEMATTRS_CODE_FUNCTION5, SEMATTRS_CODE_NAMESPACE5, SEMATTRS_CODE_FILEPATH5, SEMATTRS_CODE_LINENO5, SEMATTRS_HTTP_METHOD5, SEMATTRS_HTTP_URL5, SEMATTRS_HTTP_TARGET5, SEMATTRS_HTTP_HOST5, SEMATTRS_HTTP_SCHEME5, SEMATTRS_HTTP_STATUS_CODE5, SEMATTRS_HTTP_FLAVOR5, SEMATTRS_HTTP_USER_AGENT5, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH5, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH5, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5, SEMATTRS_HTTP_SERVER_NAME5, SEMATTRS_HTTP_ROUTE5, SEMATTRS_HTTP_CLIENT_IP5, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES5, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY5, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ5, SEMATTRS_AWS_DYNAMODB_PROJECTION5, SEMATTRS_AWS_DYNAMODB_LIMIT5, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET5, SEMATTRS_AWS_DYNAMODB_INDEX_NAME5, SEMATTRS_AWS_DYNAMODB_SELECT5, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT5, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD5, SEMATTRS_AWS_DYNAMODB_SEGMENT5, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS5, SEMATTRS_AWS_DYNAMODB_COUNT5, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT5, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5, SEMATTRS_MESSAGING_SYSTEM5, SEMATTRS_MESSAGING_DESTINATION5, SEMATTRS_MESSAGING_DESTINATION_KIND5, SEMATTRS_MESSAGING_TEMP_DESTINATION5, SEMATTRS_MESSAGING_PROTOCOL5, SEMATTRS_MESSAGING_PROTOCOL_VERSION5, SEMATTRS_MESSAGING_URL5, SEMATTRS_MESSAGING_MESSAGE_ID5, SEMATTRS_MESSAGING_CONVERSATION_ID5, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5, SEMATTRS_MESSAGING_OPERATION5, SEMATTRS_MESSAGING_CONSUMER_ID5, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY5, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY5, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP5, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID5, SEMATTRS_MESSAGING_KAFKA_PARTITION5, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE5, SEMATTRS_RPC_SYSTEM5, SEMATTRS_RPC_SERVICE5, SEMATTRS_RPC_METHOD5, SEMATTRS_RPC_GRPC_STATUS_CODE5, SEMATTRS_RPC_JSONRPC_VERSION5, SEMATTRS_RPC_JSONRPC_REQUEST_ID5, SEMATTRS_RPC_JSONRPC_ERROR_CODE5, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE5, SEMATTRS_MESSAGE_TYPE5, SEMATTRS_MESSAGE_ID5, SEMATTRS_MESSAGE_COMPRESSED_SIZE5, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE5, SemanticAttributes5, TMP_DBSYSTEMVALUES_OTHER_SQL5, TMP_DBSYSTEMVALUES_MSSQL5, TMP_DBSYSTEMVALUES_MYSQL5, TMP_DBSYSTEMVALUES_ORACLE5, TMP_DBSYSTEMVALUES_DB25, TMP_DBSYSTEMVALUES_POSTGRESQL5, TMP_DBSYSTEMVALUES_REDSHIFT5, TMP_DBSYSTEMVALUES_HIVE5, TMP_DBSYSTEMVALUES_CLOUDSCAPE5, TMP_DBSYSTEMVALUES_HSQLDB5, TMP_DBSYSTEMVALUES_PROGRESS5, TMP_DBSYSTEMVALUES_MAXDB5, TMP_DBSYSTEMVALUES_HANADB5, TMP_DBSYSTEMVALUES_INGRES5, TMP_DBSYSTEMVALUES_FIRSTSQL5, TMP_DBSYSTEMVALUES_EDB5, TMP_DBSYSTEMVALUES_CACHE5, TMP_DBSYSTEMVALUES_ADABAS5, TMP_DBSYSTEMVALUES_FIREBIRD5, TMP_DBSYSTEMVALUES_DERBY5, TMP_DBSYSTEMVALUES_FILEMAKER5, TMP_DBSYSTEMVALUES_INFORMIX5, TMP_DBSYSTEMVALUES_INSTANTDB5, TMP_DBSYSTEMVALUES_INTERBASE5, TMP_DBSYSTEMVALUES_MARIADB5, TMP_DBSYSTEMVALUES_NETEZZA5, TMP_DBSYSTEMVALUES_PERVASIVE5, TMP_DBSYSTEMVALUES_POINTBASE5, TMP_DBSYSTEMVALUES_SQLITE5, TMP_DBSYSTEMVALUES_SYBASE5, TMP_DBSYSTEMVALUES_TERADATA5, TMP_DBSYSTEMVALUES_VERTICA5, TMP_DBSYSTEMVALUES_H25, TMP_DBSYSTEMVALUES_COLDFUSION5, TMP_DBSYSTEMVALUES_CASSANDRA5, TMP_DBSYSTEMVALUES_HBASE5, TMP_DBSYSTEMVALUES_MONGODB5, TMP_DBSYSTEMVALUES_REDIS5, TMP_DBSYSTEMVALUES_COUCHBASE5, TMP_DBSYSTEMVALUES_COUCHDB5, TMP_DBSYSTEMVALUES_COSMOSDB5, TMP_DBSYSTEMVALUES_DYNAMODB5, TMP_DBSYSTEMVALUES_NEO4J5, TMP_DBSYSTEMVALUES_GEODE5, TMP_DBSYSTEMVALUES_ELASTICSEARCH5, TMP_DBSYSTEMVALUES_MEMCACHED5, TMP_DBSYSTEMVALUES_COCKROACHDB5, DBSYSTEMVALUES_OTHER_SQL5, DBSYSTEMVALUES_MSSQL5, DBSYSTEMVALUES_MYSQL5, DBSYSTEMVALUES_ORACLE5, DBSYSTEMVALUES_DB25, DBSYSTEMVALUES_POSTGRESQL5, DBSYSTEMVALUES_REDSHIFT5, DBSYSTEMVALUES_HIVE5, DBSYSTEMVALUES_CLOUDSCAPE5, DBSYSTEMVALUES_HSQLDB5, DBSYSTEMVALUES_PROGRESS5, DBSYSTEMVALUES_MAXDB5, DBSYSTEMVALUES_HANADB5, DBSYSTEMVALUES_INGRES5, DBSYSTEMVALUES_FIRSTSQL5, DBSYSTEMVALUES_EDB5, DBSYSTEMVALUES_CACHE5, DBSYSTEMVALUES_ADABAS5, DBSYSTEMVALUES_FIREBIRD5, DBSYSTEMVALUES_DERBY5, DBSYSTEMVALUES_FILEMAKER5, DBSYSTEMVALUES_INFORMIX5, DBSYSTEMVALUES_INSTANTDB5, DBSYSTEMVALUES_INTERBASE5, DBSYSTEMVALUES_MARIADB5, DBSYSTEMVALUES_NETEZZA5, DBSYSTEMVALUES_PERVASIVE5, DBSYSTEMVALUES_POINTBASE5, DBSYSTEMVALUES_SQLITE5, DBSYSTEMVALUES_SYBASE5, DBSYSTEMVALUES_TERADATA5, DBSYSTEMVALUES_VERTICA5, DBSYSTEMVALUES_H25, DBSYSTEMVALUES_COLDFUSION5, DBSYSTEMVALUES_CASSANDRA5, DBSYSTEMVALUES_HBASE5, DBSYSTEMVALUES_MONGODB5, DBSYSTEMVALUES_REDIS5, DBSYSTEMVALUES_COUCHBASE5, DBSYSTEMVALUES_COUCHDB5, DBSYSTEMVALUES_COSMOSDB5, DBSYSTEMVALUES_DYNAMODB5, DBSYSTEMVALUES_NEO4J5, DBSYSTEMVALUES_GEODE5, DBSYSTEMVALUES_ELASTICSEARCH5, DBSYSTEMVALUES_MEMCACHED5, DBSYSTEMVALUES_COCKROACHDB5, DbSystemValues5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5, DBCASSANDRACONSISTENCYLEVELVALUES_ALL5, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5, DBCASSANDRACONSISTENCYLEVELVALUES_ONE5, DBCASSANDRACONSISTENCYLEVELVALUES_TWO5, DBCASSANDRACONSISTENCYLEVELVALUES_THREE5, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5, DBCASSANDRACONSISTENCYLEVELVALUES_ANY5, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5, DbCassandraConsistencyLevelValues5, TMP_FAASTRIGGERVALUES_DATASOURCE5, TMP_FAASTRIGGERVALUES_HTTP5, TMP_FAASTRIGGERVALUES_PUBSUB5, TMP_FAASTRIGGERVALUES_TIMER5, TMP_FAASTRIGGERVALUES_OTHER5, FAASTRIGGERVALUES_DATASOURCE5, FAASTRIGGERVALUES_HTTP5, FAASTRIGGERVALUES_PUBSUB5, FAASTRIGGERVALUES_TIMER5, FAASTRIGGERVALUES_OTHER5, FaasTriggerValues5, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT5, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT5, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE5, FAASDOCUMENTOPERATIONVALUES_INSERT5, FAASDOCUMENTOPERATIONVALUES_EDIT5, FAASDOCUMENTOPERATIONVALUES_DELETE5, FaasDocumentOperationValues5, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5, TMP_FAASINVOKEDPROVIDERVALUES_AWS5, TMP_FAASINVOKEDPROVIDERVALUES_AZURE5, TMP_FAASINVOKEDPROVIDERVALUES_GCP5, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5, FAASINVOKEDPROVIDERVALUES_AWS5, FAASINVOKEDPROVIDERVALUES_AZURE5, FAASINVOKEDPROVIDERVALUES_GCP5, FaasInvokedProviderValues5, TMP_NETTRANSPORTVALUES_IP_TCP5, TMP_NETTRANSPORTVALUES_IP_UDP5, TMP_NETTRANSPORTVALUES_IP5, TMP_NETTRANSPORTVALUES_UNIX5, TMP_NETTRANSPORTVALUES_PIPE5, TMP_NETTRANSPORTVALUES_INPROC5, TMP_NETTRANSPORTVALUES_OTHER5, NETTRANSPORTVALUES_IP_TCP5, NETTRANSPORTVALUES_IP_UDP5, NETTRANSPORTVALUES_IP5, NETTRANSPORTVALUES_UNIX5, NETTRANSPORTVALUES_PIPE5, NETTRANSPORTVALUES_INPROC5, NETTRANSPORTVALUES_OTHER5, NetTransportValues5, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI5, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED5, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL5, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5, NETHOSTCONNECTIONTYPEVALUES_WIFI5, NETHOSTCONNECTIONTYPEVALUES_WIRED5, NETHOSTCONNECTIONTYPEVALUES_CELL5, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5, NetHostConnectionTypeValues5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5, NETHOSTCONNECTIONSUBTYPEVALUES_LTE5, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5, NETHOSTCONNECTIONSUBTYPEVALUES_GSM5, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5, NETHOSTCONNECTIONSUBTYPEVALUES_NR5, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5, NetHostConnectionSubtypeValues5, TMP_HTTPFLAVORVALUES_HTTP_1_05, TMP_HTTPFLAVORVALUES_HTTP_1_15, TMP_HTTPFLAVORVALUES_HTTP_2_05, TMP_HTTPFLAVORVALUES_SPDY5, TMP_HTTPFLAVORVALUES_QUIC5, HTTPFLAVORVALUES_HTTP_1_05, HTTPFLAVORVALUES_HTTP_1_15, HTTPFLAVORVALUES_HTTP_2_05, HTTPFLAVORVALUES_SPDY5, HTTPFLAVORVALUES_QUIC5, HttpFlavorValues5, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE5, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC5, MESSAGINGDESTINATIONKINDVALUES_QUEUE5, MESSAGINGDESTINATIONKINDVALUES_TOPIC5, MessagingDestinationKindValues5, TMP_MESSAGINGOPERATIONVALUES_RECEIVE5, TMP_MESSAGINGOPERATIONVALUES_PROCESS5, MESSAGINGOPERATIONVALUES_RECEIVE5, MESSAGINGOPERATIONVALUES_PROCESS5, MessagingOperationValues5, TMP_RPCGRPCSTATUSCODEVALUES_OK5, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED5, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN5, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND5, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED5, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL5, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS5, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5, RPCGRPCSTATUSCODEVALUES_OK5, RPCGRPCSTATUSCODEVALUES_CANCELLED5, RPCGRPCSTATUSCODEVALUES_UNKNOWN5, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5, RPCGRPCSTATUSCODEVALUES_NOT_FOUND5, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5, RPCGRPCSTATUSCODEVALUES_ABORTED5, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5, RPCGRPCSTATUSCODEVALUES_INTERNAL5, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5, RPCGRPCSTATUSCODEVALUES_DATA_LOSS5, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5, RpcGrpcStatusCodeValues5, TMP_MESSAGETYPEVALUES_SENT5, TMP_MESSAGETYPEVALUES_RECEIVED5, MESSAGETYPEVALUES_SENT5, MESSAGETYPEVALUES_RECEIVED5, MessageTypeValues5;
var init_SemanticAttributes5 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils7();
    TMP_AWS_LAMBDA_INVOKED_ARN5 = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM5 = "db.system";
    TMP_DB_CONNECTION_STRING5 = "db.connection_string";
    TMP_DB_USER5 = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME5 = "db.jdbc.driver_classname";
    TMP_DB_NAME5 = "db.name";
    TMP_DB_STATEMENT5 = "db.statement";
    TMP_DB_OPERATION5 = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME5 = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE5 = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE5 = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL5 = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE5 = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE5 = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5 = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID5 = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC5 = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE5 = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX5 = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION5 = "db.mongodb.collection";
    TMP_DB_SQL_TABLE5 = "db.sql.table";
    TMP_EXCEPTION_TYPE5 = "exception.type";
    TMP_EXCEPTION_MESSAGE5 = "exception.message";
    TMP_EXCEPTION_STACKTRACE5 = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED5 = "exception.escaped";
    TMP_FAAS_TRIGGER5 = "faas.trigger";
    TMP_FAAS_EXECUTION5 = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION5 = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION5 = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME5 = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME5 = "faas.document.name";
    TMP_FAAS_TIME5 = "faas.time";
    TMP_FAAS_CRON5 = "faas.cron";
    TMP_FAAS_COLDSTART5 = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME5 = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER5 = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION5 = "faas.invoked_region";
    TMP_NET_TRANSPORT5 = "net.transport";
    TMP_NET_PEER_IP5 = "net.peer.ip";
    TMP_NET_PEER_PORT5 = "net.peer.port";
    TMP_NET_PEER_NAME5 = "net.peer.name";
    TMP_NET_HOST_IP5 = "net.host.ip";
    TMP_NET_HOST_PORT5 = "net.host.port";
    TMP_NET_HOST_NAME5 = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE5 = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE5 = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME5 = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC5 = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC5 = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC5 = "net.host.carrier.icc";
    TMP_PEER_SERVICE5 = "peer.service";
    TMP_ENDUSER_ID5 = "enduser.id";
    TMP_ENDUSER_ROLE5 = "enduser.role";
    TMP_ENDUSER_SCOPE5 = "enduser.scope";
    TMP_THREAD_ID5 = "thread.id";
    TMP_THREAD_NAME5 = "thread.name";
    TMP_CODE_FUNCTION5 = "code.function";
    TMP_CODE_NAMESPACE5 = "code.namespace";
    TMP_CODE_FILEPATH5 = "code.filepath";
    TMP_CODE_LINENO5 = "code.lineno";
    TMP_HTTP_METHOD5 = "http.method";
    TMP_HTTP_URL5 = "http.url";
    TMP_HTTP_TARGET5 = "http.target";
    TMP_HTTP_HOST5 = "http.host";
    TMP_HTTP_SCHEME5 = "http.scheme";
    TMP_HTTP_STATUS_CODE5 = "http.status_code";
    TMP_HTTP_FLAVOR5 = "http.flavor";
    TMP_HTTP_USER_AGENT5 = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH5 = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5 = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH5 = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5 = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME5 = "http.server_name";
    TMP_HTTP_ROUTE5 = "http.route";
    TMP_HTTP_CLIENT_IP5 = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES5 = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY5 = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5 = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5 = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5 = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ5 = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION5 = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT5 = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET5 = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME5 = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT5 = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5 = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5 = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5 = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT5 = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD5 = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT5 = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS5 = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT5 = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT5 = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5 = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5 = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM5 = "messaging.system";
    TMP_MESSAGING_DESTINATION5 = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND5 = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION5 = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL5 = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION5 = "messaging.protocol_version";
    TMP_MESSAGING_URL5 = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID5 = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID5 = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5 = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5 = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION5 = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID5 = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY5 = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY5 = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP5 = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID5 = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION5 = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE5 = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM5 = "rpc.system";
    TMP_RPC_SERVICE5 = "rpc.service";
    TMP_RPC_METHOD5 = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE5 = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION5 = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID5 = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE5 = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE5 = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE5 = "message.type";
    TMP_MESSAGE_ID5 = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE5 = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE5 = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN5 = TMP_AWS_LAMBDA_INVOKED_ARN5;
    SEMATTRS_DB_SYSTEM5 = TMP_DB_SYSTEM5;
    SEMATTRS_DB_CONNECTION_STRING5 = TMP_DB_CONNECTION_STRING5;
    SEMATTRS_DB_USER5 = TMP_DB_USER5;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME5 = TMP_DB_JDBC_DRIVER_CLASSNAME5;
    SEMATTRS_DB_NAME5 = TMP_DB_NAME5;
    SEMATTRS_DB_STATEMENT5 = TMP_DB_STATEMENT5;
    SEMATTRS_DB_OPERATION5 = TMP_DB_OPERATION5;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME5 = TMP_DB_MSSQL_INSTANCE_NAME5;
    SEMATTRS_DB_CASSANDRA_KEYSPACE5 = TMP_DB_CASSANDRA_KEYSPACE5;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE5 = TMP_DB_CASSANDRA_PAGE_SIZE5;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL5 = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL5;
    SEMATTRS_DB_CASSANDRA_TABLE5 = TMP_DB_CASSANDRA_TABLE5;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE5 = TMP_DB_CASSANDRA_IDEMPOTENCE5;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5 = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID5 = TMP_DB_CASSANDRA_COORDINATOR_ID5;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC5 = TMP_DB_CASSANDRA_COORDINATOR_DC5;
    SEMATTRS_DB_HBASE_NAMESPACE5 = TMP_DB_HBASE_NAMESPACE5;
    SEMATTRS_DB_REDIS_DATABASE_INDEX5 = TMP_DB_REDIS_DATABASE_INDEX5;
    SEMATTRS_DB_MONGODB_COLLECTION5 = TMP_DB_MONGODB_COLLECTION5;
    SEMATTRS_DB_SQL_TABLE5 = TMP_DB_SQL_TABLE5;
    SEMATTRS_EXCEPTION_TYPE5 = TMP_EXCEPTION_TYPE5;
    SEMATTRS_EXCEPTION_MESSAGE5 = TMP_EXCEPTION_MESSAGE5;
    SEMATTRS_EXCEPTION_STACKTRACE5 = TMP_EXCEPTION_STACKTRACE5;
    SEMATTRS_EXCEPTION_ESCAPED5 = TMP_EXCEPTION_ESCAPED5;
    SEMATTRS_FAAS_TRIGGER5 = TMP_FAAS_TRIGGER5;
    SEMATTRS_FAAS_EXECUTION5 = TMP_FAAS_EXECUTION5;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION5 = TMP_FAAS_DOCUMENT_COLLECTION5;
    SEMATTRS_FAAS_DOCUMENT_OPERATION5 = TMP_FAAS_DOCUMENT_OPERATION5;
    SEMATTRS_FAAS_DOCUMENT_TIME5 = TMP_FAAS_DOCUMENT_TIME5;
    SEMATTRS_FAAS_DOCUMENT_NAME5 = TMP_FAAS_DOCUMENT_NAME5;
    SEMATTRS_FAAS_TIME5 = TMP_FAAS_TIME5;
    SEMATTRS_FAAS_CRON5 = TMP_FAAS_CRON5;
    SEMATTRS_FAAS_COLDSTART5 = TMP_FAAS_COLDSTART5;
    SEMATTRS_FAAS_INVOKED_NAME5 = TMP_FAAS_INVOKED_NAME5;
    SEMATTRS_FAAS_INVOKED_PROVIDER5 = TMP_FAAS_INVOKED_PROVIDER5;
    SEMATTRS_FAAS_INVOKED_REGION5 = TMP_FAAS_INVOKED_REGION5;
    SEMATTRS_NET_TRANSPORT5 = TMP_NET_TRANSPORT5;
    SEMATTRS_NET_PEER_IP5 = TMP_NET_PEER_IP5;
    SEMATTRS_NET_PEER_PORT5 = TMP_NET_PEER_PORT5;
    SEMATTRS_NET_PEER_NAME5 = TMP_NET_PEER_NAME5;
    SEMATTRS_NET_HOST_IP5 = TMP_NET_HOST_IP5;
    SEMATTRS_NET_HOST_PORT5 = TMP_NET_HOST_PORT5;
    SEMATTRS_NET_HOST_NAME5 = TMP_NET_HOST_NAME5;
    SEMATTRS_NET_HOST_CONNECTION_TYPE5 = TMP_NET_HOST_CONNECTION_TYPE5;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE5 = TMP_NET_HOST_CONNECTION_SUBTYPE5;
    SEMATTRS_NET_HOST_CARRIER_NAME5 = TMP_NET_HOST_CARRIER_NAME5;
    SEMATTRS_NET_HOST_CARRIER_MCC5 = TMP_NET_HOST_CARRIER_MCC5;
    SEMATTRS_NET_HOST_CARRIER_MNC5 = TMP_NET_HOST_CARRIER_MNC5;
    SEMATTRS_NET_HOST_CARRIER_ICC5 = TMP_NET_HOST_CARRIER_ICC5;
    SEMATTRS_PEER_SERVICE5 = TMP_PEER_SERVICE5;
    SEMATTRS_ENDUSER_ID5 = TMP_ENDUSER_ID5;
    SEMATTRS_ENDUSER_ROLE5 = TMP_ENDUSER_ROLE5;
    SEMATTRS_ENDUSER_SCOPE5 = TMP_ENDUSER_SCOPE5;
    SEMATTRS_THREAD_ID5 = TMP_THREAD_ID5;
    SEMATTRS_THREAD_NAME5 = TMP_THREAD_NAME5;
    SEMATTRS_CODE_FUNCTION5 = TMP_CODE_FUNCTION5;
    SEMATTRS_CODE_NAMESPACE5 = TMP_CODE_NAMESPACE5;
    SEMATTRS_CODE_FILEPATH5 = TMP_CODE_FILEPATH5;
    SEMATTRS_CODE_LINENO5 = TMP_CODE_LINENO5;
    SEMATTRS_HTTP_METHOD5 = TMP_HTTP_METHOD5;
    SEMATTRS_HTTP_URL5 = TMP_HTTP_URL5;
    SEMATTRS_HTTP_TARGET5 = TMP_HTTP_TARGET5;
    SEMATTRS_HTTP_HOST5 = TMP_HTTP_HOST5;
    SEMATTRS_HTTP_SCHEME5 = TMP_HTTP_SCHEME5;
    SEMATTRS_HTTP_STATUS_CODE5 = TMP_HTTP_STATUS_CODE5;
    SEMATTRS_HTTP_FLAVOR5 = TMP_HTTP_FLAVOR5;
    SEMATTRS_HTTP_USER_AGENT5 = TMP_HTTP_USER_AGENT5;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH5 = TMP_HTTP_REQUEST_CONTENT_LENGTH5;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5 = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH5 = TMP_HTTP_RESPONSE_CONTENT_LENGTH5;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5 = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5;
    SEMATTRS_HTTP_SERVER_NAME5 = TMP_HTTP_SERVER_NAME5;
    SEMATTRS_HTTP_ROUTE5 = TMP_HTTP_ROUTE5;
    SEMATTRS_HTTP_CLIENT_IP5 = TMP_HTTP_CLIENT_IP5;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES5 = TMP_AWS_DYNAMODB_TABLE_NAMES5;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY5 = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY5;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5 = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5 = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5 = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ5 = TMP_AWS_DYNAMODB_CONSISTENT_READ5;
    SEMATTRS_AWS_DYNAMODB_PROJECTION5 = TMP_AWS_DYNAMODB_PROJECTION5;
    SEMATTRS_AWS_DYNAMODB_LIMIT5 = TMP_AWS_DYNAMODB_LIMIT5;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET5 = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET5;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME5 = TMP_AWS_DYNAMODB_INDEX_NAME5;
    SEMATTRS_AWS_DYNAMODB_SELECT5 = TMP_AWS_DYNAMODB_SELECT5;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5 = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5 = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT5 = TMP_AWS_DYNAMODB_TABLE_COUNT5;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD5 = TMP_AWS_DYNAMODB_SCAN_FORWARD5;
    SEMATTRS_AWS_DYNAMODB_SEGMENT5 = TMP_AWS_DYNAMODB_SEGMENT5;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS5 = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS5;
    SEMATTRS_AWS_DYNAMODB_COUNT5 = TMP_AWS_DYNAMODB_COUNT5;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT5 = TMP_AWS_DYNAMODB_SCANNED_COUNT5;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5 = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5 = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5;
    SEMATTRS_MESSAGING_SYSTEM5 = TMP_MESSAGING_SYSTEM5;
    SEMATTRS_MESSAGING_DESTINATION5 = TMP_MESSAGING_DESTINATION5;
    SEMATTRS_MESSAGING_DESTINATION_KIND5 = TMP_MESSAGING_DESTINATION_KIND5;
    SEMATTRS_MESSAGING_TEMP_DESTINATION5 = TMP_MESSAGING_TEMP_DESTINATION5;
    SEMATTRS_MESSAGING_PROTOCOL5 = TMP_MESSAGING_PROTOCOL5;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION5 = TMP_MESSAGING_PROTOCOL_VERSION5;
    SEMATTRS_MESSAGING_URL5 = TMP_MESSAGING_URL5;
    SEMATTRS_MESSAGING_MESSAGE_ID5 = TMP_MESSAGING_MESSAGE_ID5;
    SEMATTRS_MESSAGING_CONVERSATION_ID5 = TMP_MESSAGING_CONVERSATION_ID5;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5 = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5 = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5;
    SEMATTRS_MESSAGING_OPERATION5 = TMP_MESSAGING_OPERATION5;
    SEMATTRS_MESSAGING_CONSUMER_ID5 = TMP_MESSAGING_CONSUMER_ID5;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY5 = TMP_MESSAGING_RABBITMQ_ROUTING_KEY5;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY5 = TMP_MESSAGING_KAFKA_MESSAGE_KEY5;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP5 = TMP_MESSAGING_KAFKA_CONSUMER_GROUP5;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID5 = TMP_MESSAGING_KAFKA_CLIENT_ID5;
    SEMATTRS_MESSAGING_KAFKA_PARTITION5 = TMP_MESSAGING_KAFKA_PARTITION5;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE5 = TMP_MESSAGING_KAFKA_TOMBSTONE5;
    SEMATTRS_RPC_SYSTEM5 = TMP_RPC_SYSTEM5;
    SEMATTRS_RPC_SERVICE5 = TMP_RPC_SERVICE5;
    SEMATTRS_RPC_METHOD5 = TMP_RPC_METHOD5;
    SEMATTRS_RPC_GRPC_STATUS_CODE5 = TMP_RPC_GRPC_STATUS_CODE5;
    SEMATTRS_RPC_JSONRPC_VERSION5 = TMP_RPC_JSONRPC_VERSION5;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID5 = TMP_RPC_JSONRPC_REQUEST_ID5;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE5 = TMP_RPC_JSONRPC_ERROR_CODE5;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE5 = TMP_RPC_JSONRPC_ERROR_MESSAGE5;
    SEMATTRS_MESSAGE_TYPE5 = TMP_MESSAGE_TYPE5;
    SEMATTRS_MESSAGE_ID5 = TMP_MESSAGE_ID5;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE5 = TMP_MESSAGE_COMPRESSED_SIZE5;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE5 = TMP_MESSAGE_UNCOMPRESSED_SIZE5;
    SemanticAttributes5 = /* @__PURE__ */ createConstMap5([
      TMP_AWS_LAMBDA_INVOKED_ARN5,
      TMP_DB_SYSTEM5,
      TMP_DB_CONNECTION_STRING5,
      TMP_DB_USER5,
      TMP_DB_JDBC_DRIVER_CLASSNAME5,
      TMP_DB_NAME5,
      TMP_DB_STATEMENT5,
      TMP_DB_OPERATION5,
      TMP_DB_MSSQL_INSTANCE_NAME5,
      TMP_DB_CASSANDRA_KEYSPACE5,
      TMP_DB_CASSANDRA_PAGE_SIZE5,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL5,
      TMP_DB_CASSANDRA_TABLE5,
      TMP_DB_CASSANDRA_IDEMPOTENCE5,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5,
      TMP_DB_CASSANDRA_COORDINATOR_ID5,
      TMP_DB_CASSANDRA_COORDINATOR_DC5,
      TMP_DB_HBASE_NAMESPACE5,
      TMP_DB_REDIS_DATABASE_INDEX5,
      TMP_DB_MONGODB_COLLECTION5,
      TMP_DB_SQL_TABLE5,
      TMP_EXCEPTION_TYPE5,
      TMP_EXCEPTION_MESSAGE5,
      TMP_EXCEPTION_STACKTRACE5,
      TMP_EXCEPTION_ESCAPED5,
      TMP_FAAS_TRIGGER5,
      TMP_FAAS_EXECUTION5,
      TMP_FAAS_DOCUMENT_COLLECTION5,
      TMP_FAAS_DOCUMENT_OPERATION5,
      TMP_FAAS_DOCUMENT_TIME5,
      TMP_FAAS_DOCUMENT_NAME5,
      TMP_FAAS_TIME5,
      TMP_FAAS_CRON5,
      TMP_FAAS_COLDSTART5,
      TMP_FAAS_INVOKED_NAME5,
      TMP_FAAS_INVOKED_PROVIDER5,
      TMP_FAAS_INVOKED_REGION5,
      TMP_NET_TRANSPORT5,
      TMP_NET_PEER_IP5,
      TMP_NET_PEER_PORT5,
      TMP_NET_PEER_NAME5,
      TMP_NET_HOST_IP5,
      TMP_NET_HOST_PORT5,
      TMP_NET_HOST_NAME5,
      TMP_NET_HOST_CONNECTION_TYPE5,
      TMP_NET_HOST_CONNECTION_SUBTYPE5,
      TMP_NET_HOST_CARRIER_NAME5,
      TMP_NET_HOST_CARRIER_MCC5,
      TMP_NET_HOST_CARRIER_MNC5,
      TMP_NET_HOST_CARRIER_ICC5,
      TMP_PEER_SERVICE5,
      TMP_ENDUSER_ID5,
      TMP_ENDUSER_ROLE5,
      TMP_ENDUSER_SCOPE5,
      TMP_THREAD_ID5,
      TMP_THREAD_NAME5,
      TMP_CODE_FUNCTION5,
      TMP_CODE_NAMESPACE5,
      TMP_CODE_FILEPATH5,
      TMP_CODE_LINENO5,
      TMP_HTTP_METHOD5,
      TMP_HTTP_URL5,
      TMP_HTTP_TARGET5,
      TMP_HTTP_HOST5,
      TMP_HTTP_SCHEME5,
      TMP_HTTP_STATUS_CODE5,
      TMP_HTTP_FLAVOR5,
      TMP_HTTP_USER_AGENT5,
      TMP_HTTP_REQUEST_CONTENT_LENGTH5,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH5,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5,
      TMP_HTTP_SERVER_NAME5,
      TMP_HTTP_ROUTE5,
      TMP_HTTP_CLIENT_IP5,
      TMP_AWS_DYNAMODB_TABLE_NAMES5,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY5,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5,
      TMP_AWS_DYNAMODB_CONSISTENT_READ5,
      TMP_AWS_DYNAMODB_PROJECTION5,
      TMP_AWS_DYNAMODB_LIMIT5,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET5,
      TMP_AWS_DYNAMODB_INDEX_NAME5,
      TMP_AWS_DYNAMODB_SELECT5,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5,
      TMP_AWS_DYNAMODB_TABLE_COUNT5,
      TMP_AWS_DYNAMODB_SCAN_FORWARD5,
      TMP_AWS_DYNAMODB_SEGMENT5,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS5,
      TMP_AWS_DYNAMODB_COUNT5,
      TMP_AWS_DYNAMODB_SCANNED_COUNT5,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5,
      TMP_MESSAGING_SYSTEM5,
      TMP_MESSAGING_DESTINATION5,
      TMP_MESSAGING_DESTINATION_KIND5,
      TMP_MESSAGING_TEMP_DESTINATION5,
      TMP_MESSAGING_PROTOCOL5,
      TMP_MESSAGING_PROTOCOL_VERSION5,
      TMP_MESSAGING_URL5,
      TMP_MESSAGING_MESSAGE_ID5,
      TMP_MESSAGING_CONVERSATION_ID5,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5,
      TMP_MESSAGING_OPERATION5,
      TMP_MESSAGING_CONSUMER_ID5,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY5,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY5,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP5,
      TMP_MESSAGING_KAFKA_CLIENT_ID5,
      TMP_MESSAGING_KAFKA_PARTITION5,
      TMP_MESSAGING_KAFKA_TOMBSTONE5,
      TMP_RPC_SYSTEM5,
      TMP_RPC_SERVICE5,
      TMP_RPC_METHOD5,
      TMP_RPC_GRPC_STATUS_CODE5,
      TMP_RPC_JSONRPC_VERSION5,
      TMP_RPC_JSONRPC_REQUEST_ID5,
      TMP_RPC_JSONRPC_ERROR_CODE5,
      TMP_RPC_JSONRPC_ERROR_MESSAGE5,
      TMP_MESSAGE_TYPE5,
      TMP_MESSAGE_ID5,
      TMP_MESSAGE_COMPRESSED_SIZE5,
      TMP_MESSAGE_UNCOMPRESSED_SIZE5
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL5 = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL5 = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL5 = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE5 = "oracle";
    TMP_DBSYSTEMVALUES_DB25 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL5 = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT5 = "redshift";
    TMP_DBSYSTEMVALUES_HIVE5 = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE5 = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB5 = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS5 = "progress";
    TMP_DBSYSTEMVALUES_MAXDB5 = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB5 = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES5 = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL5 = "firstsql";
    TMP_DBSYSTEMVALUES_EDB5 = "edb";
    TMP_DBSYSTEMVALUES_CACHE5 = "cache";
    TMP_DBSYSTEMVALUES_ADABAS5 = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD5 = "firebird";
    TMP_DBSYSTEMVALUES_DERBY5 = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER5 = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX5 = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB5 = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE5 = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB5 = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA5 = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE5 = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE5 = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE5 = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE5 = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA5 = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA5 = "vertica";
    TMP_DBSYSTEMVALUES_H25 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION5 = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA5 = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE5 = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB5 = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS5 = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE5 = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB5 = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB5 = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB5 = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J5 = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE5 = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH5 = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED5 = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB5 = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL5 = TMP_DBSYSTEMVALUES_OTHER_SQL5;
    DBSYSTEMVALUES_MSSQL5 = TMP_DBSYSTEMVALUES_MSSQL5;
    DBSYSTEMVALUES_MYSQL5 = TMP_DBSYSTEMVALUES_MYSQL5;
    DBSYSTEMVALUES_ORACLE5 = TMP_DBSYSTEMVALUES_ORACLE5;
    DBSYSTEMVALUES_DB25 = TMP_DBSYSTEMVALUES_DB25;
    DBSYSTEMVALUES_POSTGRESQL5 = TMP_DBSYSTEMVALUES_POSTGRESQL5;
    DBSYSTEMVALUES_REDSHIFT5 = TMP_DBSYSTEMVALUES_REDSHIFT5;
    DBSYSTEMVALUES_HIVE5 = TMP_DBSYSTEMVALUES_HIVE5;
    DBSYSTEMVALUES_CLOUDSCAPE5 = TMP_DBSYSTEMVALUES_CLOUDSCAPE5;
    DBSYSTEMVALUES_HSQLDB5 = TMP_DBSYSTEMVALUES_HSQLDB5;
    DBSYSTEMVALUES_PROGRESS5 = TMP_DBSYSTEMVALUES_PROGRESS5;
    DBSYSTEMVALUES_MAXDB5 = TMP_DBSYSTEMVALUES_MAXDB5;
    DBSYSTEMVALUES_HANADB5 = TMP_DBSYSTEMVALUES_HANADB5;
    DBSYSTEMVALUES_INGRES5 = TMP_DBSYSTEMVALUES_INGRES5;
    DBSYSTEMVALUES_FIRSTSQL5 = TMP_DBSYSTEMVALUES_FIRSTSQL5;
    DBSYSTEMVALUES_EDB5 = TMP_DBSYSTEMVALUES_EDB5;
    DBSYSTEMVALUES_CACHE5 = TMP_DBSYSTEMVALUES_CACHE5;
    DBSYSTEMVALUES_ADABAS5 = TMP_DBSYSTEMVALUES_ADABAS5;
    DBSYSTEMVALUES_FIREBIRD5 = TMP_DBSYSTEMVALUES_FIREBIRD5;
    DBSYSTEMVALUES_DERBY5 = TMP_DBSYSTEMVALUES_DERBY5;
    DBSYSTEMVALUES_FILEMAKER5 = TMP_DBSYSTEMVALUES_FILEMAKER5;
    DBSYSTEMVALUES_INFORMIX5 = TMP_DBSYSTEMVALUES_INFORMIX5;
    DBSYSTEMVALUES_INSTANTDB5 = TMP_DBSYSTEMVALUES_INSTANTDB5;
    DBSYSTEMVALUES_INTERBASE5 = TMP_DBSYSTEMVALUES_INTERBASE5;
    DBSYSTEMVALUES_MARIADB5 = TMP_DBSYSTEMVALUES_MARIADB5;
    DBSYSTEMVALUES_NETEZZA5 = TMP_DBSYSTEMVALUES_NETEZZA5;
    DBSYSTEMVALUES_PERVASIVE5 = TMP_DBSYSTEMVALUES_PERVASIVE5;
    DBSYSTEMVALUES_POINTBASE5 = TMP_DBSYSTEMVALUES_POINTBASE5;
    DBSYSTEMVALUES_SQLITE5 = TMP_DBSYSTEMVALUES_SQLITE5;
    DBSYSTEMVALUES_SYBASE5 = TMP_DBSYSTEMVALUES_SYBASE5;
    DBSYSTEMVALUES_TERADATA5 = TMP_DBSYSTEMVALUES_TERADATA5;
    DBSYSTEMVALUES_VERTICA5 = TMP_DBSYSTEMVALUES_VERTICA5;
    DBSYSTEMVALUES_H25 = TMP_DBSYSTEMVALUES_H25;
    DBSYSTEMVALUES_COLDFUSION5 = TMP_DBSYSTEMVALUES_COLDFUSION5;
    DBSYSTEMVALUES_CASSANDRA5 = TMP_DBSYSTEMVALUES_CASSANDRA5;
    DBSYSTEMVALUES_HBASE5 = TMP_DBSYSTEMVALUES_HBASE5;
    DBSYSTEMVALUES_MONGODB5 = TMP_DBSYSTEMVALUES_MONGODB5;
    DBSYSTEMVALUES_REDIS5 = TMP_DBSYSTEMVALUES_REDIS5;
    DBSYSTEMVALUES_COUCHBASE5 = TMP_DBSYSTEMVALUES_COUCHBASE5;
    DBSYSTEMVALUES_COUCHDB5 = TMP_DBSYSTEMVALUES_COUCHDB5;
    DBSYSTEMVALUES_COSMOSDB5 = TMP_DBSYSTEMVALUES_COSMOSDB5;
    DBSYSTEMVALUES_DYNAMODB5 = TMP_DBSYSTEMVALUES_DYNAMODB5;
    DBSYSTEMVALUES_NEO4J5 = TMP_DBSYSTEMVALUES_NEO4J5;
    DBSYSTEMVALUES_GEODE5 = TMP_DBSYSTEMVALUES_GEODE5;
    DBSYSTEMVALUES_ELASTICSEARCH5 = TMP_DBSYSTEMVALUES_ELASTICSEARCH5;
    DBSYSTEMVALUES_MEMCACHED5 = TMP_DBSYSTEMVALUES_MEMCACHED5;
    DBSYSTEMVALUES_COCKROACHDB5 = TMP_DBSYSTEMVALUES_COCKROACHDB5;
    DbSystemValues5 = /* @__PURE__ */ createConstMap5([
      TMP_DBSYSTEMVALUES_OTHER_SQL5,
      TMP_DBSYSTEMVALUES_MSSQL5,
      TMP_DBSYSTEMVALUES_MYSQL5,
      TMP_DBSYSTEMVALUES_ORACLE5,
      TMP_DBSYSTEMVALUES_DB25,
      TMP_DBSYSTEMVALUES_POSTGRESQL5,
      TMP_DBSYSTEMVALUES_REDSHIFT5,
      TMP_DBSYSTEMVALUES_HIVE5,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE5,
      TMP_DBSYSTEMVALUES_HSQLDB5,
      TMP_DBSYSTEMVALUES_PROGRESS5,
      TMP_DBSYSTEMVALUES_MAXDB5,
      TMP_DBSYSTEMVALUES_HANADB5,
      TMP_DBSYSTEMVALUES_INGRES5,
      TMP_DBSYSTEMVALUES_FIRSTSQL5,
      TMP_DBSYSTEMVALUES_EDB5,
      TMP_DBSYSTEMVALUES_CACHE5,
      TMP_DBSYSTEMVALUES_ADABAS5,
      TMP_DBSYSTEMVALUES_FIREBIRD5,
      TMP_DBSYSTEMVALUES_DERBY5,
      TMP_DBSYSTEMVALUES_FILEMAKER5,
      TMP_DBSYSTEMVALUES_INFORMIX5,
      TMP_DBSYSTEMVALUES_INSTANTDB5,
      TMP_DBSYSTEMVALUES_INTERBASE5,
      TMP_DBSYSTEMVALUES_MARIADB5,
      TMP_DBSYSTEMVALUES_NETEZZA5,
      TMP_DBSYSTEMVALUES_PERVASIVE5,
      TMP_DBSYSTEMVALUES_POINTBASE5,
      TMP_DBSYSTEMVALUES_SQLITE5,
      TMP_DBSYSTEMVALUES_SYBASE5,
      TMP_DBSYSTEMVALUES_TERADATA5,
      TMP_DBSYSTEMVALUES_VERTICA5,
      TMP_DBSYSTEMVALUES_H25,
      TMP_DBSYSTEMVALUES_COLDFUSION5,
      TMP_DBSYSTEMVALUES_CASSANDRA5,
      TMP_DBSYSTEMVALUES_HBASE5,
      TMP_DBSYSTEMVALUES_MONGODB5,
      TMP_DBSYSTEMVALUES_REDIS5,
      TMP_DBSYSTEMVALUES_COUCHBASE5,
      TMP_DBSYSTEMVALUES_COUCHDB5,
      TMP_DBSYSTEMVALUES_COSMOSDB5,
      TMP_DBSYSTEMVALUES_DYNAMODB5,
      TMP_DBSYSTEMVALUES_NEO4J5,
      TMP_DBSYSTEMVALUES_GEODE5,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH5,
      TMP_DBSYSTEMVALUES_MEMCACHED5,
      TMP_DBSYSTEMVALUES_COCKROACHDB5
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL5 = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5 = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5 = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5 = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE5 = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO5 = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE5 = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5 = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY5 = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5 = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5 = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL5;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE5;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO5;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE5;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY5;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5 = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5;
    DbCassandraConsistencyLevelValues5 = /* @__PURE__ */ createConstMap5([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE5 = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP5 = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB5 = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER5 = "timer";
    TMP_FAASTRIGGERVALUES_OTHER5 = "other";
    FAASTRIGGERVALUES_DATASOURCE5 = TMP_FAASTRIGGERVALUES_DATASOURCE5;
    FAASTRIGGERVALUES_HTTP5 = TMP_FAASTRIGGERVALUES_HTTP5;
    FAASTRIGGERVALUES_PUBSUB5 = TMP_FAASTRIGGERVALUES_PUBSUB5;
    FAASTRIGGERVALUES_TIMER5 = TMP_FAASTRIGGERVALUES_TIMER5;
    FAASTRIGGERVALUES_OTHER5 = TMP_FAASTRIGGERVALUES_OTHER5;
    FaasTriggerValues5 = /* @__PURE__ */ createConstMap5([
      TMP_FAASTRIGGERVALUES_DATASOURCE5,
      TMP_FAASTRIGGERVALUES_HTTP5,
      TMP_FAASTRIGGERVALUES_PUBSUB5,
      TMP_FAASTRIGGERVALUES_TIMER5,
      TMP_FAASTRIGGERVALUES_OTHER5
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT5 = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT5 = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE5 = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT5 = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT5;
    FAASDOCUMENTOPERATIONVALUES_EDIT5 = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT5;
    FAASDOCUMENTOPERATIONVALUES_DELETE5 = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE5;
    FaasDocumentOperationValues5 = /* @__PURE__ */ createConstMap5([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT5,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT5,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE5
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5 = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS5 = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE5 = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP5 = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5 = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5;
    FAASINVOKEDPROVIDERVALUES_AWS5 = TMP_FAASINVOKEDPROVIDERVALUES_AWS5;
    FAASINVOKEDPROVIDERVALUES_AZURE5 = TMP_FAASINVOKEDPROVIDERVALUES_AZURE5;
    FAASINVOKEDPROVIDERVALUES_GCP5 = TMP_FAASINVOKEDPROVIDERVALUES_GCP5;
    FaasInvokedProviderValues5 = /* @__PURE__ */ createConstMap5([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS5,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE5,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP5
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP5 = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP5 = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP5 = "ip";
    TMP_NETTRANSPORTVALUES_UNIX5 = "unix";
    TMP_NETTRANSPORTVALUES_PIPE5 = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC5 = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER5 = "other";
    NETTRANSPORTVALUES_IP_TCP5 = TMP_NETTRANSPORTVALUES_IP_TCP5;
    NETTRANSPORTVALUES_IP_UDP5 = TMP_NETTRANSPORTVALUES_IP_UDP5;
    NETTRANSPORTVALUES_IP5 = TMP_NETTRANSPORTVALUES_IP5;
    NETTRANSPORTVALUES_UNIX5 = TMP_NETTRANSPORTVALUES_UNIX5;
    NETTRANSPORTVALUES_PIPE5 = TMP_NETTRANSPORTVALUES_PIPE5;
    NETTRANSPORTVALUES_INPROC5 = TMP_NETTRANSPORTVALUES_INPROC5;
    NETTRANSPORTVALUES_OTHER5 = TMP_NETTRANSPORTVALUES_OTHER5;
    NetTransportValues5 = /* @__PURE__ */ createConstMap5([
      TMP_NETTRANSPORTVALUES_IP_TCP5,
      TMP_NETTRANSPORTVALUES_IP_UDP5,
      TMP_NETTRANSPORTVALUES_IP5,
      TMP_NETTRANSPORTVALUES_UNIX5,
      TMP_NETTRANSPORTVALUES_PIPE5,
      TMP_NETTRANSPORTVALUES_INPROC5,
      TMP_NETTRANSPORTVALUES_OTHER5
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI5 = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED5 = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL5 = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5 = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5 = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI5 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI5;
    NETHOSTCONNECTIONTYPEVALUES_WIRED5 = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED5;
    NETHOSTCONNECTIONTYPEVALUES_CELL5 = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL5;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5 = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5;
    NetHostConnectionTypeValues5 = /* @__PURE__ */ createConstMap5([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI5,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED5,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL5,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5 = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5 = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5 = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5 = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5 = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5 = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5 = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5 = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5 = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5 = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5 = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE5 = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5 = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5 = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM5 = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5 = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5 = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR5 = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5 = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5 = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE5;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM5;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR5;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5;
    NetHostConnectionSubtypeValues5 = /* @__PURE__ */ createConstMap5([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_05 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_15 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_05 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY5 = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC5 = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_05 = TMP_HTTPFLAVORVALUES_HTTP_1_05;
    HTTPFLAVORVALUES_HTTP_1_15 = TMP_HTTPFLAVORVALUES_HTTP_1_15;
    HTTPFLAVORVALUES_HTTP_2_05 = TMP_HTTPFLAVORVALUES_HTTP_2_05;
    HTTPFLAVORVALUES_SPDY5 = TMP_HTTPFLAVORVALUES_SPDY5;
    HTTPFLAVORVALUES_QUIC5 = TMP_HTTPFLAVORVALUES_QUIC5;
    HttpFlavorValues5 = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_05,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_15,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_05,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY5,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC5
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE5 = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC5 = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE5 = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE5;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC5 = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC5;
    MessagingDestinationKindValues5 = /* @__PURE__ */ createConstMap5([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE5,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC5
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE5 = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS5 = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE5 = TMP_MESSAGINGOPERATIONVALUES_RECEIVE5;
    MESSAGINGOPERATIONVALUES_PROCESS5 = TMP_MESSAGINGOPERATIONVALUES_PROCESS5;
    MessagingOperationValues5 = /* @__PURE__ */ createConstMap5([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE5,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS5
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK5 = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED5 = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN5 = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5 = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5 = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND5 = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5 = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5 = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5 = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5 = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED5 = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5 = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5 = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL5 = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5 = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS5 = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5 = 16;
    RPCGRPCSTATUSCODEVALUES_OK5 = TMP_RPCGRPCSTATUSCODEVALUES_OK5;
    RPCGRPCSTATUSCODEVALUES_CANCELLED5 = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED5;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN5 = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN5;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5 = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5 = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND5 = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND5;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5 = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5 = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5 = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5 = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5;
    RPCGRPCSTATUSCODEVALUES_ABORTED5 = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED5;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5 = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5 = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5;
    RPCGRPCSTATUSCODEVALUES_INTERNAL5 = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL5;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5 = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS5 = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS5;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5 = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5;
    RpcGrpcStatusCodeValues5 = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK5,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED5,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN5,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND5,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED5,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL5,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS5,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5
    };
    TMP_MESSAGETYPEVALUES_SENT5 = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED5 = "RECEIVED";
    MESSAGETYPEVALUES_SENT5 = TMP_MESSAGETYPEVALUES_SENT5;
    MESSAGETYPEVALUES_RECEIVED5 = TMP_MESSAGETYPEVALUES_RECEIVED5;
    MessageTypeValues5 = /* @__PURE__ */ createConstMap5([
      TMP_MESSAGETYPEVALUES_SENT5,
      TMP_MESSAGETYPEVALUES_RECEIVED5
    ]);
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace6 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes5();
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER5, TMP_CLOUD_ACCOUNT_ID5, TMP_CLOUD_REGION5, TMP_CLOUD_AVAILABILITY_ZONE5, TMP_CLOUD_PLATFORM5, TMP_AWS_ECS_CONTAINER_ARN5, TMP_AWS_ECS_CLUSTER_ARN5, TMP_AWS_ECS_LAUNCHTYPE5, TMP_AWS_ECS_TASK_ARN5, TMP_AWS_ECS_TASK_FAMILY5, TMP_AWS_ECS_TASK_REVISION5, TMP_AWS_EKS_CLUSTER_ARN5, TMP_AWS_LOG_GROUP_NAMES5, TMP_AWS_LOG_GROUP_ARNS5, TMP_AWS_LOG_STREAM_NAMES5, TMP_AWS_LOG_STREAM_ARNS5, TMP_CONTAINER_NAME5, TMP_CONTAINER_ID5, TMP_CONTAINER_RUNTIME5, TMP_CONTAINER_IMAGE_NAME5, TMP_CONTAINER_IMAGE_TAG5, TMP_DEPLOYMENT_ENVIRONMENT5, TMP_DEVICE_ID5, TMP_DEVICE_MODEL_IDENTIFIER5, TMP_DEVICE_MODEL_NAME5, TMP_FAAS_NAME5, TMP_FAAS_ID5, TMP_FAAS_VERSION5, TMP_FAAS_INSTANCE5, TMP_FAAS_MAX_MEMORY5, TMP_HOST_ID5, TMP_HOST_NAME5, TMP_HOST_TYPE5, TMP_HOST_ARCH5, TMP_HOST_IMAGE_NAME5, TMP_HOST_IMAGE_ID5, TMP_HOST_IMAGE_VERSION5, TMP_K8S_CLUSTER_NAME5, TMP_K8S_NODE_NAME5, TMP_K8S_NODE_UID5, TMP_K8S_NAMESPACE_NAME5, TMP_K8S_POD_UID5, TMP_K8S_POD_NAME5, TMP_K8S_CONTAINER_NAME5, TMP_K8S_REPLICASET_UID5, TMP_K8S_REPLICASET_NAME5, TMP_K8S_DEPLOYMENT_UID5, TMP_K8S_DEPLOYMENT_NAME5, TMP_K8S_STATEFULSET_UID5, TMP_K8S_STATEFULSET_NAME5, TMP_K8S_DAEMONSET_UID5, TMP_K8S_DAEMONSET_NAME5, TMP_K8S_JOB_UID5, TMP_K8S_JOB_NAME5, TMP_K8S_CRONJOB_UID5, TMP_K8S_CRONJOB_NAME5, TMP_OS_TYPE5, TMP_OS_DESCRIPTION5, TMP_OS_NAME5, TMP_OS_VERSION5, TMP_PROCESS_PID5, TMP_PROCESS_EXECUTABLE_NAME5, TMP_PROCESS_EXECUTABLE_PATH5, TMP_PROCESS_COMMAND5, TMP_PROCESS_COMMAND_LINE5, TMP_PROCESS_COMMAND_ARGS5, TMP_PROCESS_OWNER5, TMP_PROCESS_RUNTIME_NAME5, TMP_PROCESS_RUNTIME_VERSION5, TMP_PROCESS_RUNTIME_DESCRIPTION5, TMP_SERVICE_NAME5, TMP_SERVICE_NAMESPACE5, TMP_SERVICE_INSTANCE_ID5, TMP_SERVICE_VERSION5, TMP_TELEMETRY_SDK_NAME5, TMP_TELEMETRY_SDK_LANGUAGE5, TMP_TELEMETRY_SDK_VERSION5, TMP_TELEMETRY_AUTO_VERSION5, TMP_WEBENGINE_NAME5, TMP_WEBENGINE_VERSION5, TMP_WEBENGINE_DESCRIPTION5, SEMRESATTRS_CLOUD_PROVIDER5, SEMRESATTRS_CLOUD_ACCOUNT_ID5, SEMRESATTRS_CLOUD_REGION5, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE5, SEMRESATTRS_CLOUD_PLATFORM5, SEMRESATTRS_AWS_ECS_CONTAINER_ARN5, SEMRESATTRS_AWS_ECS_CLUSTER_ARN5, SEMRESATTRS_AWS_ECS_LAUNCHTYPE5, SEMRESATTRS_AWS_ECS_TASK_ARN5, SEMRESATTRS_AWS_ECS_TASK_FAMILY5, SEMRESATTRS_AWS_ECS_TASK_REVISION5, SEMRESATTRS_AWS_EKS_CLUSTER_ARN5, SEMRESATTRS_AWS_LOG_GROUP_NAMES5, SEMRESATTRS_AWS_LOG_GROUP_ARNS5, SEMRESATTRS_AWS_LOG_STREAM_NAMES5, SEMRESATTRS_AWS_LOG_STREAM_ARNS5, SEMRESATTRS_CONTAINER_NAME5, SEMRESATTRS_CONTAINER_ID5, SEMRESATTRS_CONTAINER_RUNTIME5, SEMRESATTRS_CONTAINER_IMAGE_NAME5, SEMRESATTRS_CONTAINER_IMAGE_TAG5, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT5, SEMRESATTRS_DEVICE_ID5, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER5, SEMRESATTRS_DEVICE_MODEL_NAME5, SEMRESATTRS_FAAS_NAME5, SEMRESATTRS_FAAS_ID5, SEMRESATTRS_FAAS_VERSION5, SEMRESATTRS_FAAS_INSTANCE5, SEMRESATTRS_FAAS_MAX_MEMORY5, SEMRESATTRS_HOST_ID5, SEMRESATTRS_HOST_NAME5, SEMRESATTRS_HOST_TYPE5, SEMRESATTRS_HOST_ARCH5, SEMRESATTRS_HOST_IMAGE_NAME5, SEMRESATTRS_HOST_IMAGE_ID5, SEMRESATTRS_HOST_IMAGE_VERSION5, SEMRESATTRS_K8S_CLUSTER_NAME5, SEMRESATTRS_K8S_NODE_NAME5, SEMRESATTRS_K8S_NODE_UID5, SEMRESATTRS_K8S_NAMESPACE_NAME5, SEMRESATTRS_K8S_POD_UID5, SEMRESATTRS_K8S_POD_NAME5, SEMRESATTRS_K8S_CONTAINER_NAME5, SEMRESATTRS_K8S_REPLICASET_UID5, SEMRESATTRS_K8S_REPLICASET_NAME5, SEMRESATTRS_K8S_DEPLOYMENT_UID5, SEMRESATTRS_K8S_DEPLOYMENT_NAME5, SEMRESATTRS_K8S_STATEFULSET_UID5, SEMRESATTRS_K8S_STATEFULSET_NAME5, SEMRESATTRS_K8S_DAEMONSET_UID5, SEMRESATTRS_K8S_DAEMONSET_NAME5, SEMRESATTRS_K8S_JOB_UID5, SEMRESATTRS_K8S_JOB_NAME5, SEMRESATTRS_K8S_CRONJOB_UID5, SEMRESATTRS_K8S_CRONJOB_NAME5, SEMRESATTRS_OS_TYPE5, SEMRESATTRS_OS_DESCRIPTION5, SEMRESATTRS_OS_NAME5, SEMRESATTRS_OS_VERSION5, SEMRESATTRS_PROCESS_PID5, SEMRESATTRS_PROCESS_EXECUTABLE_NAME5, SEMRESATTRS_PROCESS_EXECUTABLE_PATH5, SEMRESATTRS_PROCESS_COMMAND5, SEMRESATTRS_PROCESS_COMMAND_LINE5, SEMRESATTRS_PROCESS_COMMAND_ARGS5, SEMRESATTRS_PROCESS_OWNER5, SEMRESATTRS_PROCESS_RUNTIME_NAME5, SEMRESATTRS_PROCESS_RUNTIME_VERSION5, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION5, SEMRESATTRS_SERVICE_NAME5, SEMRESATTRS_SERVICE_NAMESPACE5, SEMRESATTRS_SERVICE_INSTANCE_ID5, SEMRESATTRS_SERVICE_VERSION5, SEMRESATTRS_TELEMETRY_SDK_NAME5, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE5, SEMRESATTRS_TELEMETRY_SDK_VERSION5, SEMRESATTRS_TELEMETRY_AUTO_VERSION5, SEMRESATTRS_WEBENGINE_NAME5, SEMRESATTRS_WEBENGINE_VERSION5, SEMRESATTRS_WEBENGINE_DESCRIPTION5, SemanticResourceAttributes5, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD5, TMP_CLOUDPROVIDERVALUES_AWS5, TMP_CLOUDPROVIDERVALUES_AZURE5, TMP_CLOUDPROVIDERVALUES_GCP5, CLOUDPROVIDERVALUES_ALIBABA_CLOUD5, CLOUDPROVIDERVALUES_AWS5, CLOUDPROVIDERVALUES_AZURE5, CLOUDPROVIDERVALUES_GCP5, CloudProviderValues5, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5, TMP_CLOUDPLATFORMVALUES_AWS_EC25, TMP_CLOUDPLATFORMVALUES_AWS_ECS5, TMP_CLOUDPLATFORMVALUES_AWS_EKS5, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA5, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5, TMP_CLOUDPLATFORMVALUES_AZURE_VM5, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5, TMP_CLOUDPLATFORMVALUES_AZURE_AKS5, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE5, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5, CLOUDPLATFORMVALUES_AWS_EC25, CLOUDPLATFORMVALUES_AWS_ECS5, CLOUDPLATFORMVALUES_AWS_EKS5, CLOUDPLATFORMVALUES_AWS_LAMBDA5, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5, CLOUDPLATFORMVALUES_AZURE_VM5, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5, CLOUDPLATFORMVALUES_AZURE_AKS5, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5, CLOUDPLATFORMVALUES_GCP_APP_ENGINE5, CloudPlatformValues5, TMP_AWSECSLAUNCHTYPEVALUES_EC25, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE5, AWSECSLAUNCHTYPEVALUES_EC25, AWSECSLAUNCHTYPEVALUES_FARGATE5, AwsEcsLaunchtypeValues5, TMP_HOSTARCHVALUES_AMD645, TMP_HOSTARCHVALUES_ARM325, TMP_HOSTARCHVALUES_ARM645, TMP_HOSTARCHVALUES_IA645, TMP_HOSTARCHVALUES_PPC325, TMP_HOSTARCHVALUES_PPC645, TMP_HOSTARCHVALUES_X865, HOSTARCHVALUES_AMD645, HOSTARCHVALUES_ARM325, HOSTARCHVALUES_ARM645, HOSTARCHVALUES_IA645, HOSTARCHVALUES_PPC325, HOSTARCHVALUES_PPC645, HOSTARCHVALUES_X865, HostArchValues5, TMP_OSTYPEVALUES_WINDOWS5, TMP_OSTYPEVALUES_LINUX5, TMP_OSTYPEVALUES_DARWIN5, TMP_OSTYPEVALUES_FREEBSD5, TMP_OSTYPEVALUES_NETBSD5, TMP_OSTYPEVALUES_OPENBSD5, TMP_OSTYPEVALUES_DRAGONFLYBSD5, TMP_OSTYPEVALUES_HPUX5, TMP_OSTYPEVALUES_AIX5, TMP_OSTYPEVALUES_SOLARIS5, TMP_OSTYPEVALUES_Z_OS5, OSTYPEVALUES_WINDOWS5, OSTYPEVALUES_LINUX5, OSTYPEVALUES_DARWIN5, OSTYPEVALUES_FREEBSD5, OSTYPEVALUES_NETBSD5, OSTYPEVALUES_OPENBSD5, OSTYPEVALUES_DRAGONFLYBSD5, OSTYPEVALUES_HPUX5, OSTYPEVALUES_AIX5, OSTYPEVALUES_SOLARIS5, OSTYPEVALUES_Z_OS5, OsTypeValues5, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP5, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET5, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG5, TMP_TELEMETRYSDKLANGUAGEVALUES_GO5, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA5, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS5, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP5, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON5, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY5, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS5, TELEMETRYSDKLANGUAGEVALUES_CPP5, TELEMETRYSDKLANGUAGEVALUES_DOTNET5, TELEMETRYSDKLANGUAGEVALUES_ERLANG5, TELEMETRYSDKLANGUAGEVALUES_GO5, TELEMETRYSDKLANGUAGEVALUES_JAVA5, TELEMETRYSDKLANGUAGEVALUES_NODEJS5, TELEMETRYSDKLANGUAGEVALUES_PHP5, TELEMETRYSDKLANGUAGEVALUES_PYTHON5, TELEMETRYSDKLANGUAGEVALUES_RUBY5, TELEMETRYSDKLANGUAGEVALUES_WEBJS5, TelemetrySdkLanguageValues5;
var init_SemanticResourceAttributes5 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils7();
    TMP_CLOUD_PROVIDER5 = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID5 = "cloud.account.id";
    TMP_CLOUD_REGION5 = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE5 = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM5 = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN5 = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN5 = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE5 = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN5 = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY5 = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION5 = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN5 = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES5 = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS5 = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES5 = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS5 = "aws.log.stream.arns";
    TMP_CONTAINER_NAME5 = "container.name";
    TMP_CONTAINER_ID5 = "container.id";
    TMP_CONTAINER_RUNTIME5 = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME5 = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG5 = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT5 = "deployment.environment";
    TMP_DEVICE_ID5 = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER5 = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME5 = "device.model.name";
    TMP_FAAS_NAME5 = "faas.name";
    TMP_FAAS_ID5 = "faas.id";
    TMP_FAAS_VERSION5 = "faas.version";
    TMP_FAAS_INSTANCE5 = "faas.instance";
    TMP_FAAS_MAX_MEMORY5 = "faas.max_memory";
    TMP_HOST_ID5 = "host.id";
    TMP_HOST_NAME5 = "host.name";
    TMP_HOST_TYPE5 = "host.type";
    TMP_HOST_ARCH5 = "host.arch";
    TMP_HOST_IMAGE_NAME5 = "host.image.name";
    TMP_HOST_IMAGE_ID5 = "host.image.id";
    TMP_HOST_IMAGE_VERSION5 = "host.image.version";
    TMP_K8S_CLUSTER_NAME5 = "k8s.cluster.name";
    TMP_K8S_NODE_NAME5 = "k8s.node.name";
    TMP_K8S_NODE_UID5 = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME5 = "k8s.namespace.name";
    TMP_K8S_POD_UID5 = "k8s.pod.uid";
    TMP_K8S_POD_NAME5 = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME5 = "k8s.container.name";
    TMP_K8S_REPLICASET_UID5 = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME5 = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID5 = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME5 = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID5 = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME5 = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID5 = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME5 = "k8s.daemonset.name";
    TMP_K8S_JOB_UID5 = "k8s.job.uid";
    TMP_K8S_JOB_NAME5 = "k8s.job.name";
    TMP_K8S_CRONJOB_UID5 = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME5 = "k8s.cronjob.name";
    TMP_OS_TYPE5 = "os.type";
    TMP_OS_DESCRIPTION5 = "os.description";
    TMP_OS_NAME5 = "os.name";
    TMP_OS_VERSION5 = "os.version";
    TMP_PROCESS_PID5 = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME5 = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH5 = "process.executable.path";
    TMP_PROCESS_COMMAND5 = "process.command";
    TMP_PROCESS_COMMAND_LINE5 = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS5 = "process.command_args";
    TMP_PROCESS_OWNER5 = "process.owner";
    TMP_PROCESS_RUNTIME_NAME5 = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION5 = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION5 = "process.runtime.description";
    TMP_SERVICE_NAME5 = "service.name";
    TMP_SERVICE_NAMESPACE5 = "service.namespace";
    TMP_SERVICE_INSTANCE_ID5 = "service.instance.id";
    TMP_SERVICE_VERSION5 = "service.version";
    TMP_TELEMETRY_SDK_NAME5 = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE5 = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION5 = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION5 = "telemetry.auto.version";
    TMP_WEBENGINE_NAME5 = "webengine.name";
    TMP_WEBENGINE_VERSION5 = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION5 = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER5 = TMP_CLOUD_PROVIDER5;
    SEMRESATTRS_CLOUD_ACCOUNT_ID5 = TMP_CLOUD_ACCOUNT_ID5;
    SEMRESATTRS_CLOUD_REGION5 = TMP_CLOUD_REGION5;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE5 = TMP_CLOUD_AVAILABILITY_ZONE5;
    SEMRESATTRS_CLOUD_PLATFORM5 = TMP_CLOUD_PLATFORM5;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN5 = TMP_AWS_ECS_CONTAINER_ARN5;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN5 = TMP_AWS_ECS_CLUSTER_ARN5;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE5 = TMP_AWS_ECS_LAUNCHTYPE5;
    SEMRESATTRS_AWS_ECS_TASK_ARN5 = TMP_AWS_ECS_TASK_ARN5;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY5 = TMP_AWS_ECS_TASK_FAMILY5;
    SEMRESATTRS_AWS_ECS_TASK_REVISION5 = TMP_AWS_ECS_TASK_REVISION5;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN5 = TMP_AWS_EKS_CLUSTER_ARN5;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES5 = TMP_AWS_LOG_GROUP_NAMES5;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS5 = TMP_AWS_LOG_GROUP_ARNS5;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES5 = TMP_AWS_LOG_STREAM_NAMES5;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS5 = TMP_AWS_LOG_STREAM_ARNS5;
    SEMRESATTRS_CONTAINER_NAME5 = TMP_CONTAINER_NAME5;
    SEMRESATTRS_CONTAINER_ID5 = TMP_CONTAINER_ID5;
    SEMRESATTRS_CONTAINER_RUNTIME5 = TMP_CONTAINER_RUNTIME5;
    SEMRESATTRS_CONTAINER_IMAGE_NAME5 = TMP_CONTAINER_IMAGE_NAME5;
    SEMRESATTRS_CONTAINER_IMAGE_TAG5 = TMP_CONTAINER_IMAGE_TAG5;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT5 = TMP_DEPLOYMENT_ENVIRONMENT5;
    SEMRESATTRS_DEVICE_ID5 = TMP_DEVICE_ID5;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER5 = TMP_DEVICE_MODEL_IDENTIFIER5;
    SEMRESATTRS_DEVICE_MODEL_NAME5 = TMP_DEVICE_MODEL_NAME5;
    SEMRESATTRS_FAAS_NAME5 = TMP_FAAS_NAME5;
    SEMRESATTRS_FAAS_ID5 = TMP_FAAS_ID5;
    SEMRESATTRS_FAAS_VERSION5 = TMP_FAAS_VERSION5;
    SEMRESATTRS_FAAS_INSTANCE5 = TMP_FAAS_INSTANCE5;
    SEMRESATTRS_FAAS_MAX_MEMORY5 = TMP_FAAS_MAX_MEMORY5;
    SEMRESATTRS_HOST_ID5 = TMP_HOST_ID5;
    SEMRESATTRS_HOST_NAME5 = TMP_HOST_NAME5;
    SEMRESATTRS_HOST_TYPE5 = TMP_HOST_TYPE5;
    SEMRESATTRS_HOST_ARCH5 = TMP_HOST_ARCH5;
    SEMRESATTRS_HOST_IMAGE_NAME5 = TMP_HOST_IMAGE_NAME5;
    SEMRESATTRS_HOST_IMAGE_ID5 = TMP_HOST_IMAGE_ID5;
    SEMRESATTRS_HOST_IMAGE_VERSION5 = TMP_HOST_IMAGE_VERSION5;
    SEMRESATTRS_K8S_CLUSTER_NAME5 = TMP_K8S_CLUSTER_NAME5;
    SEMRESATTRS_K8S_NODE_NAME5 = TMP_K8S_NODE_NAME5;
    SEMRESATTRS_K8S_NODE_UID5 = TMP_K8S_NODE_UID5;
    SEMRESATTRS_K8S_NAMESPACE_NAME5 = TMP_K8S_NAMESPACE_NAME5;
    SEMRESATTRS_K8S_POD_UID5 = TMP_K8S_POD_UID5;
    SEMRESATTRS_K8S_POD_NAME5 = TMP_K8S_POD_NAME5;
    SEMRESATTRS_K8S_CONTAINER_NAME5 = TMP_K8S_CONTAINER_NAME5;
    SEMRESATTRS_K8S_REPLICASET_UID5 = TMP_K8S_REPLICASET_UID5;
    SEMRESATTRS_K8S_REPLICASET_NAME5 = TMP_K8S_REPLICASET_NAME5;
    SEMRESATTRS_K8S_DEPLOYMENT_UID5 = TMP_K8S_DEPLOYMENT_UID5;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME5 = TMP_K8S_DEPLOYMENT_NAME5;
    SEMRESATTRS_K8S_STATEFULSET_UID5 = TMP_K8S_STATEFULSET_UID5;
    SEMRESATTRS_K8S_STATEFULSET_NAME5 = TMP_K8S_STATEFULSET_NAME5;
    SEMRESATTRS_K8S_DAEMONSET_UID5 = TMP_K8S_DAEMONSET_UID5;
    SEMRESATTRS_K8S_DAEMONSET_NAME5 = TMP_K8S_DAEMONSET_NAME5;
    SEMRESATTRS_K8S_JOB_UID5 = TMP_K8S_JOB_UID5;
    SEMRESATTRS_K8S_JOB_NAME5 = TMP_K8S_JOB_NAME5;
    SEMRESATTRS_K8S_CRONJOB_UID5 = TMP_K8S_CRONJOB_UID5;
    SEMRESATTRS_K8S_CRONJOB_NAME5 = TMP_K8S_CRONJOB_NAME5;
    SEMRESATTRS_OS_TYPE5 = TMP_OS_TYPE5;
    SEMRESATTRS_OS_DESCRIPTION5 = TMP_OS_DESCRIPTION5;
    SEMRESATTRS_OS_NAME5 = TMP_OS_NAME5;
    SEMRESATTRS_OS_VERSION5 = TMP_OS_VERSION5;
    SEMRESATTRS_PROCESS_PID5 = TMP_PROCESS_PID5;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME5 = TMP_PROCESS_EXECUTABLE_NAME5;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH5 = TMP_PROCESS_EXECUTABLE_PATH5;
    SEMRESATTRS_PROCESS_COMMAND5 = TMP_PROCESS_COMMAND5;
    SEMRESATTRS_PROCESS_COMMAND_LINE5 = TMP_PROCESS_COMMAND_LINE5;
    SEMRESATTRS_PROCESS_COMMAND_ARGS5 = TMP_PROCESS_COMMAND_ARGS5;
    SEMRESATTRS_PROCESS_OWNER5 = TMP_PROCESS_OWNER5;
    SEMRESATTRS_PROCESS_RUNTIME_NAME5 = TMP_PROCESS_RUNTIME_NAME5;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION5 = TMP_PROCESS_RUNTIME_VERSION5;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION5 = TMP_PROCESS_RUNTIME_DESCRIPTION5;
    SEMRESATTRS_SERVICE_NAME5 = TMP_SERVICE_NAME5;
    SEMRESATTRS_SERVICE_NAMESPACE5 = TMP_SERVICE_NAMESPACE5;
    SEMRESATTRS_SERVICE_INSTANCE_ID5 = TMP_SERVICE_INSTANCE_ID5;
    SEMRESATTRS_SERVICE_VERSION5 = TMP_SERVICE_VERSION5;
    SEMRESATTRS_TELEMETRY_SDK_NAME5 = TMP_TELEMETRY_SDK_NAME5;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE5 = TMP_TELEMETRY_SDK_LANGUAGE5;
    SEMRESATTRS_TELEMETRY_SDK_VERSION5 = TMP_TELEMETRY_SDK_VERSION5;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION5 = TMP_TELEMETRY_AUTO_VERSION5;
    SEMRESATTRS_WEBENGINE_NAME5 = TMP_WEBENGINE_NAME5;
    SEMRESATTRS_WEBENGINE_VERSION5 = TMP_WEBENGINE_VERSION5;
    SEMRESATTRS_WEBENGINE_DESCRIPTION5 = TMP_WEBENGINE_DESCRIPTION5;
    SemanticResourceAttributes5 = /* @__PURE__ */ createConstMap5([
      TMP_CLOUD_PROVIDER5,
      TMP_CLOUD_ACCOUNT_ID5,
      TMP_CLOUD_REGION5,
      TMP_CLOUD_AVAILABILITY_ZONE5,
      TMP_CLOUD_PLATFORM5,
      TMP_AWS_ECS_CONTAINER_ARN5,
      TMP_AWS_ECS_CLUSTER_ARN5,
      TMP_AWS_ECS_LAUNCHTYPE5,
      TMP_AWS_ECS_TASK_ARN5,
      TMP_AWS_ECS_TASK_FAMILY5,
      TMP_AWS_ECS_TASK_REVISION5,
      TMP_AWS_EKS_CLUSTER_ARN5,
      TMP_AWS_LOG_GROUP_NAMES5,
      TMP_AWS_LOG_GROUP_ARNS5,
      TMP_AWS_LOG_STREAM_NAMES5,
      TMP_AWS_LOG_STREAM_ARNS5,
      TMP_CONTAINER_NAME5,
      TMP_CONTAINER_ID5,
      TMP_CONTAINER_RUNTIME5,
      TMP_CONTAINER_IMAGE_NAME5,
      TMP_CONTAINER_IMAGE_TAG5,
      TMP_DEPLOYMENT_ENVIRONMENT5,
      TMP_DEVICE_ID5,
      TMP_DEVICE_MODEL_IDENTIFIER5,
      TMP_DEVICE_MODEL_NAME5,
      TMP_FAAS_NAME5,
      TMP_FAAS_ID5,
      TMP_FAAS_VERSION5,
      TMP_FAAS_INSTANCE5,
      TMP_FAAS_MAX_MEMORY5,
      TMP_HOST_ID5,
      TMP_HOST_NAME5,
      TMP_HOST_TYPE5,
      TMP_HOST_ARCH5,
      TMP_HOST_IMAGE_NAME5,
      TMP_HOST_IMAGE_ID5,
      TMP_HOST_IMAGE_VERSION5,
      TMP_K8S_CLUSTER_NAME5,
      TMP_K8S_NODE_NAME5,
      TMP_K8S_NODE_UID5,
      TMP_K8S_NAMESPACE_NAME5,
      TMP_K8S_POD_UID5,
      TMP_K8S_POD_NAME5,
      TMP_K8S_CONTAINER_NAME5,
      TMP_K8S_REPLICASET_UID5,
      TMP_K8S_REPLICASET_NAME5,
      TMP_K8S_DEPLOYMENT_UID5,
      TMP_K8S_DEPLOYMENT_NAME5,
      TMP_K8S_STATEFULSET_UID5,
      TMP_K8S_STATEFULSET_NAME5,
      TMP_K8S_DAEMONSET_UID5,
      TMP_K8S_DAEMONSET_NAME5,
      TMP_K8S_JOB_UID5,
      TMP_K8S_JOB_NAME5,
      TMP_K8S_CRONJOB_UID5,
      TMP_K8S_CRONJOB_NAME5,
      TMP_OS_TYPE5,
      TMP_OS_DESCRIPTION5,
      TMP_OS_NAME5,
      TMP_OS_VERSION5,
      TMP_PROCESS_PID5,
      TMP_PROCESS_EXECUTABLE_NAME5,
      TMP_PROCESS_EXECUTABLE_PATH5,
      TMP_PROCESS_COMMAND5,
      TMP_PROCESS_COMMAND_LINE5,
      TMP_PROCESS_COMMAND_ARGS5,
      TMP_PROCESS_OWNER5,
      TMP_PROCESS_RUNTIME_NAME5,
      TMP_PROCESS_RUNTIME_VERSION5,
      TMP_PROCESS_RUNTIME_DESCRIPTION5,
      TMP_SERVICE_NAME5,
      TMP_SERVICE_NAMESPACE5,
      TMP_SERVICE_INSTANCE_ID5,
      TMP_SERVICE_VERSION5,
      TMP_TELEMETRY_SDK_NAME5,
      TMP_TELEMETRY_SDK_LANGUAGE5,
      TMP_TELEMETRY_SDK_VERSION5,
      TMP_TELEMETRY_AUTO_VERSION5,
      TMP_WEBENGINE_NAME5,
      TMP_WEBENGINE_VERSION5,
      TMP_WEBENGINE_DESCRIPTION5
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD5 = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS5 = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE5 = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP5 = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD5 = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD5;
    CLOUDPROVIDERVALUES_AWS5 = TMP_CLOUDPROVIDERVALUES_AWS5;
    CLOUDPROVIDERVALUES_AZURE5 = TMP_CLOUDPROVIDERVALUES_AZURE5;
    CLOUDPROVIDERVALUES_GCP5 = TMP_CLOUDPROVIDERVALUES_GCP5;
    CloudProviderValues5 = /* @__PURE__ */ createConstMap5([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD5,
      TMP_CLOUDPROVIDERVALUES_AWS5,
      TMP_CLOUDPROVIDERVALUES_AZURE5,
      TMP_CLOUDPROVIDERVALUES_GCP5
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5 = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5 = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC25 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS5 = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS5 = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA5 = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5 = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM5 = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5 = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS5 = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5 = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5 = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5 = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5 = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5 = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5 = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE5 = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5 = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5;
    CLOUDPLATFORMVALUES_AWS_EC25 = TMP_CLOUDPLATFORMVALUES_AWS_EC25;
    CLOUDPLATFORMVALUES_AWS_ECS5 = TMP_CLOUDPLATFORMVALUES_AWS_ECS5;
    CLOUDPLATFORMVALUES_AWS_EKS5 = TMP_CLOUDPLATFORMVALUES_AWS_EKS5;
    CLOUDPLATFORMVALUES_AWS_LAMBDA5 = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA5;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5 = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5;
    CLOUDPLATFORMVALUES_AZURE_VM5 = TMP_CLOUDPLATFORMVALUES_AZURE_VM5;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5 = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5;
    CLOUDPLATFORMVALUES_AZURE_AKS5 = TMP_CLOUDPLATFORMVALUES_AZURE_AKS5;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5 = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5 = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5 = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5 = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5 = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE5 = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE5;
    CloudPlatformValues5 = /* @__PURE__ */ createConstMap5([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5,
      TMP_CLOUDPLATFORMVALUES_AWS_EC25,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS5,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS5,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA5,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM5,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS5,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE5
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC25 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE5 = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC25 = TMP_AWSECSLAUNCHTYPEVALUES_EC25;
    AWSECSLAUNCHTYPEVALUES_FARGATE5 = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE5;
    AwsEcsLaunchtypeValues5 = /* @__PURE__ */ createConstMap5([
      TMP_AWSECSLAUNCHTYPEVALUES_EC25,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE5
    ]);
    TMP_HOSTARCHVALUES_AMD645 = "amd64";
    TMP_HOSTARCHVALUES_ARM325 = "arm32";
    TMP_HOSTARCHVALUES_ARM645 = "arm64";
    TMP_HOSTARCHVALUES_IA645 = "ia64";
    TMP_HOSTARCHVALUES_PPC325 = "ppc32";
    TMP_HOSTARCHVALUES_PPC645 = "ppc64";
    TMP_HOSTARCHVALUES_X865 = "x86";
    HOSTARCHVALUES_AMD645 = TMP_HOSTARCHVALUES_AMD645;
    HOSTARCHVALUES_ARM325 = TMP_HOSTARCHVALUES_ARM325;
    HOSTARCHVALUES_ARM645 = TMP_HOSTARCHVALUES_ARM645;
    HOSTARCHVALUES_IA645 = TMP_HOSTARCHVALUES_IA645;
    HOSTARCHVALUES_PPC325 = TMP_HOSTARCHVALUES_PPC325;
    HOSTARCHVALUES_PPC645 = TMP_HOSTARCHVALUES_PPC645;
    HOSTARCHVALUES_X865 = TMP_HOSTARCHVALUES_X865;
    HostArchValues5 = /* @__PURE__ */ createConstMap5([
      TMP_HOSTARCHVALUES_AMD645,
      TMP_HOSTARCHVALUES_ARM325,
      TMP_HOSTARCHVALUES_ARM645,
      TMP_HOSTARCHVALUES_IA645,
      TMP_HOSTARCHVALUES_PPC325,
      TMP_HOSTARCHVALUES_PPC645,
      TMP_HOSTARCHVALUES_X865
    ]);
    TMP_OSTYPEVALUES_WINDOWS5 = "windows";
    TMP_OSTYPEVALUES_LINUX5 = "linux";
    TMP_OSTYPEVALUES_DARWIN5 = "darwin";
    TMP_OSTYPEVALUES_FREEBSD5 = "freebsd";
    TMP_OSTYPEVALUES_NETBSD5 = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD5 = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD5 = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX5 = "hpux";
    TMP_OSTYPEVALUES_AIX5 = "aix";
    TMP_OSTYPEVALUES_SOLARIS5 = "solaris";
    TMP_OSTYPEVALUES_Z_OS5 = "z_os";
    OSTYPEVALUES_WINDOWS5 = TMP_OSTYPEVALUES_WINDOWS5;
    OSTYPEVALUES_LINUX5 = TMP_OSTYPEVALUES_LINUX5;
    OSTYPEVALUES_DARWIN5 = TMP_OSTYPEVALUES_DARWIN5;
    OSTYPEVALUES_FREEBSD5 = TMP_OSTYPEVALUES_FREEBSD5;
    OSTYPEVALUES_NETBSD5 = TMP_OSTYPEVALUES_NETBSD5;
    OSTYPEVALUES_OPENBSD5 = TMP_OSTYPEVALUES_OPENBSD5;
    OSTYPEVALUES_DRAGONFLYBSD5 = TMP_OSTYPEVALUES_DRAGONFLYBSD5;
    OSTYPEVALUES_HPUX5 = TMP_OSTYPEVALUES_HPUX5;
    OSTYPEVALUES_AIX5 = TMP_OSTYPEVALUES_AIX5;
    OSTYPEVALUES_SOLARIS5 = TMP_OSTYPEVALUES_SOLARIS5;
    OSTYPEVALUES_Z_OS5 = TMP_OSTYPEVALUES_Z_OS5;
    OsTypeValues5 = /* @__PURE__ */ createConstMap5([
      TMP_OSTYPEVALUES_WINDOWS5,
      TMP_OSTYPEVALUES_LINUX5,
      TMP_OSTYPEVALUES_DARWIN5,
      TMP_OSTYPEVALUES_FREEBSD5,
      TMP_OSTYPEVALUES_NETBSD5,
      TMP_OSTYPEVALUES_OPENBSD5,
      TMP_OSTYPEVALUES_DRAGONFLYBSD5,
      TMP_OSTYPEVALUES_HPUX5,
      TMP_OSTYPEVALUES_AIX5,
      TMP_OSTYPEVALUES_SOLARIS5,
      TMP_OSTYPEVALUES_Z_OS5
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP5 = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET5 = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG5 = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO5 = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA5 = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS5 = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP5 = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON5 = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY5 = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS5 = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP5 = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP5;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET5 = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET5;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG5 = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG5;
    TELEMETRYSDKLANGUAGEVALUES_GO5 = TMP_TELEMETRYSDKLANGUAGEVALUES_GO5;
    TELEMETRYSDKLANGUAGEVALUES_JAVA5 = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA5;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS5 = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS5;
    TELEMETRYSDKLANGUAGEVALUES_PHP5 = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP5;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON5 = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON5;
    TELEMETRYSDKLANGUAGEVALUES_RUBY5 = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY5;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS5 = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS5;
    TelemetrySdkLanguageValues5 = /* @__PURE__ */ createConstMap5([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY5,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS5
    ]);
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource5 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes5();
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT5, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED5, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER5, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER5, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED5, ATTR_TELEMETRY_SDK_LANGUAGE5, TELEMETRY_SDK_LANGUAGE_VALUE_CPP5, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET5, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG5, TELEMETRY_SDK_LANGUAGE_VALUE_GO5, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA5, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS5, TELEMETRY_SDK_LANGUAGE_VALUE_PHP5, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON5, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY5, TELEMETRY_SDK_LANGUAGE_VALUE_RUST5, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT5, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS5, ATTR_TELEMETRY_SDK_NAME5, ATTR_TELEMETRY_SDK_VERSION5, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE5, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT5, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED5, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED5, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED5, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED5, ATTR_ASPNETCORE_RATE_LIMITING_POLICY5, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED5, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK5, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS5, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE5, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS5, ATTR_CLIENT_ADDRESS5, ATTR_CLIENT_PORT5, ATTR_ERROR_TYPE5, ERROR_TYPE_VALUE_OTHER5, ATTR_EXCEPTION_ESCAPED5, ATTR_EXCEPTION_MESSAGE5, ATTR_EXCEPTION_STACKTRACE5, ATTR_EXCEPTION_TYPE5, ATTR_HTTP_REQUEST_HEADER5, ATTR_HTTP_REQUEST_METHOD5, HTTP_REQUEST_METHOD_VALUE_OTHER5, HTTP_REQUEST_METHOD_VALUE_CONNECT5, HTTP_REQUEST_METHOD_VALUE_DELETE5, HTTP_REQUEST_METHOD_VALUE_GET5, HTTP_REQUEST_METHOD_VALUE_HEAD5, HTTP_REQUEST_METHOD_VALUE_OPTIONS5, HTTP_REQUEST_METHOD_VALUE_PATCH5, HTTP_REQUEST_METHOD_VALUE_POST5, HTTP_REQUEST_METHOD_VALUE_PUT5, HTTP_REQUEST_METHOD_VALUE_TRACE5, ATTR_HTTP_REQUEST_METHOD_ORIGINAL5, ATTR_HTTP_REQUEST_RESEND_COUNT5, ATTR_HTTP_RESPONSE_HEADER5, ATTR_HTTP_RESPONSE_STATUS_CODE5, ATTR_HTTP_ROUTE5, ATTR_JVM_GC_ACTION5, ATTR_JVM_GC_NAME5, ATTR_JVM_MEMORY_POOL_NAME5, ATTR_JVM_MEMORY_TYPE5, JVM_MEMORY_TYPE_VALUE_HEAP5, JVM_MEMORY_TYPE_VALUE_NON_HEAP5, ATTR_JVM_THREAD_DAEMON5, ATTR_JVM_THREAD_STATE5, JVM_THREAD_STATE_VALUE_BLOCKED5, JVM_THREAD_STATE_VALUE_NEW5, JVM_THREAD_STATE_VALUE_RUNNABLE5, JVM_THREAD_STATE_VALUE_TERMINATED5, JVM_THREAD_STATE_VALUE_TIMED_WAITING5, JVM_THREAD_STATE_VALUE_WAITING5, ATTR_NETWORK_LOCAL_ADDRESS5, ATTR_NETWORK_LOCAL_PORT5, ATTR_NETWORK_PEER_ADDRESS5, ATTR_NETWORK_PEER_PORT5, ATTR_NETWORK_PROTOCOL_NAME5, ATTR_NETWORK_PROTOCOL_VERSION5, ATTR_NETWORK_TRANSPORT5, NETWORK_TRANSPORT_VALUE_PIPE5, NETWORK_TRANSPORT_VALUE_QUIC5, NETWORK_TRANSPORT_VALUE_TCP5, NETWORK_TRANSPORT_VALUE_UDP5, NETWORK_TRANSPORT_VALUE_UNIX5, ATTR_NETWORK_TYPE5, NETWORK_TYPE_VALUE_IPV45, NETWORK_TYPE_VALUE_IPV65, ATTR_OTEL_SCOPE_NAME5, ATTR_OTEL_SCOPE_VERSION5, ATTR_OTEL_STATUS_CODE5, OTEL_STATUS_CODE_VALUE_ERROR5, OTEL_STATUS_CODE_VALUE_OK5, ATTR_OTEL_STATUS_DESCRIPTION5, ATTR_SERVER_ADDRESS5, ATTR_SERVER_PORT5, ATTR_SERVICE_NAME5, ATTR_SERVICE_VERSION5, ATTR_SIGNALR_CONNECTION_STATUS5, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN5, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE5, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT5, ATTR_SIGNALR_TRANSPORT5, SIGNALR_TRANSPORT_VALUE_LONG_POLLING5, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS5, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS5, ATTR_URL_FRAGMENT5, ATTR_URL_FULL5, ATTR_URL_PATH5, ATTR_URL_QUERY5, ATTR_URL_SCHEME5, ATTR_USER_AGENT_ORIGINAL5;
var init_stable_attributes5 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT5 = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED5 = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER5 = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER5 = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED5 = "request_canceled";
    ATTR_TELEMETRY_SDK_LANGUAGE5 = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP5 = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET5 = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG5 = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO5 = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA5 = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS5 = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP5 = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON5 = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY5 = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST5 = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT5 = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS5 = "webjs";
    ATTR_TELEMETRY_SDK_NAME5 = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION5 = "telemetry.sdk.version";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE5 = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT5 = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED5 = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED5 = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED5 = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED5 = "unhandled";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY5 = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED5 = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK5 = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS5 = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE5 = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS5 = "success";
    ATTR_CLIENT_ADDRESS5 = "client.address";
    ATTR_CLIENT_PORT5 = "client.port";
    ATTR_ERROR_TYPE5 = "error.type";
    ERROR_TYPE_VALUE_OTHER5 = "_OTHER";
    ATTR_EXCEPTION_ESCAPED5 = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE5 = "exception.message";
    ATTR_EXCEPTION_STACKTRACE5 = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE5 = "exception.type";
    ATTR_HTTP_REQUEST_HEADER5 = function(key) {
      return "http.request.header." + key;
    };
    ATTR_HTTP_REQUEST_METHOD5 = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER5 = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT5 = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE5 = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET5 = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD5 = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS5 = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH5 = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST5 = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT5 = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE5 = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL5 = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT5 = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER5 = function(key) {
      return "http.response.header." + key;
    };
    ATTR_HTTP_RESPONSE_STATUS_CODE5 = "http.response.status_code";
    ATTR_HTTP_ROUTE5 = "http.route";
    ATTR_JVM_GC_ACTION5 = "jvm.gc.action";
    ATTR_JVM_GC_NAME5 = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME5 = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE5 = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP5 = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP5 = "non_heap";
    ATTR_JVM_THREAD_DAEMON5 = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE5 = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED5 = "blocked";
    JVM_THREAD_STATE_VALUE_NEW5 = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE5 = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED5 = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING5 = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING5 = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS5 = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT5 = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS5 = "network.peer.address";
    ATTR_NETWORK_PEER_PORT5 = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME5 = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION5 = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT5 = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE5 = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC5 = "quic";
    NETWORK_TRANSPORT_VALUE_TCP5 = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP5 = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX5 = "unix";
    ATTR_NETWORK_TYPE5 = "network.type";
    NETWORK_TYPE_VALUE_IPV45 = "ipv4";
    NETWORK_TYPE_VALUE_IPV65 = "ipv6";
    ATTR_OTEL_SCOPE_NAME5 = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION5 = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE5 = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR5 = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK5 = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION5 = "otel.status_description";
    ATTR_SERVER_ADDRESS5 = "server.address";
    ATTR_SERVER_PORT5 = "server.port";
    ATTR_SERVICE_NAME5 = "service.name";
    ATTR_SERVICE_VERSION5 = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS5 = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN5 = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE5 = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT5 = "timeout";
    ATTR_SIGNALR_TRANSPORT5 = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING5 = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS5 = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS5 = "web_sockets";
    ATTR_URL_FRAGMENT5 = "url.fragment";
    ATTR_URL_FULL5 = "url.full";
    ATTR_URL_PATH5 = "url.path";
    ATTR_URL_QUERY5 = "url.query";
    ATTR_URL_SCHEME5 = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL5 = "user_agent.original";
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS5, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES5, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS5, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE5, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION5, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS5, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS5, METRIC_HTTP_CLIENT_REQUEST_DURATION5, METRIC_HTTP_SERVER_REQUEST_DURATION5, METRIC_JVM_CLASS_COUNT5, METRIC_JVM_CLASS_LOADED5, METRIC_JVM_CLASS_UNLOADED5, METRIC_JVM_CPU_COUNT5, METRIC_JVM_CPU_RECENT_UTILIZATION5, METRIC_JVM_CPU_TIME5, METRIC_JVM_GC_DURATION5, METRIC_JVM_MEMORY_COMMITTED5, METRIC_JVM_MEMORY_LIMIT5, METRIC_JVM_MEMORY_USED5, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC5, METRIC_JVM_THREAD_COUNT5, METRIC_KESTREL_ACTIVE_CONNECTIONS5, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES5, METRIC_KESTREL_CONNECTION_DURATION5, METRIC_KESTREL_QUEUED_CONNECTIONS5, METRIC_KESTREL_QUEUED_REQUESTS5, METRIC_KESTREL_REJECTED_CONNECTIONS5, METRIC_KESTREL_TLS_HANDSHAKE_DURATION5, METRIC_KESTREL_UPGRADED_CONNECTIONS5, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS5, METRIC_SIGNALR_SERVER_CONNECTION_DURATION5;
var init_stable_metrics5 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS5 = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES5 = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS5 = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE5 = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION5 = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS5 = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS5 = "aspnetcore.routing.match_attempts";
    METRIC_HTTP_CLIENT_REQUEST_DURATION5 = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION5 = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT5 = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED5 = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED5 = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT5 = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION5 = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME5 = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION5 = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED5 = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT5 = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED5 = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC5 = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT5 = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS5 = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES5 = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION5 = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS5 = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS5 = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS5 = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION5 = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS5 = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS5 = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION5 = "signalr.server.connection.duration";
  }
});

// node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports6 = {};
__export(esm_exports6, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED5,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED5,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED5,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED5,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED5,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER5,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER5,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED5,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE5,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS5,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT5,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE5,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY5,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT5,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED5,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK5,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS5,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS5,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT5,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE5,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED5,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE5,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE5,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE5,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER5,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD5,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL5,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT5,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER5,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE5,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE5,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION5,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME5,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME5,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE5,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON5,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE5,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS5,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT5,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS5,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT5,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME5,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION5,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT5,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE5,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME5,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION5,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE5,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION5,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS5,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT5,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME5,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION5,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS5,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT5,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE5,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME5,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION5,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT5,
  ATTR_URL_FULL: () => ATTR_URL_FULL5,
  ATTR_URL_PATH: () => ATTR_URL_PATH5,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY5,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME5,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL5,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC25,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE5,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues5,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS5,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC5,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC25,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS5,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS5,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK5,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA5,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS5,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE5,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES5,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS5,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM5,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE5,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS5,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN5,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE5,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE5,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD5,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS5,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE5,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP5,
  CloudPlatformValues: () => CloudPlatformValues5,
  CloudProviderValues: () => CloudProviderValues5,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL5,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY5,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM5,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE5,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM5,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL5,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE5,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM5,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL5,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE5,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO5,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS5,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE5,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA5,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE5,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB5,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION5,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB5,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE5,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB5,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB25,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY5,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB5,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB5,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH5,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER5,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD5,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL5,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE5,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H25,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB5,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE5,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE5,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB5,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX5,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES5,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB5,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE5,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB5,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB5,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED5,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB5,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL5,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL5,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J5,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA5,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE5,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL5,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE5,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE5,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL5,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS5,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS5,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT5,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE5,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE5,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA5,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA5,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues5,
  DbSystemValues: () => DbSystemValues5,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER5,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE5,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT5,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT5,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD5,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS5,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE5,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP5,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE5,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP5,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER5,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB5,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER5,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues5,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues5,
  FaasTriggerValues: () => FaasTriggerValues5,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD645,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM325,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM645,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA645,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC325,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC645,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X865,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_05,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_15,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_05,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC5,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY5,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT5,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE5,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET5,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD5,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS5,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER5,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH5,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST5,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT5,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE5,
  HostArchValues: () => HostArchValues5,
  HttpFlavorValues: () => HttpFlavorValues5,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP5,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP5,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED5,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW5,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE5,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED5,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING5,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING5,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED5,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT5,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE5,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC5,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS5,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE5,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS5,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES5,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS5,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS5,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION5,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE5,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS5,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION5,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION5,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT5,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED5,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED5,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT5,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION5,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME5,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION5,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED5,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT5,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED5,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC5,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT5,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS5,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES5,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION5,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS5,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS5,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS5,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION5,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS5,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS5,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION5,
  MessageTypeValues: () => MessageTypeValues5,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues5,
  MessagingOperationValues: () => MessagingOperationValues5,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT5,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE5,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD5,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_05,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A5,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B5,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS5,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM5,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP5,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN5,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN5,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE5,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR5,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA5,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS5,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL5,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE5,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN5,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI5,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED5,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC5,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP5,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP5,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP5,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER5,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE5,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX5,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE5,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC5,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP5,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP5,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX5,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV45,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV65,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues5,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues5,
  NetTransportValues: () => NetTransportValues5,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX5,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN5,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD5,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD5,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX5,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX5,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD5,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD5,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS5,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS5,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS5,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR5,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK5,
  OsTypeValues: () => OsTypeValues5,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED5,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS5,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED5,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS5,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED5,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION5,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL5,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT5,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND5,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK5,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE5,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED5,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED5,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED5,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE5,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED5,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN5,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues5,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET5,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS5,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ5,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY5,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT5,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE5,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES5,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES5,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME5,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS5,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT5,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES5,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION5,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY5,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY5,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT5,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD5,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT5,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT5,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT5,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES5,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS5,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN5,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH5,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION5,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO5,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE5,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL5,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC5,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID5,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE5,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE5,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE5,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT5,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE5,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING5,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE5,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME5,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION5,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME5,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME5,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION5,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX5,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE5,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT5,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM5,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER5,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID5,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE5,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE5,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED5,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE5,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE5,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE5,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART5,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON5,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION5,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME5,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION5,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME5,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION5,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME5,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER5,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION5,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME5,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER5,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP5,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR5,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST5,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD5,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH5,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED5,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH5,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED5,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE5,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME5,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME5,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE5,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET5,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL5,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT5,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE5,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID5,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE5,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE5,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID5,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID5,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION5,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND5,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID5,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP5,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY5,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION5,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE5,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID5,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES5,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES5,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION5,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL5,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION5,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY5,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM5,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION5,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL5,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC5,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC5,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC5,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME5,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE5,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE5,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP5,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME5,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT5,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP5,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME5,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT5,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT5,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE5,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE5,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE5,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE5,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID5,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION5,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD5,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE5,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM5,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID5,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME5,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN5,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN5,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE5,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN5,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY5,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION5,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN5,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS5,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES5,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS5,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES5,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID5,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE5,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM5,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER5,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION5,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID5,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME5,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG5,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME5,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME5,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT5,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID5,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER5,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME5,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID5,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE5,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY5,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME5,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION5,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH5,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID5,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID5,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME5,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION5,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME5,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE5,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME5,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME5,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME5,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID5,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME5,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID5,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME5,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID5,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME5,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID5,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME5,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME5,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID5,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME5,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID5,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME5,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID5,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME5,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID5,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION5,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME5,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE5,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION5,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND5,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS5,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE5,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME5,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH5,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER5,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID5,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION5,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME5,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION5,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID5,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME5,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE5,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION5,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION5,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE5,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME5,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION5,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION5,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME5,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION5,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN5,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE5,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT5,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING5,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS5,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS5,
  SemanticAttributes: () => SemanticAttributes5,
  SemanticResourceAttributes: () => SemanticResourceAttributes5,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP5,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET5,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG5,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO5,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA5,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS5,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP5,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON5,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY5,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS5,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP5,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET5,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG5,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO5,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA5,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS5,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP5,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON5,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY5,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST5,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT5,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS5,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues5
});
var init_esm6 = __esm({
  "node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace6();
    init_resource5();
    init_stable_attributes5();
    init_stable_metrics5();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports2.defaultServiceName = defaultServiceName;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node6 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    var default_service_name_1 = require_default_service_name();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: true, get: function() {
      return default_service_name_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform5 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    var node_1 = require_node6();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: true, get: function() {
      return node_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/Resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Resource = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var core_1 = require_src();
    var platform_1 = require_platform5();
    var Resource2 = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then((asyncAttributes) => {
          this._attributes = Object.assign({}, this._attributes, asyncAttributes);
          this.asyncAttributesPending = false;
          return asyncAttributes;
        }, (err) => {
          api_1.diag.debug("a resource's async attributes promise rejected: %s", err);
          this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a;
        if (this.asyncAttributesPending) {
          api_1.diag.error("Accessing resource attributes before async attributes settled");
        }
        return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        if (this.asyncAttributesPending) {
          await this._asyncAttributesPromise;
        }
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a;
        if (!other)
          return this;
        const mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new _Resource(mergedSyncAttributes);
        }
        const mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a2;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports2.Resource = Resource2;
    Resource2.EMPTY = new Resource2({});
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeType = exports2.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports2.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports2.normalizeType = normalizeType;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.execAsync = void 0;
    var child_process = require("child_process");
    var util3 = require("util");
    exports2.execAsync = util3.promisify(child_process.exec);
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
        const idLine = result.stdout.split("\n").find((line) => line.includes("IOPlatformUUID"));
        if (!idLine) {
          return "";
        }
        const parts = idLine.split('" = "');
        if (parts.length === 2) {
          return parts[1].slice(0, -1);
        }
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var fs_1 = require("fs");
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (const path of paths) {
        try {
          const result = await fs_1.promises.readFile(path, { encoding: "utf8" });
          return result.trim();
        } catch (e) {
          api_1.diag.debug(`error reading machine id: ${e}`);
        }
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var fs_1 = require("fs");
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
        return result.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      try {
        const result = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
        return result.stdout.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var process2 = require("process");
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
      let command = "%windir%\\System32\\REG.exe";
      if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
        command = "%windir%\\sysnative\\cmd.exe /c " + command;
      }
      try {
        const result = await (0, execAsync_1.execAsync)(`${command} ${args}`);
        const parts = result.stdout.split("REG_SZ");
        if (parts.length === 2) {
          return parts[1].trim();
        }
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      api_1.diag.debug("could not read machine-id: unsupported platform");
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var process2 = require("process");
    var getMachineId;
    exports2.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports2.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
        break;
      case "linux":
        exports2.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
        break;
      case "freebsd":
        exports2.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
        break;
      case "win32":
        exports2.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
        break;
      default:
        exports2.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
    }
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hostDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var Resource_1 = require_Resource();
    var os_1 = require("os");
    var utils_1 = require_utils4();
    var getMachineId_1 = require_getMachineId();
    var HostDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SEMRESATTRS_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          const attributes = {};
          if (machineId) {
            attributes[semantic_conventions_1.SEMRESATTRS_HOST_ID] = machineId;
          }
          return attributes;
        });
      }
    };
    exports2.hostDetectorSync = new HostDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync();
    var HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports2.hostDetector = new HostDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.osDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var Resource_1 = require_Resource();
    var os_1 = require("os");
    var utils_1 = require_utils4();
    var OSDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SEMRESATTRS_OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.osDetectorSync = new OSDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync();
    var OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports2.osDetector = new OSDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var Resource_1 = require_Resource();
    var os4 = require("os");
    var ProcessDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_PID]: process.pid,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        if (process.argv.length > 1) {
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND] = process.argv[1];
        }
        try {
          const userInfo = os4.userInfo();
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.processDetectorSync = new ProcessDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    var ProcessDetector = class {
      detect(config2) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config2));
      }
    };
    exports2.processDetector = new ProcessDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js
var require_ServiceInstanceIdDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceInstanceIdDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var Resource_1 = require_Resource();
    var crypto_1 = require("crypto");
    var ServiceInstanceIdDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.serviceInstanceIdDetectorSync = new ServiceInstanceIdDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node7 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var HostDetector_1 = require_HostDetector();
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return HostDetector_1.hostDetector;
    } });
    var HostDetectorSync_1 = require_HostDetectorSync();
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return HostDetectorSync_1.hostDetectorSync;
    } });
    var OSDetector_1 = require_OSDetector();
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return OSDetector_1.osDetector;
    } });
    var OSDetectorSync_1 = require_OSDetectorSync();
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return OSDetectorSync_1.osDetectorSync;
    } });
    var ProcessDetector_1 = require_ProcessDetector();
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return ProcessDetector_1.processDetector;
    } });
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return ProcessDetectorSync_1.processDetectorSync;
    } });
    var ServiceInstanceIdDetectorSync_1 = require_ServiceInstanceIdDetectorSync();
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return ServiceInstanceIdDetectorSync_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform6 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var node_1 = require_node7();
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return node_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return node_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return node_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return node_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return node_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return node_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return node_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.browserDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Resource_1 = require_Resource();
    var BrowserDetectorSync = class {
      detect(config2) {
        var _a, _b, _c;
        const isBrowser = typeof navigator !== "undefined" && ((_b = (_a = global.process) === null || _a === void 0 ? void 0 : _a.versions) === null || _b === void 0 ? void 0 : _b.node) === void 0 && // Node.js v21 adds `navigator`
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore don't have Bun types
        ((_c = global.Bun) === null || _c === void 0 ? void 0 : _c.version) === void 0;
        if (!isBrowser) {
          return Resource_1.Resource.empty();
        }
        const browserResource = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config2);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        if (browserResource[semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION] === "") {
          api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return Resource_1.Resource.empty();
        } else {
          return new Resource_1.Resource(Object.assign({}, browserResource));
        }
      }
    };
    exports2.browserDetectorSync = new BrowserDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.browserDetector = void 0;
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    var BrowserDetector = class {
      detect(config2) {
        return Promise.resolve(BrowserDetectorSync_1.browserDetectorSync.detect(config2));
      }
    };
    exports2.browserDetector = new BrowserDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var semantic_conventions_1 = (init_esm6(), __toCommonJS(esm_exports6));
    var Resource_1 = require_Resource();
    var EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        const attributes = {};
        const env = (0, core_1.getEnv)();
        const rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES;
        const serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes) {
          try {
            const parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e) {
            api_1.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        }
        if (serviceName) {
          attributes[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME] = serviceName;
        }
        return new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. key1=val1,key2=val2. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespace, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-separated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        const attributes = {};
        const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (const rawAttribute of rawAttributes) {
          const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2) {
            continue;
          }
          let [key, value] = keyValuePair;
          key = key.trim();
          value = value.trim().split(/^"|"$/).join("");
          if (!this._isValidAndNotEmpty(key)) {
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          }
          if (!this._isValid(value)) {
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          }
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          const ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports2.envDetectorSync = new EnvDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    var EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config2) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config2));
      }
    };
    exports2.envDetector = new EnvDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetectorSync = exports2.browserDetectorSync = exports2.envDetector = exports2.browserDetector = exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var platform_1 = require_platform6();
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return platform_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return platform_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return platform_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return platform_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return platform_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return platform_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return platform_1.serviceInstanceIdDetectorSync;
    } });
    var BrowserDetector_1 = require_BrowserDetector();
    Object.defineProperty(exports2, "browserDetector", { enumerable: true, get: function() {
      return BrowserDetector_1.browserDetector;
    } });
    var EnvDetector_1 = require_EnvDetector();
    Object.defineProperty(exports2, "envDetector", { enumerable: true, get: function() {
      return EnvDetector_1.envDetector;
    } });
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    Object.defineProperty(exports2, "browserDetectorSync", { enumerable: true, get: function() {
      return BrowserDetectorSync_1.browserDetectorSync;
    } });
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    Object.defineProperty(exports2, "envDetectorSync", { enumerable: true, get: function() {
      return EnvDetectorSync_1.envDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils5 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromiseLike = void 0;
    var isPromiseLike = (val) => {
      return val !== null && typeof val === "object" && typeof val.then === "function";
    };
    exports2.isPromiseLike = isPromiseLike;
  }
});

// node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectResourcesSync = exports2.detectResources = void 0;
    var Resource_1 = require_Resource();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils5();
    var detectResources = async (config2 = {}) => {
      const resources = await Promise.all((config2.detectors || []).map(async (d) => {
        try {
          const resource = await d.detect(config2);
          api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
          return resource;
        } catch (e) {
          api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`);
          return Resource_1.Resource.empty();
        }
      }));
      logResources(resources);
      return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports2.detectResources = detectResources;
    var detectResourcesSync = (config2 = {}) => {
      var _a;
      const resources = ((_a = config2.detectors) !== null && _a !== void 0 ? _a : []).map((d) => {
        try {
          const resourceOrPromise = d.detect(config2);
          let resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            const createPromise = async () => {
              var _a2;
              const resolvedResource = await resourceOrPromise;
              await ((_a2 = resolvedResource.waitForAsyncAttributes) === null || _a2 === void 0 ? void 0 : _a2.call(resolvedResource));
              return resolvedResource.attributes;
            };
            resource = new Resource_1.Resource({}, createPromise());
          } else {
            resource = resourceOrPromise;
          }
          if (resource.waitForAsyncAttributes) {
            void resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource));
          } else {
            api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
          }
          return resource;
        } catch (e) {
          api_1.diag.error(`${d.constructor.name} failed: ${e.message}`);
          return Resource_1.Resource.empty();
        }
      });
      const mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(() => {
          logResources(resources);
        });
      }
      return mergedResources;
    };
    exports2.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          const resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// node_modules/@opentelemetry/resources/build/src/index.js
var require_src7 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectResources = exports2.detectResourcesSync = exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = exports2.envDetectorSync = exports2.envDetector = exports2.browserDetectorSync = exports2.browserDetector = exports2.defaultServiceName = exports2.Resource = void 0;
    var Resource_1 = require_Resource();
    Object.defineProperty(exports2, "Resource", { enumerable: true, get: function() {
      return Resource_1.Resource;
    } });
    var platform_1 = require_platform5();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: true, get: function() {
      return platform_1.defaultServiceName;
    } });
    var detectors_1 = require_detectors();
    Object.defineProperty(exports2, "browserDetector", { enumerable: true, get: function() {
      return detectors_1.browserDetector;
    } });
    Object.defineProperty(exports2, "browserDetectorSync", { enumerable: true, get: function() {
      return detectors_1.browserDetectorSync;
    } });
    Object.defineProperty(exports2, "envDetector", { enumerable: true, get: function() {
      return detectors_1.envDetector;
    } });
    Object.defineProperty(exports2, "envDetectorSync", { enumerable: true, get: function() {
      return detectors_1.envDetectorSync;
    } });
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return detectors_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return detectors_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return detectors_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return detectors_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return detectors_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return detectors_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return detectors_1.serviceInstanceIdDetectorSync;
    } });
    var detect_resources_1 = require_detect_resources();
    Object.defineProperty(exports2, "detectResourcesSync", { enumerable: true, get: function() {
      return detect_resources_1.detectResourcesSync;
    } });
    Object.defineProperty(exports2, "detectResources", { enumerable: true, get: function() {
      return detect_resources_1.detectResources;
    } });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js
var require_MultiSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiSpanProcessor = void 0;
    var core_1 = require_src();
    var MultiSpanProcessor = class {
      constructor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      forceFlush() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
          promises.push(spanProcessor.forceFlush());
        }
        return new Promise((resolve2) => {
          Promise.all(promises).then(() => {
            resolve2();
          }).catch((error) => {
            (0, core_1.globalErrorHandler)(error || new Error("MultiSpanProcessor: forceFlush failed"));
            resolve2();
          });
        });
      }
      onStart(span, context3) {
        for (const spanProcessor of this._spanProcessors) {
          spanProcessor.onStart(span, context3);
        }
      }
      onEnd(span) {
        for (const spanProcessor of this._spanProcessors) {
          spanProcessor.onEnd(span);
        }
      }
      shutdown() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
          promises.push(spanProcessor.shutdown());
        }
        return new Promise((resolve2, reject) => {
          Promise.all(promises).then(() => {
            resolve2();
          }, reject);
        });
      }
    };
    exports2.MultiSpanProcessor = MultiSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js
var require_NoopSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoopSpanProcessor = void 0;
    var NoopSpanProcessor = class {
      onStart(_span, _context) {
      }
      onEnd(_span) {
      }
      shutdown() {
        return Promise.resolve();
      }
      forceFlush() {
        return Promise.resolve();
      }
    };
    exports2.NoopSpanProcessor = NoopSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js
var require_BasicTracerProvider = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicTracerProvider = exports2.ForceFlushState = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var resources_1 = require_src7();
    var Tracer_1 = require_Tracer();
    var config_1 = require_config();
    var MultiSpanProcessor_1 = require_MultiSpanProcessor();
    var NoopSpanProcessor_1 = require_NoopSpanProcessor();
    var platform_1 = require_platform4();
    var utility_1 = require_utility();
    var ForceFlushState;
    (function(ForceFlushState2) {
      ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
      ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
      ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
      ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
    })(ForceFlushState = exports2.ForceFlushState || (exports2.ForceFlushState = {}));
    var BasicTracerProvider2 = class {
      constructor(config2 = {}) {
        var _a, _b;
        this._registeredSpanProcessors = [];
        this._tracers = /* @__PURE__ */ new Map();
        const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config2));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : resources_1.Resource.empty();
        if (mergedConfig.mergeResourceWithDefaults) {
          this.resource = resources_1.Resource.default().merge(this.resource);
        }
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        if ((_b = config2.spanProcessors) === null || _b === void 0 ? void 0 : _b.length) {
          this._registeredSpanProcessors = [...config2.spanProcessors];
          this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
        } else {
          const defaultExporter = this._buildExporterFromEnv();
          if (defaultExporter !== void 0) {
            const batchProcessor = new platform_1.BatchSpanProcessor(defaultExporter);
            this.activeSpanProcessor = batchProcessor;
          } else {
            this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor();
          }
        }
      }
      getTracer(name, version, options) {
        const key = `${name}@${version || ""}:${(options === null || options === void 0 ? void 0 : options.schemaUrl) || ""}`;
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer_1.Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
        }
        return this._tracers.get(key);
      }
      /**
       * @deprecated please use {@link TracerConfig} spanProcessors property
       * Adds a new {@link SpanProcessor} to this tracer.
       * @param spanProcessor the new SpanProcessor to be added.
       */
      addSpanProcessor(spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          this.activeSpanProcessor.shutdown().catch((err) => api_1.diag.error("Error while trying to shutdown current span processor", err));
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
      }
      getActiveSpanProcessor() {
        return this.activeSpanProcessor;
      }
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      register(config2 = {}) {
        api_1.trace.setGlobalTracerProvider(this);
        if (config2.propagator === void 0) {
          config2.propagator = this._buildPropagatorFromEnv();
        }
        if (config2.contextManager) {
          api_1.context.setGlobalContextManager(config2.contextManager);
        }
        if (config2.propagator) {
          api_1.propagation.setGlobalPropagator(config2.propagator);
        }
      }
      forceFlush() {
        const timeout = this._config.forceFlushTimeoutMillis;
        const promises = this._registeredSpanProcessors.map((spanProcessor) => {
          return new Promise((resolve2) => {
            let state;
            const timeoutInterval = setTimeout(() => {
              resolve2(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));
              state = ForceFlushState.timeout;
            }, timeout);
            spanProcessor.forceFlush().then(() => {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve2(state);
              }
            }).catch((error) => {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve2(error);
            });
          });
        });
        return new Promise((resolve2, reject) => {
          Promise.all(promises).then((results) => {
            const errors = results.filter((result) => result !== ForceFlushState.resolved);
            if (errors.length > 0) {
              reject(errors);
            } else {
              resolve2();
            }
          }).catch((error) => reject([error]));
        });
      }
      shutdown() {
        return this.activeSpanProcessor.shutdown();
      }
      /**
       * TS cannot yet infer the type of this.constructor:
       * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
       * There is no need to override either of the getters in your child class.
       * The type of the registered component maps should be the same across all
       * classes in the inheritance tree.
       */
      _getPropagator(name) {
        var _a;
        return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();
      }
      _getSpanExporter(name) {
        var _a;
        return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();
      }
      _buildPropagatorFromEnv() {
        const uniquePropagatorNames = Array.from(new Set((0, core_1.getEnv)().OTEL_PROPAGATORS));
        const propagators = uniquePropagatorNames.map((name) => {
          const propagator = this._getPropagator(name);
          if (!propagator) {
            api_1.diag.warn(`Propagator "${name}" requested through environment variable is unavailable.`);
          }
          return propagator;
        });
        const validPropagators = propagators.reduce((list, item) => {
          if (item) {
            list.push(item);
          }
          return list;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new core_1.CompositePropagator({
            propagators: validPropagators
          });
        }
      }
      _buildExporterFromEnv() {
        const exporterName = (0, core_1.getEnv)().OTEL_TRACES_EXPORTER;
        if (exporterName === "none" || exporterName === "")
          return;
        const exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          api_1.diag.error(`Exporter "${exporterName}" requested through environment variable is unavailable.`);
        }
        return exporter;
      }
    };
    exports2.BasicTracerProvider = BasicTracerProvider2;
    BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([
      ["tracecontext", () => new core_1.W3CTraceContextPropagator()],
      ["baggage", () => new core_1.W3CBaggagePropagator()]
    ]);
    BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js
var require_ConsoleSpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleSpanExporter = void 0;
    var core_1 = require_src();
    var ConsoleSpanExporter = class {
      /**
       * Export spans.
       * @param spans
       * @param resultCallback
       */
      export(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
      }
      /**
       * Shutdown the exporter.
       */
      shutdown() {
        this._sendSpans([]);
        return this.forceFlush();
      }
      /**
       * Exports any pending spans in exporter
       */
      forceFlush() {
        return Promise.resolve();
      }
      /**
       * converts span info into more readable format
       * @param span
       */
      _exportInfo(span) {
        var _a;
        return {
          resource: {
            attributes: span.resource.attributes
          },
          instrumentationScope: span.instrumentationLibrary,
          traceId: span.spanContext().traceId,
          parentId: span.parentSpanId,
          traceState: (_a = span.spanContext().traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
          name: span.name,
          id: span.spanContext().spanId,
          kind: span.kind,
          timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
          duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
          attributes: span.attributes,
          status: span.status,
          events: span.events,
          links: span.links
        };
      }
      /**
       * Showing spans in console
       * @param spans
       * @param done
       */
      _sendSpans(spans, done) {
        for (const span of spans) {
          console.dir(this._exportInfo(span), { depth: 3 });
        }
        if (done) {
          return done({ code: core_1.ExportResultCode.SUCCESS });
        }
      }
    };
    exports2.ConsoleSpanExporter = ConsoleSpanExporter;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js
var require_InMemorySpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemorySpanExporter = void 0;
    var core_1 = require_src();
    var InMemorySpanExporter = class {
      constructor() {
        this._finishedSpans = [];
        this._stopped = false;
      }
      export(spans, resultCallback) {
        if (this._stopped)
          return resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Exporter has been stopped")
          });
        this._finishedSpans.push(...spans);
        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      shutdown() {
        this._stopped = true;
        this._finishedSpans = [];
        return this.forceFlush();
      }
      /**
       * Exports any pending spans in the exporter
       */
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._finishedSpans = [];
      }
      getFinishedSpans() {
        return this._finishedSpans;
      }
    };
    exports2.InMemorySpanExporter = InMemorySpanExporter;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js
var require_SimpleSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleSpanProcessor = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var SimpleSpanProcessor = class {
      constructor(_exporter) {
        this._exporter = _exporter;
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        this._unresolvedExports = /* @__PURE__ */ new Set();
      }
      async forceFlush() {
        await Promise.all(Array.from(this._unresolvedExports));
        if (this._exporter.forceFlush) {
          await this._exporter.forceFlush();
        }
      }
      onStart(_span, _parentContext) {
      }
      onEnd(span) {
        var _a, _b;
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
          return;
        }
        const doExport = () => core_1.internal._export(this._exporter, [span]).then((result) => {
          var _a2;
          if (result.code !== core_1.ExportResultCode.SUCCESS) {
            (0, core_1.globalErrorHandler)((_a2 = result.error) !== null && _a2 !== void 0 ? _a2 : new Error(`SimpleSpanProcessor: span export failed (status ${result})`));
          }
        }).catch((error) => {
          (0, core_1.globalErrorHandler)(error);
        });
        if (span.resource.asyncAttributesPending) {
          const exportPromise = (_b = (_a = span.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a).then(() => {
            if (exportPromise != null) {
              this._unresolvedExports.delete(exportPromise);
            }
            return doExport();
          }, (err) => (0, core_1.globalErrorHandler)(err));
          if (exportPromise != null) {
            this._unresolvedExports.add(exportPromise);
          }
        } else {
          void doExport();
        }
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return this._exporter.shutdown();
      }
    };
    exports2.SimpleSpanProcessor = SimpleSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/index.js
var require_src8 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Span = exports2.SamplingDecision = exports2.TraceIdRatioBasedSampler = exports2.ParentBasedSampler = exports2.AlwaysOnSampler = exports2.AlwaysOffSampler = exports2.NoopSpanProcessor = exports2.SimpleSpanProcessor = exports2.InMemorySpanExporter = exports2.ConsoleSpanExporter = exports2.RandomIdGenerator = exports2.BatchSpanProcessor = exports2.ForceFlushState = exports2.BasicTracerProvider = exports2.Tracer = void 0;
    var Tracer_1 = require_Tracer();
    Object.defineProperty(exports2, "Tracer", { enumerable: true, get: function() {
      return Tracer_1.Tracer;
    } });
    var BasicTracerProvider_1 = require_BasicTracerProvider();
    Object.defineProperty(exports2, "BasicTracerProvider", { enumerable: true, get: function() {
      return BasicTracerProvider_1.BasicTracerProvider;
    } });
    Object.defineProperty(exports2, "ForceFlushState", { enumerable: true, get: function() {
      return BasicTracerProvider_1.ForceFlushState;
    } });
    var platform_1 = require_platform4();
    Object.defineProperty(exports2, "BatchSpanProcessor", { enumerable: true, get: function() {
      return platform_1.BatchSpanProcessor;
    } });
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return platform_1.RandomIdGenerator;
    } });
    var ConsoleSpanExporter_1 = require_ConsoleSpanExporter();
    Object.defineProperty(exports2, "ConsoleSpanExporter", { enumerable: true, get: function() {
      return ConsoleSpanExporter_1.ConsoleSpanExporter;
    } });
    var InMemorySpanExporter_1 = require_InMemorySpanExporter();
    Object.defineProperty(exports2, "InMemorySpanExporter", { enumerable: true, get: function() {
      return InMemorySpanExporter_1.InMemorySpanExporter;
    } });
    var SimpleSpanProcessor_1 = require_SimpleSpanProcessor();
    Object.defineProperty(exports2, "SimpleSpanProcessor", { enumerable: true, get: function() {
      return SimpleSpanProcessor_1.SimpleSpanProcessor;
    } });
    var NoopSpanProcessor_1 = require_NoopSpanProcessor();
    Object.defineProperty(exports2, "NoopSpanProcessor", { enumerable: true, get: function() {
      return NoopSpanProcessor_1.NoopSpanProcessor;
    } });
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    Object.defineProperty(exports2, "AlwaysOffSampler", { enumerable: true, get: function() {
      return AlwaysOffSampler_1.AlwaysOffSampler;
    } });
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    Object.defineProperty(exports2, "AlwaysOnSampler", { enumerable: true, get: function() {
      return AlwaysOnSampler_1.AlwaysOnSampler;
    } });
    var ParentBasedSampler_1 = require_ParentBasedSampler2();
    Object.defineProperty(exports2, "ParentBasedSampler", { enumerable: true, get: function() {
      return ParentBasedSampler_1.ParentBasedSampler;
    } });
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
    Object.defineProperty(exports2, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
      return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
    } });
    var Sampler_1 = require_Sampler();
    Object.defineProperty(exports2, "SamplingDecision", { enumerable: true, get: function() {
      return Sampler_1.SamplingDecision;
    } });
    var Span_1 = require_Span();
    Object.defineProperty(exports2, "Span", { enumerable: true, get: function() {
      return Span_1.Span;
    } });
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/enums/ExpressLayerType.js
var require_ExpressLayerType = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/enums/ExpressLayerType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpressLayerType = void 0;
    var ExpressLayerType2;
    (function(ExpressLayerType3) {
      ExpressLayerType3["ROUTER"] = "router";
      ExpressLayerType3["MIDDLEWARE"] = "middleware";
      ExpressLayerType3["REQUEST_HANDLER"] = "request_handler";
    })(ExpressLayerType2 = exports2.ExpressLayerType || (exports2.ExpressLayerType = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/enums/AttributeNames.js
var require_AttributeNames2 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["EXPRESS_TYPE"] = "express.type";
      AttributeNames3["EXPRESS_NAME"] = "express.name";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/internal-types.js
var require_internal_types = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._LAYERS_STORE_PROPERTY = exports2.kLayerPatched = void 0;
    exports2.kLayerPatched = Symbol("express-layer-patched");
    exports2._LAYERS_STORE_PROPERTY = "__ot_middlewares";
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/utils.js
var require_utils6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLayerPath = exports2.asErrorAndMessage = exports2.isLayerIgnored = exports2.getLayerMetadata = exports2.getRouterPath = exports2.storeLayerPath = void 0;
    var ExpressLayerType_1 = require_ExpressLayerType();
    var AttributeNames_1 = require_AttributeNames2();
    var internal_types_1 = require_internal_types();
    var storeLayerPath2 = (request, value) => {
      if (Array.isArray(request[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
        Object.defineProperty(request, internal_types_1._LAYERS_STORE_PROPERTY, {
          enumerable: false,
          value: []
        });
      }
      if (value === void 0)
        return;
      request[internal_types_1._LAYERS_STORE_PROPERTY].push(value);
    };
    exports2.storeLayerPath = storeLayerPath2;
    var getRouterPath2 = (path, layer) => {
      var _a, _b, _c, _d;
      const stackLayer = (_b = (_a = layer.handle) === null || _a === void 0 ? void 0 : _a.stack) === null || _b === void 0 ? void 0 : _b[0];
      if ((_c = stackLayer === null || stackLayer === void 0 ? void 0 : stackLayer.route) === null || _c === void 0 ? void 0 : _c.path) {
        return `${path}${stackLayer.route.path}`;
      }
      if ((_d = stackLayer === null || stackLayer === void 0 ? void 0 : stackLayer.handle) === null || _d === void 0 ? void 0 : _d.stack) {
        return (0, exports2.getRouterPath)(path, stackLayer);
      }
      return path;
    };
    exports2.getRouterPath = getRouterPath2;
    var getLayerMetadata2 = (route, layer, layerPath) => {
      var _a;
      if (layer.name === "router") {
        const maybeRouterPath = (0, exports2.getRouterPath)("", layer);
        const extractedRouterPath = maybeRouterPath ? maybeRouterPath : layerPath || route || "/";
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXPRESS_NAME]: extractedRouterPath,
            [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.ROUTER
          },
          name: `router - ${extractedRouterPath}`
        };
      } else if (layer.name === "bound dispatch") {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXPRESS_NAME]: (_a = route || layerPath) !== null && _a !== void 0 ? _a : "request handler",
            [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.REQUEST_HANDLER
          },
          name: `request handler${layer.path ? ` - ${route || layerPath}` : ""}`
        };
      } else {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layer.name,
            [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.MIDDLEWARE
          },
          name: `middleware - ${layer.name}`
        };
      }
    };
    exports2.getLayerMetadata = getLayerMetadata2;
    var satisfiesPattern2 = (constant, pattern) => {
      if (typeof pattern === "string") {
        return pattern === constant;
      } else if (pattern instanceof RegExp) {
        return pattern.test(constant);
      } else if (typeof pattern === "function") {
        return pattern(constant);
      } else {
        throw new TypeError("Pattern is in unsupported datatype");
      }
    };
    var isLayerIgnored2 = (name, type, config2) => {
      var _a;
      if (Array.isArray(config2 === null || config2 === void 0 ? void 0 : config2.ignoreLayersType) && ((_a = config2 === null || config2 === void 0 ? void 0 : config2.ignoreLayersType) === null || _a === void 0 ? void 0 : _a.includes(type))) {
        return true;
      }
      if (Array.isArray(config2 === null || config2 === void 0 ? void 0 : config2.ignoreLayers) === false)
        return false;
      try {
        for (const pattern of config2.ignoreLayers) {
          if (satisfiesPattern2(name, pattern)) {
            return true;
          }
        }
      } catch (e) {
      }
      return false;
    };
    exports2.isLayerIgnored = isLayerIgnored2;
    var asErrorAndMessage2 = (error) => error instanceof Error ? [error, error.message] : [String(error), String(error)];
    exports2.asErrorAndMessage = asErrorAndMessage2;
    var getLayerPath2 = (args) => {
      const firstArg = args[0];
      if (Array.isArray(firstArg)) {
        return firstArg.map((arg) => extractLayerPathSegment2(arg) || "").join(",");
      }
      return extractLayerPathSegment2(firstArg);
    };
    exports2.getLayerPath = getLayerPath2;
    var extractLayerPathSegment2 = (arg) => {
      if (typeof arg === "string") {
        return arg;
      }
      if (arg instanceof RegExp || typeof arg === "number") {
        return arg.toString();
      }
      return;
    };
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/version.js
var require_version4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.47.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-express";
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/instrumentation.js
var require_instrumentation3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpressInstrumentation = void 0;
    var core_1 = require_src();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var ExpressLayerType_1 = require_ExpressLayerType();
    var AttributeNames_1 = require_AttributeNames2();
    var utils_1 = require_utils6();
    var version_1 = require_version4();
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var internal_types_1 = require_internal_types();
    var ExpressInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("express", [">=4.0.0 <5"], (moduleExports) => {
            const routerProto = moduleExports.Router;
            if ((0, instrumentation_1.isWrapped)(routerProto.route)) {
              this._unwrap(routerProto, "route");
            }
            this._wrap(routerProto, "route", this._getRoutePatch());
            if ((0, instrumentation_1.isWrapped)(routerProto.use)) {
              this._unwrap(routerProto, "use");
            }
            this._wrap(routerProto, "use", this._getRouterUsePatch());
            if ((0, instrumentation_1.isWrapped)(moduleExports.application.use)) {
              this._unwrap(moduleExports.application, "use");
            }
            this._wrap(
              moduleExports.application,
              "use",
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this._getAppUsePatch()
            );
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === void 0)
              return;
            const routerProto = moduleExports.Router;
            this._unwrap(routerProto, "route");
            this._unwrap(routerProto, "use");
            this._unwrap(moduleExports.application, "use");
          })
        ];
      }
      /**
       * Get the patch for Router.route function
       */
      _getRoutePatch() {
        const instrumentation = this;
        return function(original) {
          return function route_trace(...args) {
            const route = original.apply(this, args);
            const layer = this.stack[this.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
            return route;
          };
        };
      }
      /**
       * Get the patch for Router.use function
       */
      _getRouterUsePatch() {
        const instrumentation = this;
        return function(original) {
          return function use(...args) {
            const route = original.apply(this, args);
            const layer = this.stack[this.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
            return route;
          };
        };
      }
      /**
       * Get the patch for Application.use function
       */
      _getAppUsePatch() {
        const instrumentation = this;
        return function(original) {
          return function use(...args) {
            const route = original.apply(this, args);
            const layer = this._router.stack[this._router.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
            return route;
          };
        };
      }
      /** Patch each express layer to create span and propagate context */
      _applyPatch(layer, layerPath) {
        const instrumentation = this;
        if (layer[internal_types_1.kLayerPatched] === true)
          return;
        layer[internal_types_1.kLayerPatched] = true;
        this._wrap(layer, "handle", (original) => {
          if (original.length === 4)
            return original;
          const patched = function(req, res) {
            (0, utils_1.storeLayerPath)(req, layerPath);
            const route = req[internal_types_1._LAYERS_STORE_PROPERTY].filter((path) => path !== "/" && path !== "/*").join("").replace(/\/{2,}/g, "/");
            const attributes = {
              [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.length > 0 ? route : "/"
            };
            const metadata = (0, utils_1.getLayerMetadata)(route, layer, layerPath);
            const type = metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE];
            const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
            if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
              rpcMetadata.route = route || "/";
            }
            if ((0, utils_1.isLayerIgnored)(metadata.name, type, instrumentation.getConfig())) {
              if (type === ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
                req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
              }
              return original.apply(this, arguments);
            }
            if (api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return original.apply(this, arguments);
            }
            const spanName = instrumentation._getSpanName({
              request: req,
              layerType: type,
              route
            }, metadata.name);
            const span = instrumentation.tracer.startSpan(spanName, {
              attributes: Object.assign(attributes, metadata.attributes)
            });
            const { requestHook: requestHook2 } = instrumentation.getConfig();
            if (requestHook2) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook2(span, {
                request: req,
                layerType: type,
                route
              }), (e) => {
                if (e) {
                  api_1.diag.error("express instrumentation: request hook failed", e);
                }
              }, true);
            }
            let spanHasEnded = false;
            if (metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE] !== ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
              span.end();
              spanHasEnded = true;
            }
            const onResponseFinish = () => {
              if (spanHasEnded === false) {
                spanHasEnded = true;
                span.end();
              }
            };
            const args = Array.from(arguments);
            const callbackIdx = args.findIndex((arg) => typeof arg === "function");
            if (callbackIdx >= 0) {
              arguments[callbackIdx] = function() {
                var _a;
                const maybeError = arguments[0];
                const isError2 = ![void 0, null, "route", "router"].includes(maybeError);
                if (!spanHasEnded && isError2) {
                  const [error, message] = (0, utils_1.asErrorAndMessage)(maybeError);
                  span.recordException(error);
                  span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message
                  });
                }
                if (spanHasEnded === false) {
                  spanHasEnded = true;
                  (_a = req.res) === null || _a === void 0 ? void 0 : _a.removeListener("finish", onResponseFinish);
                  span.end();
                }
                if (!(req.route && isError2)) {
                  req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
                }
                const callback = args[callbackIdx];
                return callback.apply(this, arguments);
              };
            }
            try {
              return original.apply(this, arguments);
            } catch (anyError) {
              const [error, message] = (0, utils_1.asErrorAndMessage)(anyError);
              span.recordException(error);
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message
              });
              throw anyError;
            } finally {
              if (!spanHasEnded) {
                res.once("finish", onResponseFinish);
              }
            }
          };
          for (const key in original) {
            Object.defineProperty(patched, key, {
              get() {
                return original[key];
              },
              set(value) {
                original[key] = value;
              }
            });
          }
          return patched;
        });
      }
      _getSpanName(info, defaultName) {
        var _a;
        const { spanNameHook: spanNameHook2 } = this.getConfig();
        if (!(spanNameHook2 instanceof Function)) {
          return defaultName;
        }
        try {
          return (_a = spanNameHook2(info, defaultName)) !== null && _a !== void 0 ? _a : defaultName;
        } catch (err) {
          api_1.diag.error("express instrumentation: error calling span name rewrite hook", err);
          return defaultName;
        }
      }
    };
    exports2.ExpressInstrumentation = ExpressInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/types.js
var require_types2 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-express/build/src/index.js
var require_src9 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-express/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation3(), exports2);
    __exportStar(require_ExpressLayerType(), exports2);
    __exportStar(require_AttributeNames2(), exports2);
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/enums/AttributeNames.js
var require_AttributeNames3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FastifyNames = exports2.FastifyTypes = exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["FASTIFY_NAME"] = "fastify.name";
      AttributeNames3["FASTIFY_TYPE"] = "fastify.type";
      AttributeNames3["HOOK_NAME"] = "hook.name";
      AttributeNames3["PLUGIN_NAME"] = "plugin.name";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
    var FastifyTypes;
    (function(FastifyTypes2) {
      FastifyTypes2["MIDDLEWARE"] = "middleware";
      FastifyTypes2["REQUEST_HANDLER"] = "request_handler";
    })(FastifyTypes = exports2.FastifyTypes || (exports2.FastifyTypes = {}));
    var FastifyNames;
    (function(FastifyNames2) {
      FastifyNames2["MIDDLEWARE"] = "middleware";
      FastifyNames2["REQUEST_HANDLER"] = "request handler";
    })(FastifyNames = exports2.FastifyNames || (exports2.FastifyNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/types.js
var require_types3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hooksNamesToWrap = exports2.spanRequestSymbol = void 0;
    exports2.spanRequestSymbol = Symbol("opentelemetry.instrumentation.fastify.request_active_span");
    exports2.hooksNamesToWrap = /* @__PURE__ */ new Set([
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError"
    ]);
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/utils.js
var require_utils7 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeExecuteInTheMiddleMaybePromise = exports2.endSpan = exports2.startSpan = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants3();
    function startSpan3(reply, tracer, spanName, spanAttributes = {}) {
      const span = tracer.startSpan(spanName, { attributes: spanAttributes });
      const spans = reply[constants_1.spanRequestSymbol] || [];
      spans.push(span);
      Object.defineProperty(reply, constants_1.spanRequestSymbol, {
        enumerable: false,
        configurable: true,
        value: spans
      });
      return span;
    }
    exports2.startSpan = startSpan3;
    function endSpan(reply, err) {
      const spans = reply[constants_1.spanRequestSymbol] || [];
      if (!spans.length) {
        return;
      }
      spans.forEach((span) => {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
          span.recordException(err);
        }
        span.end();
      });
      delete reply[constants_1.spanRequestSymbol];
    }
    exports2.endSpan = endSpan;
    function safeExecuteInTheMiddleMaybePromise(execute, onFinish, preventThrowingError) {
      let error;
      let result = void 0;
      try {
        result = execute();
        if (isPromise(result)) {
          result.then((res) => onFinish(void 0, res), (err) => onFinish(err));
        }
      } catch (e) {
        error = e;
      } finally {
        if (!isPromise(result)) {
          onFinish(error, result);
          if (error && !preventThrowingError) {
            throw error;
          }
        }
        return result;
      }
    }
    exports2.safeExecuteInTheMiddleMaybePromise = safeExecuteInTheMiddleMaybePromise;
    function isPromise(val) {
      var _a;
      return typeof val === "object" && val && typeof ((_a = Object.getOwnPropertyDescriptor(val, "then")) === null || _a === void 0 ? void 0 : _a.value) === "function" || false;
    }
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/version.js
var require_version5 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.44.2";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-fastify";
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/instrumentation.js
var require_instrumentation4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FastifyInstrumentation = exports2.ANONYMOUS_NAME = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var constants_1 = require_constants3();
    var AttributeNames_1 = require_AttributeNames3();
    var utils_1 = require_utils7();
    var version_1 = require_version5();
    exports2.ANONYMOUS_NAME = "anonymous";
    var FastifyInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("fastify", [">=3.0.0 <6"], (moduleExports) => {
            return this._patchConstructor(moduleExports);
          })
        ];
      }
      _hookOnRequest() {
        const instrumentation = this;
        return function onRequest(request, reply, done) {
          if (!instrumentation.isEnabled()) {
            return done();
          }
          instrumentation._wrap(reply, "send", instrumentation._patchSend());
          const anyRequest = request;
          const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
          const routeName = anyRequest.routeOptions ? anyRequest.routeOptions.url : request.routerPath;
          if (routeName && (rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
            rpcMetadata.route = routeName;
          }
          done();
        };
      }
      _wrapHandler(pluginName, hookName, original, syncFunctionWithDone) {
        const instrumentation = this;
        this._diag.debug("Patching fastify route.handler function");
        return function(...args) {
          if (!instrumentation.isEnabled()) {
            return original.apply(this, args);
          }
          const name = original.name || pluginName || exports2.ANONYMOUS_NAME;
          const spanName = `${AttributeNames_1.FastifyNames.MIDDLEWARE} - ${name}`;
          const reply = args[1];
          const span = (0, utils_1.startSpan)(reply, instrumentation.tracer, spanName, {
            [AttributeNames_1.AttributeNames.FASTIFY_TYPE]: AttributeNames_1.FastifyTypes.MIDDLEWARE,
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName,
            [AttributeNames_1.AttributeNames.HOOK_NAME]: hookName
          });
          const origDone = syncFunctionWithDone && args[args.length - 1];
          if (origDone) {
            args[args.length - 1] = function(...doneArgs) {
              (0, utils_1.endSpan)(reply);
              origDone.apply(this, doneArgs);
            };
          }
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return (0, utils_1.safeExecuteInTheMiddleMaybePromise)(() => {
              return original.apply(this, args);
            }, (err) => {
              if (err instanceof Error) {
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message: err.message
                });
                span.recordException(err);
              }
              if (!syncFunctionWithDone) {
                (0, utils_1.endSpan)(reply);
              }
            });
          });
        };
      }
      _wrapAddHook() {
        const instrumentation = this;
        this._diag.debug("Patching fastify server.addHook function");
        return function(original) {
          return function wrappedAddHook(...args) {
            const name = args[0];
            const handler = args[1];
            const pluginName = this.pluginName;
            if (!constants_1.hooksNamesToWrap.has(name)) {
              return original.apply(this, args);
            }
            const syncFunctionWithDone = typeof args[args.length - 1] === "function" && handler.constructor.name !== "AsyncFunction";
            return original.apply(this, [
              name,
              instrumentation._wrapHandler(pluginName, name, handler, syncFunctionWithDone)
            ]);
          };
        };
      }
      _patchConstructor(moduleExports) {
        const instrumentation = this;
        function fastify(...args) {
          const app = moduleExports.fastify.apply(this, args);
          app.addHook("onRequest", instrumentation._hookOnRequest());
          app.addHook("preHandler", instrumentation._hookPreHandler());
          instrumentation._wrap(app, "addHook", instrumentation._wrapAddHook());
          return app;
        }
        if (moduleExports.errorCodes !== void 0) {
          fastify.errorCodes = moduleExports.errorCodes;
        }
        fastify.fastify = fastify;
        fastify.default = fastify;
        return fastify;
      }
      _patchSend() {
        const instrumentation = this;
        this._diag.debug("Patching fastify reply.send function");
        return function patchSend(original) {
          return function send(...args) {
            const maybeError = args[0];
            if (!instrumentation.isEnabled()) {
              return original.apply(this, args);
            }
            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              return original.apply(this, args);
            }, (err) => {
              if (!err && maybeError instanceof Error) {
                err = maybeError;
              }
              (0, utils_1.endSpan)(this, err);
            });
          };
        };
      }
      _hookPreHandler() {
        const instrumentation = this;
        this._diag.debug("Patching fastify preHandler function");
        return function preHandler(request, reply, done) {
          var _a, _b;
          if (!instrumentation.isEnabled()) {
            return done();
          }
          const anyRequest = request;
          const handler = ((_a = anyRequest.routeOptions) === null || _a === void 0 ? void 0 : _a.handler) || ((_b = anyRequest.context) === null || _b === void 0 ? void 0 : _b.handler);
          const handlerName = (handler === null || handler === void 0 ? void 0 : handler.name.startsWith("bound ")) ? handler.name.substring(6) : handler === null || handler === void 0 ? void 0 : handler.name;
          const spanName = `${AttributeNames_1.FastifyNames.REQUEST_HANDLER} - ${handlerName || this.pluginName || exports2.ANONYMOUS_NAME}`;
          const spanAttributes = {
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: this.pluginName,
            [AttributeNames_1.AttributeNames.FASTIFY_TYPE]: AttributeNames_1.FastifyTypes.REQUEST_HANDLER,
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: anyRequest.routeOptions ? anyRequest.routeOptions.url : request.routerPath
          };
          if (handlerName) {
            spanAttributes[AttributeNames_1.AttributeNames.FASTIFY_NAME] = handlerName;
          }
          const span = (0, utils_1.startSpan)(reply, instrumentation.tracer, spanName, spanAttributes);
          const { requestHook: requestHook2 } = instrumentation.getConfig();
          if (requestHook2) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook2(span, { request }), (e) => {
              if (e) {
                instrumentation._diag.error("request hook failed", e);
              }
            }, true);
          }
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            done();
          });
        };
      }
    };
    exports2.FastifyInstrumentation = FastifyInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-fastify/build/src/index.js
var require_src10 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-fastify/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_AttributeNames3(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_instrumentation4(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/enum.js
var require_enum = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpanNames = exports2.TokenKind = exports2.AllowedOperationTypes = void 0;
    var AllowedOperationTypes;
    (function(AllowedOperationTypes2) {
      AllowedOperationTypes2["QUERY"] = "query";
      AllowedOperationTypes2["MUTATION"] = "mutation";
      AllowedOperationTypes2["SUBSCRIPTION"] = "subscription";
    })(AllowedOperationTypes = exports2.AllowedOperationTypes || (exports2.AllowedOperationTypes = {}));
    var TokenKind;
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind = exports2.TokenKind || (exports2.TokenKind = {}));
    var SpanNames;
    (function(SpanNames2) {
      SpanNames2["EXECUTE"] = "graphql.execute";
      SpanNames2["PARSE"] = "graphql.parse";
      SpanNames2["RESOLVE"] = "graphql.resolve";
      SpanNames2["VALIDATE"] = "graphql.validate";
      SpanNames2["SCHEMA_VALIDATE"] = "graphql.validateSchema";
      SpanNames2["SCHEMA_PARSE"] = "graphql.parseSchema";
    })(SpanNames = exports2.SpanNames || (exports2.SpanNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/enums/AttributeNames.js
var require_AttributeNames4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["SOURCE"] = "graphql.source";
      AttributeNames3["FIELD_NAME"] = "graphql.field.name";
      AttributeNames3["FIELD_PATH"] = "graphql.field.path";
      AttributeNames3["FIELD_TYPE"] = "graphql.field.type";
      AttributeNames3["OPERATION_TYPE"] = "graphql.operation.type";
      AttributeNames3["OPERATION_NAME"] = "graphql.operation.name";
      AttributeNames3["VARIABLES"] = "graphql.variables.";
      AttributeNames3["ERROR_VALIDATION_NAME"] = "graphql.validation.error";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/symbols.js
var require_symbols = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OTEL_GRAPHQL_DATA_SYMBOL = exports2.OTEL_PATCHED_SYMBOL = void 0;
    exports2.OTEL_PATCHED_SYMBOL = Symbol.for("opentelemetry.patched");
    exports2.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for("opentelemetry.graphql_data");
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/internal-types.js
var require_internal_types2 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OPERATION_NOT_SUPPORTED = void 0;
    var symbols_1 = require_symbols();
    exports2.OPERATION_NOT_SUPPORTED = "Operation$operationName$not supported";
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/utils.js
var require_utils8 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapFieldResolver = exports2.wrapFields = exports2.getSourceFromLocation = exports2.getOperation = exports2.endSpan = exports2.addSpanSource = exports2.addInputVariableAttributes = exports2.isPromise = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var enum_1 = require_enum();
    var AttributeNames_1 = require_AttributeNames4();
    var symbols_1 = require_symbols();
    var OPERATION_VALUES = Object.values(enum_1.AllowedOperationTypes);
    var isPromise = (value) => {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    };
    exports2.isPromise = isPromise;
    var isObjectLike = (value) => {
      return typeof value == "object" && value !== null;
    };
    function addInputVariableAttribute(span, key, variable) {
      if (Array.isArray(variable)) {
        variable.forEach((value, idx) => {
          addInputVariableAttribute(span, `${key}.${idx}`, value);
        });
      } else if (variable instanceof Object) {
        Object.entries(variable).forEach(([nestedKey, value]) => {
          addInputVariableAttribute(span, `${key}.${nestedKey}`, value);
        });
      } else {
        span.setAttribute(`${AttributeNames_1.AttributeNames.VARIABLES}${String(key)}`, variable);
      }
    }
    function addInputVariableAttributes(span, variableValues) {
      Object.entries(variableValues).forEach(([key, value]) => {
        addInputVariableAttribute(span, key, value);
      });
    }
    exports2.addInputVariableAttributes = addInputVariableAttributes;
    function addSpanSource(span, loc, allowValues, start, end) {
      const source = getSourceFromLocation(loc, allowValues, start, end);
      span.setAttribute(AttributeNames_1.AttributeNames.SOURCE, source);
    }
    exports2.addSpanSource = addSpanSource;
    function createFieldIfNotExists(tracer, getConfig, contextValue, info, path) {
      let field = getField(contextValue, path);
      let spanAdded = false;
      if (!field) {
        spanAdded = true;
        const parent = getParentField(contextValue, path);
        field = {
          parent,
          span: createResolverSpan(tracer, getConfig, contextValue, info, path, parent.span),
          error: null
        };
        addField(contextValue, path, field);
      }
      return { spanAdded, field };
    }
    function createResolverSpan(tracer, getConfig, contextValue, info, path, parentSpan) {
      var _a, _b;
      const attributes = {
        [AttributeNames_1.AttributeNames.FIELD_NAME]: info.fieldName,
        [AttributeNames_1.AttributeNames.FIELD_PATH]: path.join("."),
        [AttributeNames_1.AttributeNames.FIELD_TYPE]: info.returnType.toString()
      };
      const span = tracer.startSpan(`${enum_1.SpanNames.RESOLVE} ${attributes[AttributeNames_1.AttributeNames.FIELD_PATH]}`, {
        attributes
      }, parentSpan ? api.trace.setSpan(api.context.active(), parentSpan) : void 0);
      const document2 = contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].source;
      const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === "Field");
      if (fieldNode) {
        addSpanSource(span, document2.loc, getConfig().allowValues, (_a = fieldNode.loc) === null || _a === void 0 ? void 0 : _a.start, (_b = fieldNode.loc) === null || _b === void 0 ? void 0 : _b.end);
      }
      return span;
    }
    function endSpan(span, error) {
      if (error) {
        span.recordException(error);
      }
      span.end();
    }
    exports2.endSpan = endSpan;
    function getOperation(document2, operationName) {
      if (!document2 || !Array.isArray(document2.definitions)) {
        return void 0;
      }
      if (operationName) {
        return document2.definitions.filter((definition) => {
          var _a;
          return OPERATION_VALUES.indexOf((_a = definition) === null || _a === void 0 ? void 0 : _a.operation) !== -1;
        }).find((definition) => {
          var _a, _b;
          return operationName === ((_b = (_a = definition) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value);
        });
      } else {
        return document2.definitions.find((definition) => {
          var _a;
          return OPERATION_VALUES.indexOf((_a = definition) === null || _a === void 0 ? void 0 : _a.operation) !== -1;
        });
      }
    }
    exports2.getOperation = getOperation;
    function addField(contextValue, path, field) {
      return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path.join(".")] = field;
    }
    function getField(contextValue, path) {
      return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path.join(".")];
    }
    function getParentField(contextValue, path) {
      for (let i = path.length - 1; i > 0; i--) {
        const field = getField(contextValue, path.slice(0, i));
        if (field) {
          return field;
        }
      }
      return {
        span: contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].span
      };
    }
    function pathToArray(mergeItems, path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        let key = curr.key;
        if (mergeItems && typeof key === "number") {
          key = "*";
        }
        flattened.push(String(key));
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    function repeatBreak(i) {
      return repeatChar("\n", i);
    }
    function repeatSpace(i) {
      return repeatChar(" ", i);
    }
    function repeatChar(char, to) {
      let text = "";
      for (let i = 0; i < to; i++) {
        text += char;
      }
      return text;
    }
    var KindsToBeRemoved = [
      enum_1.TokenKind.FLOAT,
      enum_1.TokenKind.STRING,
      enum_1.TokenKind.INT,
      enum_1.TokenKind.BLOCK_STRING
    ];
    function getSourceFromLocation(loc, allowValues = false, inputStart, inputEnd) {
      var _a, _b;
      let source = "";
      if (loc === null || loc === void 0 ? void 0 : loc.startToken) {
        const start = typeof inputStart === "number" ? inputStart : loc.start;
        const end = typeof inputEnd === "number" ? inputEnd : loc.end;
        let next = loc.startToken.next;
        let previousLine = 1;
        while (next) {
          if (next.start < start) {
            next = next.next;
            previousLine = next === null || next === void 0 ? void 0 : next.line;
            continue;
          }
          if (next.end > end) {
            next = next.next;
            previousLine = next === null || next === void 0 ? void 0 : next.line;
            continue;
          }
          let value = next.value || next.kind;
          let space = "";
          if (!allowValues && KindsToBeRemoved.indexOf(next.kind) >= 0) {
            value = "*";
          }
          if (next.kind === enum_1.TokenKind.STRING) {
            value = `"${value}"`;
          }
          if (next.kind === enum_1.TokenKind.EOF) {
            value = "";
          }
          if (next.line > previousLine) {
            source += repeatBreak(next.line - previousLine);
            previousLine = next.line;
            space = repeatSpace(next.column - 1);
          } else {
            if (next.line === ((_a = next.prev) === null || _a === void 0 ? void 0 : _a.line)) {
              space = repeatSpace(next.start - (((_b = next.prev) === null || _b === void 0 ? void 0 : _b.end) || 0));
            }
          }
          source += space + value;
          if (next) {
            next = next.next;
          }
        }
      }
      return source;
    }
    exports2.getSourceFromLocation = getSourceFromLocation;
    function wrapFields(type, tracer, getConfig) {
      if (!type || typeof type.getFields !== "function" || type[symbols_1.OTEL_PATCHED_SYMBOL]) {
        return;
      }
      const fields = type.getFields();
      type[symbols_1.OTEL_PATCHED_SYMBOL] = true;
      Object.keys(fields).forEach((key) => {
        const field = fields[key];
        if (!field) {
          return;
        }
        if (field.resolve) {
          field.resolve = wrapFieldResolver(tracer, getConfig, field.resolve);
        }
        if (field.type) {
          let unwrappedType = field.type;
          while (unwrappedType.ofType) {
            unwrappedType = unwrappedType.ofType;
          }
          wrapFields(unwrappedType, tracer, getConfig);
        }
      });
    }
    exports2.wrapFields = wrapFields;
    var handleResolveSpanError = (resolveSpan, err, shouldEndSpan) => {
      if (!shouldEndSpan) {
        return;
      }
      resolveSpan.recordException(err);
      resolveSpan.setStatus({
        code: api.SpanStatusCode.ERROR,
        message: err.message
      });
      resolveSpan.end();
    };
    var handleResolveSpanSuccess = (resolveSpan, shouldEndSpan) => {
      if (!shouldEndSpan) {
        return;
      }
      resolveSpan.end();
    };
    function wrapFieldResolver(tracer, getConfig, fieldResolver, isDefaultResolver = false) {
      if (wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] || typeof fieldResolver !== "function") {
        return fieldResolver;
      }
      function wrappedFieldResolver(source, args, contextValue, info) {
        if (!fieldResolver) {
          return void 0;
        }
        const config2 = getConfig();
        if (config2.ignoreTrivialResolveSpans && isDefaultResolver && (isObjectLike(source) || typeof source === "function")) {
          const property = source[info.fieldName];
          if (typeof property !== "function") {
            return fieldResolver.call(this, source, args, contextValue, info);
          }
        }
        if (!contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL]) {
          return fieldResolver.call(this, source, args, contextValue, info);
        }
        const path = pathToArray(config2.mergeItems, info && info.path);
        const depth = path.filter((item) => typeof item === "string").length;
        let field;
        let shouldEndSpan = false;
        if (config2.depth >= 0 && config2.depth < depth) {
          field = getParentField(contextValue, path);
        } else {
          const newField = createFieldIfNotExists(tracer, getConfig, contextValue, info, path);
          field = newField.field;
          shouldEndSpan = newField.spanAdded;
        }
        return api.context.with(api.trace.setSpan(api.context.active(), field.span), () => {
          try {
            const res = fieldResolver.call(this, source, args, contextValue, info);
            if ((0, exports2.isPromise)(res)) {
              return res.then((r) => {
                handleResolveSpanSuccess(field.span, shouldEndSpan);
                return r;
              }, (err) => {
                handleResolveSpanError(field.span, err, shouldEndSpan);
                throw err;
              });
            } else {
              handleResolveSpanSuccess(field.span, shouldEndSpan);
              return res;
            }
          } catch (err) {
            handleResolveSpanError(field.span, err, shouldEndSpan);
            throw err;
          }
        });
      }
      wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] = true;
      return wrappedFieldResolver;
    }
    exports2.wrapFieldResolver = wrapFieldResolver;
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/version.js
var require_version6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.47.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-graphql";
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/instrumentation.js
var require_instrumentation5 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GraphQLInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var enum_1 = require_enum();
    var AttributeNames_1 = require_AttributeNames4();
    var symbols_1 = require_symbols();
    var internal_types_1 = require_internal_types2();
    var utils_1 = require_utils8();
    var version_1 = require_version6();
    var DEFAULT_CONFIG = {
      mergeItems: false,
      depth: -1,
      allowValues: false,
      ignoreResolveSpans: false
    };
    var supportedVersions = [">=14.0.0 <17"];
    var GraphQLInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      setConfig(config2 = {}) {
        super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      init() {
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition("graphql", supportedVersions);
        module3.files.push(this._addPatchingExecute());
        module3.files.push(this._addPatchingParser());
        module3.files.push(this._addPatchingValidate());
        return module3;
      }
      _addPatchingExecute() {
        return new instrumentation_1.InstrumentationNodeModuleFile(
          "graphql/execution/execute.js",
          supportedVersions,
          // cannot make it work with appropriate type as execute function has 2
          //types and/cannot import function but only types
          (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.execute)) {
              this._unwrap(moduleExports, "execute");
            }
            this._wrap(moduleExports, "execute", this._patchExecute(moduleExports.defaultFieldResolver));
            return moduleExports;
          },
          (moduleExports) => {
            if (moduleExports) {
              this._unwrap(moduleExports, "execute");
            }
          }
        );
      }
      _addPatchingParser() {
        return new instrumentation_1.InstrumentationNodeModuleFile("graphql/language/parser.js", supportedVersions, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.parse)) {
            this._unwrap(moduleExports, "parse");
          }
          this._wrap(moduleExports, "parse", this._patchParse());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports) {
            this._unwrap(moduleExports, "parse");
          }
        });
      }
      _addPatchingValidate() {
        return new instrumentation_1.InstrumentationNodeModuleFile("graphql/validation/validate.js", supportedVersions, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.validate)) {
            this._unwrap(moduleExports, "validate");
          }
          this._wrap(moduleExports, "validate", this._patchValidate());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports) {
            this._unwrap(moduleExports, "validate");
          }
        });
      }
      _patchExecute(defaultFieldResolved) {
        const instrumentation = this;
        return function execute(original) {
          return function patchExecute() {
            let processedArgs;
            if (arguments.length >= 2) {
              const args = arguments;
              processedArgs = instrumentation._wrapExecuteArgs(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], defaultFieldResolved);
            } else {
              const args = arguments[0];
              processedArgs = instrumentation._wrapExecuteArgs(args.schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.typeResolver, defaultFieldResolved);
            }
            const operation = (0, utils_1.getOperation)(processedArgs.document, processedArgs.operationName);
            const span = instrumentation._createExecuteSpan(operation, processedArgs);
            processedArgs.contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] = {
              source: processedArgs.document ? processedArgs.document || processedArgs.document[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] : void 0,
              span,
              fields: {}
            };
            return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                return original.apply(this, [
                  processedArgs
                ]);
              }, (err, result) => {
                instrumentation._handleExecutionResult(span, err, result);
              });
            });
          };
        };
      }
      _handleExecutionResult(span, err, result) {
        const config2 = this.getConfig();
        if (result === void 0 || err) {
          (0, utils_1.endSpan)(span, err);
          return;
        }
        if ((0, utils_1.isPromise)(result)) {
          result.then((resultData) => {
            if (typeof config2.responseHook !== "function") {
              (0, utils_1.endSpan)(span);
              return;
            }
            this._executeResponseHook(span, resultData);
          }, (error) => {
            (0, utils_1.endSpan)(span, error);
          });
        } else {
          if (typeof config2.responseHook !== "function") {
            (0, utils_1.endSpan)(span);
            return;
          }
          this._executeResponseHook(span, result);
        }
      }
      _executeResponseHook(span, result) {
        const { responseHook } = this.getConfig();
        if (!responseHook) {
          return;
        }
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          responseHook(span, result);
        }, (err) => {
          if (err) {
            this._diag.error("Error running response hook", err);
          }
          (0, utils_1.endSpan)(span, void 0);
        }, true);
      }
      _patchParse() {
        const instrumentation = this;
        return function parse(original) {
          return function patchParse(source, options) {
            return instrumentation._parse(this, original, source, options);
          };
        };
      }
      _patchValidate() {
        const instrumentation = this;
        return function validate(original) {
          return function patchValidate(schema, documentAST, rules, options, typeInfo) {
            return instrumentation._validate(this, original, schema, documentAST, rules, typeInfo, options);
          };
        };
      }
      _parse(obj, original, source, options) {
        const config2 = this.getConfig();
        const span = this.tracer.startSpan(enum_1.SpanNames.PARSE);
        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            return original.call(obj, source, options);
          }, (err, result) => {
            if (result) {
              const operation = (0, utils_1.getOperation)(result);
              if (!operation) {
                span.updateName(enum_1.SpanNames.SCHEMA_PARSE);
              } else if (result.loc) {
                (0, utils_1.addSpanSource)(span, result.loc, config2.allowValues);
              }
            }
            (0, utils_1.endSpan)(span, err);
          });
        });
      }
      _validate(obj, original, schema, documentAST, rules, typeInfo, options) {
        const span = this.tracer.startSpan(enum_1.SpanNames.VALIDATE, {});
        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            return original.call(obj, schema, documentAST, rules, options, typeInfo);
          }, (err, errors) => {
            if (!documentAST.loc) {
              span.updateName(enum_1.SpanNames.SCHEMA_VALIDATE);
            }
            if (errors && errors.length) {
              span.recordException({
                name: AttributeNames_1.AttributeNames.ERROR_VALIDATION_NAME,
                message: JSON.stringify(errors)
              });
            }
            (0, utils_1.endSpan)(span, err);
          });
        });
      }
      _createExecuteSpan(operation, processedArgs) {
        var _a;
        const config2 = this.getConfig();
        const span = this.tracer.startSpan(enum_1.SpanNames.EXECUTE, {});
        if (operation) {
          const { operation: operationType, name: nameNode } = operation;
          span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_TYPE, operationType);
          const operationName = nameNode === null || nameNode === void 0 ? void 0 : nameNode.value;
          if (operationName) {
            span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
            span.updateName(`${operationType} ${operationName}`);
          } else {
            span.updateName(operationType);
          }
        } else {
          let operationName = " ";
          if (processedArgs.operationName) {
            operationName = ` "${processedArgs.operationName}" `;
          }
          operationName = internal_types_1.OPERATION_NOT_SUPPORTED.replace("$operationName$", operationName);
          span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
        }
        if ((_a = processedArgs.document) === null || _a === void 0 ? void 0 : _a.loc) {
          (0, utils_1.addSpanSource)(span, processedArgs.document.loc, config2.allowValues);
        }
        if (processedArgs.variableValues && config2.allowValues) {
          (0, utils_1.addInputVariableAttributes)(span, processedArgs.variableValues);
        }
        return span;
      }
      _wrapExecuteArgs(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver, defaultFieldResolved) {
        if (!contextValue) {
          contextValue = {};
        }
        if (contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] || this.getConfig().ignoreResolveSpans) {
          return {
            schema,
            document: document2,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver,
            typeResolver
          };
        }
        const isUsingDefaultResolver = fieldResolver == null;
        const fieldResolverForExecute = fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolved;
        fieldResolver = (0, utils_1.wrapFieldResolver)(this.tracer, () => this.getConfig(), fieldResolverForExecute, isUsingDefaultResolver);
        if (schema) {
          (0, utils_1.wrapFields)(schema.getQueryType(), this.tracer, () => this.getConfig());
          (0, utils_1.wrapFields)(schema.getMutationType(), this.tracer, () => this.getConfig());
        }
        return {
          schema,
          document: document2,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        };
      }
    };
    exports2.GraphQLInstrumentation = GraphQLInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/types.js
var require_types4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-graphql/build/src/index.js
var require_src11 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-graphql/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation5(), exports2);
    __exportStar(require_types4(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js
var require_version7 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-kafkajs/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.7.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-kafkajs";
  }
});

// node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js
var require_propagator = __commonJS({
  "node_modules/@opentelemetry/instrumentation-kafkajs/build/src/propagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferTextMapGetter = void 0;
    exports2.bufferTextMapGetter = {
      get(carrier, key) {
        var _a;
        if (!carrier) {
          return void 0;
        }
        const keys = Object.keys(carrier);
        for (const carrierKey of keys) {
          if (carrierKey === key || carrierKey.toLowerCase() === key) {
            return (_a = carrier[carrierKey]) === null || _a === void 0 ? void 0 : _a.toString();
          }
        }
        return void 0;
      },
      keys(carrier) {
        return carrier ? Object.keys(carrier) : [];
      }
    };
  }
});

// node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js
var require_instrumentation6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-kafkajs/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KafkaJsInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var version_1 = require_version7();
    var propagator_1 = require_propagator();
    var instrumentation_1 = require_src4();
    var KafkaJsInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        const unpatch = (moduleExports) => {
          var _a, _b;
          if ((0, instrumentation_1.isWrapped)((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _a === void 0 ? void 0 : _a.prototype.producer)) {
            this._unwrap(moduleExports.Kafka.prototype, "producer");
          }
          if ((0, instrumentation_1.isWrapped)((_b = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _b === void 0 ? void 0 : _b.prototype.consumer)) {
            this._unwrap(moduleExports.Kafka.prototype, "consumer");
          }
        };
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition("kafkajs", [">=0.1.0 <3"], (moduleExports) => {
          var _a, _b;
          unpatch(moduleExports);
          this._wrap((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _a === void 0 ? void 0 : _a.prototype, "producer", this._getProducerPatch());
          this._wrap((_b = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Kafka) === null || _b === void 0 ? void 0 : _b.prototype, "consumer", this._getConsumerPatch());
          return moduleExports;
        }, unpatch);
        return module3;
      }
      _getConsumerPatch() {
        const instrumentation = this;
        return (original) => {
          return function consumer(...args) {
            const newConsumer = original.apply(this, args);
            if ((0, instrumentation_1.isWrapped)(newConsumer.run)) {
              instrumentation._unwrap(newConsumer, "run");
            }
            instrumentation._wrap(newConsumer, "run", instrumentation._getConsumerRunPatch());
            return newConsumer;
          };
        };
      }
      _getProducerPatch() {
        const instrumentation = this;
        return (original) => {
          return function consumer(...args) {
            const newProducer = original.apply(this, args);
            if ((0, instrumentation_1.isWrapped)(newProducer.sendBatch)) {
              instrumentation._unwrap(newProducer, "sendBatch");
            }
            instrumentation._wrap(newProducer, "sendBatch", instrumentation._getProducerSendBatchPatch());
            if ((0, instrumentation_1.isWrapped)(newProducer.send)) {
              instrumentation._unwrap(newProducer, "send");
            }
            instrumentation._wrap(newProducer, "send", instrumentation._getProducerSendPatch());
            return newProducer;
          };
        };
      }
      _getConsumerRunPatch() {
        const instrumentation = this;
        return (original) => {
          return function run(...args) {
            const config2 = args[0];
            if (config2 === null || config2 === void 0 ? void 0 : config2.eachMessage) {
              if ((0, instrumentation_1.isWrapped)(config2.eachMessage)) {
                instrumentation._unwrap(config2, "eachMessage");
              }
              instrumentation._wrap(config2, "eachMessage", instrumentation._getConsumerEachMessagePatch());
            }
            if (config2 === null || config2 === void 0 ? void 0 : config2.eachBatch) {
              if ((0, instrumentation_1.isWrapped)(config2.eachBatch)) {
                instrumentation._unwrap(config2, "eachBatch");
              }
              instrumentation._wrap(config2, "eachBatch", instrumentation._getConsumerEachBatchPatch());
            }
            return original.call(this, config2);
          };
        };
      }
      _getConsumerEachMessagePatch() {
        const instrumentation = this;
        return (original) => {
          return function eachMessage(...args) {
            const payload = args[0];
            const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, payload.message.headers, propagator_1.bufferTextMapGetter);
            const span = instrumentation._startConsumerSpan(payload.topic, payload.message, semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, propagatedContext);
            const eachMessagePromise = api_1.context.with(api_1.trace.setSpan(propagatedContext, span), () => {
              return original.apply(this, args);
            });
            return instrumentation._endSpansOnPromise([span], eachMessagePromise);
          };
        };
      }
      _getConsumerEachBatchPatch() {
        return (original) => {
          const instrumentation = this;
          return function eachBatch(...args) {
            const payload = args[0];
            const receivingSpan = instrumentation._startConsumerSpan(payload.batch.topic, void 0, semantic_conventions_1.MESSAGINGOPERATIONVALUES_RECEIVE, api_1.ROOT_CONTEXT);
            return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), receivingSpan), () => {
              const spans = payload.batch.messages.map((message) => {
                var _a;
                const propagatedContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, message.headers, propagator_1.bufferTextMapGetter);
                const spanContext = (_a = api_1.trace.getSpan(propagatedContext)) === null || _a === void 0 ? void 0 : _a.spanContext();
                let origSpanLink;
                if (spanContext) {
                  origSpanLink = {
                    context: spanContext
                  };
                }
                return instrumentation._startConsumerSpan(payload.batch.topic, message, semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, void 0, origSpanLink);
              });
              const batchMessagePromise = original.apply(this, args);
              spans.unshift(receivingSpan);
              return instrumentation._endSpansOnPromise(spans, batchMessagePromise);
            });
          };
        };
      }
      _getProducerSendBatchPatch() {
        const instrumentation = this;
        return (original) => {
          return function sendBatch(...args) {
            const batch = args[0];
            const messages = batch.topicMessages || [];
            const spans = messages.map((topicMessage) => topicMessage.messages.map((message) => instrumentation._startProducerSpan(topicMessage.topic, message))).reduce((acc, val) => acc.concat(val), []);
            const origSendResult = original.apply(this, args);
            return instrumentation._endSpansOnPromise(spans, origSendResult);
          };
        };
      }
      _getProducerSendPatch() {
        const instrumentation = this;
        return (original) => {
          return function send(...args) {
            const record = args[0];
            const spans = record.messages.map((message) => {
              return instrumentation._startProducerSpan(record.topic, message);
            });
            const origSendResult = original.apply(this, args);
            return instrumentation._endSpansOnPromise(spans, origSendResult);
          };
        };
      }
      _endSpansOnPromise(spans, sendPromise) {
        return Promise.resolve(sendPromise).catch((reason) => {
          let errorMessage;
          if (typeof reason === "string")
            errorMessage = reason;
          else if (typeof reason === "object" && Object.prototype.hasOwnProperty.call(reason, "message"))
            errorMessage = reason.message;
          spans.forEach((span) => span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: errorMessage
          }));
          throw reason;
        }).finally(() => {
          spans.forEach((span) => span.end());
        });
      }
      _startConsumerSpan(topic, message, operation, context3, link) {
        const span = this.tracer.startSpan(topic, {
          kind: api_1.SpanKind.CONSUMER,
          attributes: {
            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "kafka",
            [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: topic,
            [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: operation
          },
          links: link ? [link] : []
        }, context3);
        const { consumerHook } = this.getConfig();
        if (consumerHook && message) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumerHook(span, { topic, message }), (e) => {
            if (e)
              this._diag.error("consumerHook error", e);
          }, true);
        }
        return span;
      }
      _startProducerSpan(topic, message) {
        var _a;
        const span = this.tracer.startSpan(topic, {
          kind: api_1.SpanKind.PRODUCER,
          attributes: {
            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "kafka",
            [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: topic
          }
        });
        message.headers = (_a = message.headers) !== null && _a !== void 0 ? _a : {};
        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), message.headers);
        const { producerHook } = this.getConfig();
        if (producerHook) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => producerHook(span, { topic, message }), (e) => {
            if (e)
              this._diag.error("producerHook error", e);
          }, true);
        }
        return span;
      }
    };
    exports2.KafkaJsInstrumentation = KafkaJsInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-kafkajs/build/src/types.js
var require_types5 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-kafkajs/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js
var require_src12 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-kafkajs/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation6(), exports2);
    __exportStar(require_types5(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/version.js
var require_version8 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.44.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-lru-memoizer";
  }
});

// node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/instrumentation.js
var require_instrumentation7 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruMemoizerInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var version_1 = require_version8();
    var LruMemoizerInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition(
            "lru-memoizer",
            [">=1.3 <3"],
            (moduleExports) => {
              const asyncMemoizer = function() {
                const origMemoizer = moduleExports.apply(this, arguments);
                return function() {
                  const modifiedArguments = [...arguments];
                  const origCallback = modifiedArguments.pop();
                  const callbackWithContext = typeof origCallback === "function" ? api_1.context.bind(api_1.context.active(), origCallback) : origCallback;
                  modifiedArguments.push(callbackWithContext);
                  return origMemoizer.apply(this, modifiedArguments);
                };
              };
              asyncMemoizer.sync = moduleExports.sync;
              return asyncMemoizer;
            },
            void 0
            // no need to disable as this instrumentation does not create any spans
          )
        ];
      }
    };
    exports2.LruMemoizerInstrumentation = LruMemoizerInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/index.js
var require_src13 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-lru-memoizer/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation7(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-mongodb/build/src/internal-types.js
var require_internal_types3 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongodb/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongodbCommandType = void 0;
    var MongodbCommandType;
    (function(MongodbCommandType2) {
      MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
      MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
      MongodbCommandType2["IS_MASTER"] = "isMaster";
      MongodbCommandType2["COUNT"] = "count";
      MongodbCommandType2["AGGREGATE"] = "aggregate";
      MongodbCommandType2["UNKNOWN"] = "unknown";
    })(MongodbCommandType = exports2.MongodbCommandType || (exports2.MongodbCommandType = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-mongodb/build/src/version.js
var require_version9 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongodb/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.52.0";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-mongodb";
  }
});

// node_modules/@opentelemetry/instrumentation-mongodb/build/src/instrumentation.js
var require_instrumentation8 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongodb/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoDBInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var internal_types_1 = require_internal_types3();
    var version_1 = require_version9();
    var DEFAULT_CONFIG = {
      requireParentSpan: true
    };
    var MongoDBInstrumentation2 = class _MongoDBInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      setConfig(config2 = {}) {
        super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      _updateMetricInstruments() {
        this._connectionsUsage = this.meter.createUpDownCounter("db.client.connections.usage", {
          description: "The number of connections that are currently in state described by the state attribute.",
          unit: "{connection}"
        });
      }
      init() {
        const { v3PatchConnection, v3UnpatchConnection } = this._getV3ConnectionPatches();
        const { v4PatchConnect, v4UnpatchConnect } = this._getV4ConnectPatches();
        const { v4PatchConnectionCallback, v4PatchConnectionPromise, v4UnpatchConnection } = this._getV4ConnectionPatches();
        const { v4PatchConnectionPool, v4UnpatchConnectionPool } = this._getV4ConnectionPoolPatches();
        const { v4PatchSessions, v4UnpatchSessions } = this._getV4SessionsPatches();
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=3.3.0 <4"], void 0, void 0, [
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/core/wireprotocol/index.js", [">=3.3.0 <4"], v3PatchConnection, v3UnpatchConnection)
          ]),
          new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=4.0.0 <7"], void 0, void 0, [
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=4.0.0 <6.4"], v4PatchConnectionCallback, v4UnpatchConnection),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=6.4.0 <7"], v4PatchConnectionPromise, v4UnpatchConnection),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection_pool.js", [">=4.0.0 <6.4"], v4PatchConnectionPool, v4UnpatchConnectionPool),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connect.js", [">=4.0.0 <7"], v4PatchConnect, v4UnpatchConnect),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/sessions.js", [">=4.0.0 <7"], v4PatchSessions, v4UnpatchSessions)
          ])
        ];
      }
      _getV3ConnectionPatches() {
        return {
          v3PatchConnection: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.insert)) {
              this._unwrap(moduleExports, "insert");
            }
            this._wrap(moduleExports, "insert", this._getV3PatchOperation("insert"));
            if ((0, instrumentation_1.isWrapped)(moduleExports.remove)) {
              this._unwrap(moduleExports, "remove");
            }
            this._wrap(moduleExports, "remove", this._getV3PatchOperation("remove"));
            if ((0, instrumentation_1.isWrapped)(moduleExports.update)) {
              this._unwrap(moduleExports, "update");
            }
            this._wrap(moduleExports, "update", this._getV3PatchOperation("update"));
            if ((0, instrumentation_1.isWrapped)(moduleExports.command)) {
              this._unwrap(moduleExports, "command");
            }
            this._wrap(moduleExports, "command", this._getV3PatchCommand());
            if ((0, instrumentation_1.isWrapped)(moduleExports.query)) {
              this._unwrap(moduleExports, "query");
            }
            this._wrap(moduleExports, "query", this._getV3PatchFind());
            if ((0, instrumentation_1.isWrapped)(moduleExports.getMore)) {
              this._unwrap(moduleExports, "getMore");
            }
            this._wrap(moduleExports, "getMore", this._getV3PatchCursor());
            return moduleExports;
          },
          v3UnpatchConnection: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports, "insert");
            this._unwrap(moduleExports, "remove");
            this._unwrap(moduleExports, "update");
            this._unwrap(moduleExports, "command");
            this._unwrap(moduleExports, "query");
            this._unwrap(moduleExports, "getMore");
          }
        };
      }
      _getV4SessionsPatches() {
        return {
          v4PatchSessions: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
              this._unwrap(moduleExports, "acquire");
            }
            this._wrap(moduleExports.ServerSessionPool.prototype, "acquire", this._getV4AcquireCommand());
            if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
              this._unwrap(moduleExports, "release");
            }
            this._wrap(moduleExports.ServerSessionPool.prototype, "release", this._getV4ReleaseCommand());
            return moduleExports;
          },
          v4UnpatchSessions: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
              this._unwrap(moduleExports, "acquire");
            }
            if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
              this._unwrap(moduleExports, "release");
            }
          }
        };
      }
      _getV4AcquireCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchAcquire() {
            const nSessionsBeforeAcquire = this.sessions.length;
            const session = original.call(this);
            const nSessionsAfterAcquire = this.sessions.length;
            if (nSessionsBeforeAcquire === nSessionsAfterAcquire) {
              instrumentation._connectionsUsage.add(1, {
                state: "used",
                "pool.name": instrumentation._poolName
              });
            } else if (nSessionsBeforeAcquire - 1 === nSessionsAfterAcquire) {
              instrumentation._connectionsUsage.add(-1, {
                state: "idle",
                "pool.name": instrumentation._poolName
              });
              instrumentation._connectionsUsage.add(1, {
                state: "used",
                "pool.name": instrumentation._poolName
              });
            }
            return session;
          };
        };
      }
      _getV4ReleaseCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchRelease(session) {
            const cmdPromise = original.call(this, session);
            instrumentation._connectionsUsage.add(-1, {
              state: "used",
              "pool.name": instrumentation._poolName
            });
            instrumentation._connectionsUsage.add(1, {
              state: "idle",
              "pool.name": instrumentation._poolName
            });
            return cmdPromise;
          };
        };
      }
      _getV4ConnectionPoolPatches() {
        return {
          v4PatchConnectionPool: (moduleExports) => {
            const poolPrototype = moduleExports.ConnectionPool.prototype;
            if ((0, instrumentation_1.isWrapped)(poolPrototype.checkOut)) {
              this._unwrap(poolPrototype, "checkOut");
            }
            this._wrap(poolPrototype, "checkOut", this._getV4ConnectionPoolCheckOut());
            return moduleExports;
          },
          v4UnpatchConnectionPool: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports.ConnectionPool.prototype, "checkOut");
          }
        };
      }
      _getV4ConnectPatches() {
        return {
          v4PatchConnect: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
              this._unwrap(moduleExports, "connect");
            }
            this._wrap(moduleExports, "connect", this._getV4ConnectCommand());
            return moduleExports;
          },
          v4UnpatchConnect: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports, "connect");
          }
        };
      }
      // This patch will become unnecessary once
      // https://jira.mongodb.org/browse/NODE-5639 is done.
      _getV4ConnectionPoolCheckOut() {
        return (original) => {
          return function patchedCheckout(callback) {
            const patchedCallback = api_1.context.bind(api_1.context.active(), callback);
            return original.call(this, patchedCallback);
          };
        };
      }
      _getV4ConnectCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchedConnect(options, callback) {
            if (original.length === 1) {
              const result = original.call(this, options);
              if (result && typeof result.then === "function") {
                result.then(
                  () => instrumentation.setPoolName(options),
                  // this handler is set to pass the lint rules
                  () => void 0
                );
              }
              return result;
            }
            const patchedCallback = function(err, conn) {
              if (err || !conn) {
                callback(err, conn);
                return;
              }
              instrumentation.setPoolName(options);
              callback(err, conn);
            };
            return original.call(this, options, patchedCallback);
          };
        };
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _getV4ConnectionPatches() {
        return {
          v4PatchConnectionCallback: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
              this._unwrap(moduleExports.Connection.prototype, "command");
            }
            this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandCallback());
            return moduleExports;
          },
          v4PatchConnectionPromise: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
              this._unwrap(moduleExports.Connection.prototype, "command");
            }
            this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandPromise());
            return moduleExports;
          },
          v4UnpatchConnection: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports.Connection.prototype, "command");
          }
        };
      }
      /** Creates spans for common operations */
      _getV3PatchOperation(operationName) {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, ops, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
            const resultHandler = typeof options === "function" ? options : callback;
            if (skipInstrumentation || typeof resultHandler !== "function" || typeof ops !== "object") {
              if (typeof options === "function") {
                return original.call(this, server, ns, ops, options);
              } else {
                return original.call(this, server, ns, ops, options, callback);
              }
            }
            const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV3Attributes(
              span,
              ns,
              server,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              ops[0],
              operationName
            );
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, ops, patchedCallback);
            } else {
              return original.call(this, server, ns, ops, options, patchedCallback);
            }
          };
        };
      }
      /** Creates spans for command operation */
      _getV3PatchCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, cmd, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
            const resultHandler = typeof options === "function" ? options : callback;
            if (skipInstrumentation || typeof resultHandler !== "function" || typeof cmd !== "object") {
              if (typeof options === "function") {
                return original.call(this, server, ns, cmd, options);
              } else {
                return original.call(this, server, ns, cmd, options, callback);
              }
            }
            const commandType = _MongoDBInstrumentation._getCommandType(cmd);
            const type = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? "command" : commandType;
            const span = instrumentation.tracer.startSpan(`mongodb.${type}`, {
              kind: api_1.SpanKind.CLIENT
            });
            const operation = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? void 0 : commandType;
            instrumentation._populateV3Attributes(span, ns, server, cmd, operation);
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, patchedCallback);
            } else {
              return original.call(this, server, ns, cmd, options, patchedCallback);
            }
          };
        };
      }
      /** Creates spans for command operation */
      _getV4PatchCommandCallback() {
        const instrumentation = this;
        return (original) => {
          return function patchedV4ServerCommand(ns, cmd, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
            const resultHandler = callback;
            const commandType = Object.keys(cmd)[0];
            if (typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
              return original.call(this, ns, cmd, options, callback);
            }
            let span = void 0;
            if (!skipInstrumentation) {
              span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
                kind: api_1.SpanKind.CLIENT
              });
              instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
            }
            const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
            return original.call(this, ns, cmd, options, patchedCallback);
          };
        };
      }
      _getV4PatchCommandPromise() {
        const instrumentation = this;
        return (original) => {
          return function patchedV4ServerCommand(...args) {
            const [ns, cmd] = args;
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
            const commandType = Object.keys(cmd)[0];
            const resultHandler = () => void 0;
            if (typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
              return original.apply(this, args);
            }
            let span = void 0;
            if (!skipInstrumentation) {
              span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
                kind: api_1.SpanKind.CLIENT
              });
              instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
            }
            const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
            const result = original.apply(this, args);
            result.then((res) => patchedCallback(null, res), (err) => patchedCallback(err));
            return result;
          };
        };
      }
      /** Creates spans for find operation */
      _getV3PatchFind() {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, cmd, cursorState, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
            const resultHandler = typeof options === "function" ? options : callback;
            if (skipInstrumentation || typeof resultHandler !== "function" || typeof cmd !== "object") {
              if (typeof options === "function") {
                return original.call(this, server, ns, cmd, cursorState, options);
              } else {
                return original.call(this, server, ns, cmd, cursorState, options, callback);
              }
            }
            const span = instrumentation.tracer.startSpan("mongodb.find", {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV3Attributes(span, ns, server, cmd, "find");
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, cursorState, patchedCallback);
            } else {
              return original.call(this, server, ns, cmd, cursorState, options, patchedCallback);
            }
          };
        };
      }
      /** Creates spans for find operation */
      _getV3PatchCursor() {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, cursorState, batchSize, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const skipInstrumentation = instrumentation._checkSkipInstrumentation(currentSpan);
            const resultHandler = typeof options === "function" ? options : callback;
            if (skipInstrumentation || typeof resultHandler !== "function") {
              if (typeof options === "function") {
                return original.call(this, server, ns, cursorState, batchSize, options);
              } else {
                return original.call(this, server, ns, cursorState, batchSize, options, callback);
              }
            }
            const span = instrumentation.tracer.startSpan("mongodb.getMore", {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV3Attributes(span, ns, server, cursorState.cmd, "getMore");
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, cursorState, batchSize, patchedCallback);
            } else {
              return original.call(this, server, ns, cursorState, batchSize, options, patchedCallback);
            }
          };
        };
      }
      /**
       * Get the mongodb command type from the object.
       * @param command Internal mongodb command object
       */
      static _getCommandType(command) {
        if (command.createIndexes !== void 0) {
          return internal_types_1.MongodbCommandType.CREATE_INDEXES;
        } else if (command.findandmodify !== void 0) {
          return internal_types_1.MongodbCommandType.FIND_AND_MODIFY;
        } else if (command.ismaster !== void 0) {
          return internal_types_1.MongodbCommandType.IS_MASTER;
        } else if (command.count !== void 0) {
          return internal_types_1.MongodbCommandType.COUNT;
        } else if (command.aggregate !== void 0) {
          return internal_types_1.MongodbCommandType.AGGREGATE;
        } else {
          return internal_types_1.MongodbCommandType.UNKNOWN;
        }
      }
      /**
       * Populate span's attributes by fetching related metadata from the context
       * @param span span to add attributes to
       * @param connectionCtx mongodb internal connection context
       * @param ns mongodb namespace
       * @param command mongodb internal representation of a command
       */
      _populateV4Attributes(span, connectionCtx, ns, command, operation) {
        let host, port;
        if (connectionCtx) {
          const hostParts = typeof connectionCtx.address === "string" ? connectionCtx.address.split(":") : "";
          if (hostParts.length === 2) {
            host = hostParts[0];
            port = hostParts[1];
          }
        }
        let commandObj;
        if ((command === null || command === void 0 ? void 0 : command.documents) && command.documents[0]) {
          commandObj = command.documents[0];
        } else if (command === null || command === void 0 ? void 0 : command.cursors) {
          commandObj = command.cursors;
        } else {
          commandObj = command;
        }
        this._addAllSpanAttributes(span, ns.db, ns.collection, host, port, commandObj, operation);
      }
      /**
       * Populate span's attributes by fetching related metadata from the context
       * @param span span to add attributes to
       * @param ns mongodb namespace
       * @param topology mongodb internal representation of the network topology
       * @param command mongodb internal representation of a command
       */
      _populateV3Attributes(span, ns, topology, command, operation) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let host;
        let port;
        if (topology && topology.s) {
          host = (_b = (_a = topology.s.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : topology.s.host;
          port = (_e = (_d = (_c = topology.s.options) === null || _c === void 0 ? void 0 : _c.port) !== null && _d !== void 0 ? _d : topology.s.port) === null || _e === void 0 ? void 0 : _e.toString();
          if (host == null || port == null) {
            const address = (_f = topology.description) === null || _f === void 0 ? void 0 : _f.address;
            if (address) {
              const addressSegments = address.split(":");
              host = addressSegments[0];
              port = addressSegments[1];
            }
          }
        }
        const [dbName, dbCollection] = ns.toString().split(".");
        const commandObj = (_h = (_g = command === null || command === void 0 ? void 0 : command.query) !== null && _g !== void 0 ? _g : command === null || command === void 0 ? void 0 : command.q) !== null && _h !== void 0 ? _h : command;
        this._addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation);
      }
      _addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation) {
        span.setAttributes({
          [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MONGODB,
          [semantic_conventions_1.SEMATTRS_DB_NAME]: dbName,
          [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: dbCollection,
          [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `mongodb://${host}:${port}/${dbName}`
        });
        if (host && port) {
          span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_NAME, host);
          const portNumber = parseInt(port, 10);
          if (!isNaN(portNumber)) {
            span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_PORT, portNumber);
          }
        }
        if (!commandObj)
          return;
        const { dbStatementSerializer: configDbStatementSerializer } = this.getConfig();
        const dbStatementSerializer = typeof configDbStatementSerializer === "function" ? configDbStatementSerializer : this._defaultDbStatementSerializer.bind(this);
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          const query = dbStatementSerializer(commandObj);
          span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, query);
        }, (err) => {
          if (err) {
            this._diag.error("Error running dbStatementSerializer hook", err);
          }
        }, true);
      }
      _defaultDbStatementSerializer(commandObj) {
        const { enhancedDatabaseReporting } = this.getConfig();
        const resultObj = enhancedDatabaseReporting ? commandObj : this._scrubStatement(commandObj);
        return JSON.stringify(resultObj);
      }
      _scrubStatement(value) {
        if (Array.isArray(value)) {
          return value.map((element) => this._scrubStatement(element));
        }
        if (typeof value === "object" && value !== null) {
          return Object.fromEntries(Object.entries(value).map(([key, element]) => [
            key,
            this._scrubStatement(element)
          ]));
        }
        return "?";
      }
      /**
       * Triggers the response hook in case it is defined.
       * @param span The span to add the results to.
       * @param result The command result
       */
      _handleExecutionResult(span, result) {
        const { responseHook } = this.getConfig();
        if (typeof responseHook === "function") {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            responseHook(span, { data: result });
          }, (err) => {
            if (err) {
              this._diag.error("Error running response hook", err);
            }
          }, true);
        }
      }
      /**
       * Ends a created span.
       * @param span The created span to end.
       * @param resultHandler A callback function.
       * @param connectionId: The connection ID of the Command response.
       */
      _patchEnd(span, resultHandler, connectionId, commandType) {
        const activeContext = api_1.context.active();
        const instrumentation = this;
        return function patchedEnd(...args) {
          const error = args[0];
          if (span) {
            if (error instanceof Error) {
              span === null || span === void 0 ? void 0 : span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: error.message
              });
            } else {
              const result = args[1];
              instrumentation._handleExecutionResult(span, result);
            }
            span.end();
          }
          return api_1.context.with(activeContext, () => {
            if (commandType === "endSessions") {
              instrumentation._connectionsUsage.add(-1, {
                state: "idle",
                "pool.name": instrumentation._poolName
              });
            }
            return resultHandler.apply(this, args);
          });
        };
      }
      setPoolName(options) {
        var _a, _b;
        const host = (_a = options.hostAddress) === null || _a === void 0 ? void 0 : _a.host;
        const port = (_b = options.hostAddress) === null || _b === void 0 ? void 0 : _b.port;
        const database = options.dbName;
        const poolName = `mongodb://${host}:${port}/${database}`;
        this._poolName = poolName;
      }
      _checkSkipInstrumentation(currentSpan) {
        const requireParentSpan = this.getConfig().requireParentSpan;
        const hasNoParentSpan = currentSpan === void 0;
        return requireParentSpan === true && hasNoParentSpan;
      }
    };
    exports2.MongoDBInstrumentation = MongoDBInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-mongodb/build/src/types.js
var require_types6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongodb/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongodbCommandType = void 0;
    var MongodbCommandType;
    (function(MongodbCommandType2) {
      MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
      MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
      MongodbCommandType2["IS_MASTER"] = "isMaster";
      MongodbCommandType2["COUNT"] = "count";
      MongodbCommandType2["UNKNOWN"] = "unknown";
    })(MongodbCommandType = exports2.MongodbCommandType || (exports2.MongodbCommandType = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-mongodb/build/src/index.js
var require_src14 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongodb/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation8(), exports2);
    __exportStar(require_types6(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-mongoose/build/src/utils.js
var require_utils9 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongoose/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.handleCallbackResponse = exports2.handlePromiseResponse = exports2.getAttributesFromCollection = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    function getAttributesFromCollection(collection) {
      return {
        [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: collection.name,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: collection.conn.name,
        [semantic_conventions_1.SEMATTRS_DB_USER]: collection.conn.user,
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: collection.conn.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: collection.conn.port
      };
    }
    exports2.getAttributesFromCollection = getAttributesFromCollection;
    function setErrorStatus(span, error = {}) {
      span.recordException(error);
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: `${error.message} ${error.code ? `
Mongoose Error Code: ${error.code}` : ""}`
      });
    }
    function applyResponseHook(span, response, responseHook, moduleVersion = void 0) {
      if (!responseHook) {
        return;
      }
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => responseHook(span, { moduleVersion, response }), (e) => {
        if (e) {
          api_1.diag.error("mongoose instrumentation: responseHook error", e);
        }
      }, true);
    }
    function handlePromiseResponse(execResponse, span, responseHook, moduleVersion = void 0) {
      if (!(execResponse instanceof Promise)) {
        applyResponseHook(span, execResponse, responseHook, moduleVersion);
        span.end();
        return execResponse;
      }
      return execResponse.then((response) => {
        applyResponseHook(span, response, responseHook, moduleVersion);
        return response;
      }).catch((err) => {
        setErrorStatus(span, err);
        throw err;
      }).finally(() => span.end());
    }
    exports2.handlePromiseResponse = handlePromiseResponse;
    function handleCallbackResponse(callback, exec, originalThis, span, args, responseHook, moduleVersion = void 0) {
      let callbackArgumentIndex = 0;
      if (args.length === 2) {
        callbackArgumentIndex = 1;
      }
      args[callbackArgumentIndex] = (err, response) => {
        err ? setErrorStatus(span, err) : applyResponseHook(span, response, responseHook, moduleVersion);
        span.end();
        return callback(err, response);
      };
      return exec.apply(originalThis, args);
    }
    exports2.handleCallbackResponse = handleCallbackResponse;
  }
});

// node_modules/@opentelemetry/instrumentation-mongoose/build/src/version.js
var require_version10 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongoose/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.46.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-mongoose";
  }
});

// node_modules/@opentelemetry/instrumentation-mongoose/build/src/mongoose.js
var require_mongoose = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongoose/build/src/mongoose.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongooseInstrumentation = exports2._STORED_PARENT_SPAN = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var utils_1 = require_utils9();
    var instrumentation_1 = require_src4();
    var version_1 = require_version10();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var contextCaptureFunctionsCommon = [
      "deleteOne",
      "deleteMany",
      "find",
      "findOne",
      "estimatedDocumentCount",
      "countDocuments",
      "distinct",
      "where",
      "$where",
      "findOneAndUpdate",
      "findOneAndDelete",
      "findOneAndReplace"
    ];
    var contextCaptureFunctions6 = [
      "remove",
      "count",
      "findOneAndRemove",
      ...contextCaptureFunctionsCommon
    ];
    var contextCaptureFunctions7 = [
      "count",
      "findOneAndRemove",
      ...contextCaptureFunctionsCommon
    ];
    var contextCaptureFunctions8 = [...contextCaptureFunctionsCommon];
    function getContextCaptureFunctions(moduleVersion) {
      if (!moduleVersion) {
        return contextCaptureFunctionsCommon;
      } else if (moduleVersion.startsWith("6.") || moduleVersion.startsWith("5.")) {
        return contextCaptureFunctions6;
      } else if (moduleVersion.startsWith("7.")) {
        return contextCaptureFunctions7;
      } else {
        return contextCaptureFunctions8;
      }
    }
    function instrumentRemove(moduleVersion) {
      return moduleVersion && (moduleVersion.startsWith("5.") || moduleVersion.startsWith("6.")) || false;
    }
    exports2._STORED_PARENT_SPAN = Symbol("stored-parent-span");
    var MongooseInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition("mongoose", [">=5.9.7 <9"], this.patch.bind(this), this.unpatch.bind(this));
        return module3;
      }
      patch(moduleExports, moduleVersion) {
        this._wrap(moduleExports.Model.prototype, "save", this.patchOnModelMethods("save", moduleVersion));
        moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
        if (instrumentRemove(moduleVersion)) {
          this._wrap(moduleExports.Model.prototype, "remove", this.patchOnModelMethods("remove", moduleVersion));
        }
        this._wrap(moduleExports.Query.prototype, "exec", this.patchQueryExec(moduleVersion));
        this._wrap(moduleExports.Aggregate.prototype, "exec", this.patchAggregateExec(moduleVersion));
        const contextCaptureFunctions = getContextCaptureFunctions(moduleVersion);
        contextCaptureFunctions.forEach((funcName) => {
          this._wrap(moduleExports.Query.prototype, funcName, this.patchAndCaptureSpanContext(funcName));
        });
        this._wrap(moduleExports.Model, "aggregate", this.patchModelAggregate());
        return moduleExports;
      }
      unpatch(moduleExports, moduleVersion) {
        const contextCaptureFunctions = getContextCaptureFunctions(moduleVersion);
        this._unwrap(moduleExports.Model.prototype, "save");
        moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
        if (instrumentRemove(moduleVersion)) {
          this._unwrap(moduleExports.Model.prototype, "remove");
        }
        this._unwrap(moduleExports.Query.prototype, "exec");
        this._unwrap(moduleExports.Aggregate.prototype, "exec");
        contextCaptureFunctions.forEach((funcName) => {
          this._unwrap(moduleExports.Query.prototype, funcName);
        });
        this._unwrap(moduleExports.Model, "aggregate");
      }
      patchAggregateExec(moduleVersion) {
        const self = this;
        return (originalAggregate) => {
          return function exec(callback) {
            var _a;
            if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return originalAggregate.apply(this, arguments);
            }
            const parentSpan = this[exports2._STORED_PARENT_SPAN];
            const attributes = {};
            const { dbStatementSerializer } = self.getConfig();
            if (dbStatementSerializer) {
              attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer("aggregate", {
                options: this.options,
                aggregatePipeline: this._pipeline
              });
            }
            const span = self._startSpan(this._model.collection, (_a = this._model) === null || _a === void 0 ? void 0 : _a.modelName, "aggregate", attributes, parentSpan);
            return self._handleResponse(span, originalAggregate, this, arguments, callback, moduleVersion);
          };
        };
      }
      patchQueryExec(moduleVersion) {
        const self = this;
        return (originalExec) => {
          return function exec(callback) {
            if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return originalExec.apply(this, arguments);
            }
            const parentSpan = this[exports2._STORED_PARENT_SPAN];
            const attributes = {};
            const { dbStatementSerializer } = self.getConfig();
            if (dbStatementSerializer) {
              attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(this.op, {
                condition: this._conditions,
                updates: this._update,
                options: this.options,
                fields: this._fields
              });
            }
            const span = self._startSpan(this.mongooseCollection, this.model.modelName, this.op, attributes, parentSpan);
            return self._handleResponse(span, originalExec, this, arguments, callback, moduleVersion);
          };
        };
      }
      patchOnModelMethods(op, moduleVersion) {
        const self = this;
        return (originalOnModelFunction) => {
          return function method(options, callback) {
            if (self.getConfig().requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return originalOnModelFunction.apply(this, arguments);
            }
            const serializePayload = { document: this };
            if (options && !(options instanceof Function)) {
              serializePayload.options = options;
            }
            const attributes = {};
            const { dbStatementSerializer } = self.getConfig();
            if (dbStatementSerializer) {
              attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatementSerializer(op, serializePayload);
            }
            const span = self._startSpan(this.constructor.collection, this.constructor.modelName, op, attributes);
            if (options instanceof Function) {
              callback = options;
              options = void 0;
            }
            return self._handleResponse(span, originalOnModelFunction, this, arguments, callback, moduleVersion);
          };
        };
      }
      // we want to capture the otel span on the object which is calling exec.
      // in the special case of aggregate, we need have no function to path
      // on the Aggregate object to capture the context on, so we patch
      // the aggregate of Model, and set the context on the Aggregate object
      patchModelAggregate() {
        const self = this;
        return (original) => {
          return function captureSpanContext() {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const aggregate = self._callOriginalFunction(() => original.apply(this, arguments));
            if (aggregate)
              aggregate[exports2._STORED_PARENT_SPAN] = currentSpan;
            return aggregate;
          };
        };
      }
      patchAndCaptureSpanContext(funcName) {
        const self = this;
        return (original) => {
          return function captureSpanContext() {
            this[exports2._STORED_PARENT_SPAN] = api_1.trace.getSpan(api_1.context.active());
            return self._callOriginalFunction(() => original.apply(this, arguments));
          };
        };
      }
      _startSpan(collection, modelName, operation, attributes, parentSpan) {
        return this.tracer.startSpan(`mongoose.${modelName}.${operation}`, {
          kind: api_1.SpanKind.CLIENT,
          attributes: Object.assign(Object.assign(Object.assign({}, attributes), (0, utils_1.getAttributesFromCollection)(collection)), { [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation, [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: "mongoose" })
        }, parentSpan ? api_1.trace.setSpan(api_1.context.active(), parentSpan) : void 0);
      }
      _handleResponse(span, exec, originalThis, args, callback, moduleVersion = void 0) {
        const self = this;
        if (callback instanceof Function) {
          return self._callOriginalFunction(() => (0, utils_1.handleCallbackResponse)(callback, exec, originalThis, span, args, self.getConfig().responseHook, moduleVersion));
        } else {
          const response = self._callOriginalFunction(() => exec.apply(originalThis, args));
          return (0, utils_1.handlePromiseResponse)(response, span, self.getConfig().responseHook, moduleVersion);
        }
      }
      _callOriginalFunction(originalFunction) {
        if (this.getConfig().suppressInternalInstrumentation) {
          return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), originalFunction);
        } else {
          return originalFunction();
        }
      }
    };
    exports2.MongooseInstrumentation = MongooseInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-mongoose/build/src/types.js
var require_types7 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongoose/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-mongoose/build/src/index.js
var require_src15 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mongoose/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_mongoose(), exports2);
    __exportStar(require_types7(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-mysql/build/src/AttributeNames.js
var require_AttributeNames5 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql/build/src/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["MYSQL_VALUES"] = "db.mysql.values";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-mysql/build/src/utils.js
var require_utils10 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPoolName = exports2.arrayStringifyHelper = exports2.getSpanName = exports2.getDbValues = exports2.getDbStatement = exports2.getConnectionAttributes = void 0;
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    function getConnectionAttributes(config2) {
      const { host, port, database, user } = getConfig(config2);
      const portNumber = parseInt(port, 10);
      if (!isNaN(portNumber)) {
        return {
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
          [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
          [semantic_conventions_1.SEMATTRS_DB_USER]: user
        };
      }
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    exports2.getConnectionAttributes = getConnectionAttributes;
    function getConfig(config2) {
      const { host, port, database, user } = config2 && config2.connectionConfig || config2 || {};
      return { host, port, database, user };
    }
    function getJDBCString(host, port, database) {
      let jdbcString = `jdbc:mysql://${host || "localhost"}`;
      if (typeof port === "number") {
        jdbcString += `:${port}`;
      }
      if (typeof database === "string") {
        jdbcString += `/${database}`;
      }
      return jdbcString;
    }
    function getDbStatement(query) {
      if (typeof query === "string") {
        return query;
      } else {
        return query.sql;
      }
    }
    exports2.getDbStatement = getDbStatement;
    function getDbValues(query, values) {
      if (typeof query === "string") {
        return arrayStringifyHelper(values);
      } else {
        return arrayStringifyHelper(values || query.values);
      }
    }
    exports2.getDbValues = getDbValues;
    function getSpanName(query) {
      const rawQuery = typeof query === "object" ? query.sql : query;
      const firstSpace = rawQuery === null || rawQuery === void 0 ? void 0 : rawQuery.indexOf(" ");
      if (typeof firstSpace === "number" && firstSpace !== -1) {
        return rawQuery === null || rawQuery === void 0 ? void 0 : rawQuery.substring(0, firstSpace);
      }
      return rawQuery;
    }
    exports2.getSpanName = getSpanName;
    function arrayStringifyHelper(arr) {
      if (arr)
        return `[${arr.toString()}]`;
      return "";
    }
    exports2.arrayStringifyHelper = arrayStringifyHelper;
    function getPoolName(pool) {
      const c = pool.config.connectionConfig;
      let poolName = "";
      poolName += c.host ? `host: '${c.host}', ` : "";
      poolName += c.port ? `port: ${c.port}, ` : "";
      poolName += c.database ? `database: '${c.database}', ` : "";
      poolName += c.user ? `user: '${c.user}'` : "";
      if (!c.user) {
        poolName = poolName.substring(0, poolName.length - 2);
      }
      return poolName.trim();
    }
    exports2.getPoolName = getPoolName;
  }
});

// node_modules/@opentelemetry/instrumentation-mysql/build/src/version.js
var require_version11 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.45.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql";
  }
});

// node_modules/@opentelemetry/instrumentation-mysql/build/src/instrumentation.js
var require_instrumentation9 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MySQLInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var AttributeNames_1 = require_AttributeNames5();
    var utils_1 = require_utils10();
    var version_1 = require_version11();
    var MySQLInstrumentation2 = class _MySQLInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
        this._setMetricInstruments();
      }
      setMeterProvider(meterProvider) {
        super.setMeterProvider(meterProvider);
        this._setMetricInstruments();
      }
      _setMetricInstruments() {
        this._connectionsUsage = this.meter.createUpDownCounter(
          "db.client.connections.usage",
          //TODO:: use semantic convention
          {
            description: "The number of connections that are currently in state described by the state attribute.",
            unit: "{connection}"
          }
        );
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("mysql", [">=2.0.0 <3"], (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.createConnection)) {
              this._unwrap(moduleExports, "createConnection");
            }
            this._wrap(moduleExports, "createConnection", this._patchCreateConnection());
            if ((0, instrumentation_1.isWrapped)(moduleExports.createPool)) {
              this._unwrap(moduleExports, "createPool");
            }
            this._wrap(moduleExports, "createPool", this._patchCreatePool());
            if ((0, instrumentation_1.isWrapped)(moduleExports.createPoolCluster)) {
              this._unwrap(moduleExports, "createPoolCluster");
            }
            this._wrap(moduleExports, "createPoolCluster", this._patchCreatePoolCluster());
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports, "createConnection");
            this._unwrap(moduleExports, "createPool");
            this._unwrap(moduleExports, "createPoolCluster");
          })
        ];
      }
      // global export function
      _patchCreateConnection() {
        return (originalCreateConnection) => {
          const thisPlugin = this;
          return function createConnection(_connectionUri) {
            const originalResult = originalCreateConnection(...arguments);
            thisPlugin._wrap(originalResult, "query", thisPlugin._patchQuery(originalResult));
            return originalResult;
          };
        };
      }
      // global export function
      _patchCreatePool() {
        return (originalCreatePool) => {
          const thisPlugin = this;
          return function createPool(_config) {
            const pool = originalCreatePool(...arguments);
            thisPlugin._wrap(pool, "query", thisPlugin._patchQuery(pool));
            thisPlugin._wrap(pool, "getConnection", thisPlugin._patchGetConnection(pool));
            thisPlugin._wrap(pool, "end", thisPlugin._patchPoolEnd(pool));
            thisPlugin._setPoolcallbacks(pool, thisPlugin, "");
            return pool;
          };
        };
      }
      _patchPoolEnd(pool) {
        return (originalPoolEnd) => {
          const thisPlugin = this;
          return function end(callback) {
            const nAll = pool._allConnections.length;
            const nFree = pool._freeConnections.length;
            const nUsed = nAll - nFree;
            const poolName = (0, utils_1.getPoolName)(pool);
            thisPlugin._connectionsUsage.add(-nUsed, {
              state: "used",
              name: poolName
            });
            thisPlugin._connectionsUsage.add(-nFree, {
              state: "idle",
              name: poolName
            });
            originalPoolEnd.apply(pool, arguments);
          };
        };
      }
      // global export function
      _patchCreatePoolCluster() {
        return (originalCreatePoolCluster) => {
          const thisPlugin = this;
          return function createPool(_config) {
            const cluster = originalCreatePoolCluster(...arguments);
            thisPlugin._wrap(cluster, "getConnection", thisPlugin._patchGetConnection(cluster));
            thisPlugin._wrap(cluster, "add", thisPlugin._patchAdd(cluster));
            return cluster;
          };
        };
      }
      _patchAdd(cluster) {
        return (originalAdd) => {
          const thisPlugin = this;
          return function add(id, config2) {
            if (!thisPlugin["_enabled"]) {
              thisPlugin._unwrap(cluster, "add");
              return originalAdd.apply(cluster, arguments);
            }
            originalAdd.apply(cluster, arguments);
            const nodes = cluster["_nodes"];
            if (nodes) {
              const nodeId = typeof id === "object" ? "CLUSTER::" + cluster._lastId : String(id);
              const pool = nodes[nodeId].pool;
              thisPlugin._setPoolcallbacks(pool, thisPlugin, id);
            }
          };
        };
      }
      // method on cluster or pool
      _patchGetConnection(pool) {
        return (originalGetConnection) => {
          const thisPlugin = this;
          return function getConnection(arg1, arg2, arg3) {
            if (!thisPlugin["_enabled"]) {
              thisPlugin._unwrap(pool, "getConnection");
              return originalGetConnection.apply(pool, arguments);
            }
            if (arguments.length === 1 && typeof arg1 === "function") {
              const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg1);
              return originalGetConnection.call(pool, patchFn);
            }
            if (arguments.length === 2 && typeof arg2 === "function") {
              const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg2);
              return originalGetConnection.call(pool, arg1, patchFn);
            }
            if (arguments.length === 3 && typeof arg3 === "function") {
              const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg3);
              return originalGetConnection.call(pool, arg1, arg2, patchFn);
            }
            return originalGetConnection.apply(pool, arguments);
          };
        };
      }
      _getConnectionCallbackPatchFn(cb) {
        const thisPlugin = this;
        const activeContext = api_1.context.active();
        return function(err, connection) {
          if (connection) {
            if (!(0, instrumentation_1.isWrapped)(connection.query)) {
              thisPlugin._wrap(connection, "query", thisPlugin._patchQuery(connection));
            }
          }
          if (typeof cb === "function") {
            api_1.context.with(activeContext, cb, this, err, connection);
          }
        };
      }
      _patchQuery(connection) {
        return (originalQuery) => {
          const thisPlugin = this;
          return function query(query, _valuesOrCallback, _callback) {
            if (!thisPlugin["_enabled"]) {
              thisPlugin._unwrap(connection, "query");
              return originalQuery.apply(connection, arguments);
            }
            const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
              kind: api_1.SpanKind.CLIENT,
              attributes: Object.assign(Object.assign({}, _MySQLInstrumentation.COMMON_ATTRIBUTES), (0, utils_1.getConnectionAttributes)(connection.config))
            });
            span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, (0, utils_1.getDbStatement)(query));
            if (thisPlugin.getConfig().enhancedDatabaseReporting) {
              let values;
              if (Array.isArray(_valuesOrCallback)) {
                values = _valuesOrCallback;
              } else if (arguments[2]) {
                values = [_valuesOrCallback];
              }
              span.setAttribute(AttributeNames_1.AttributeNames.MYSQL_VALUES, (0, utils_1.getDbValues)(query, values));
            }
            const cbIndex = Array.from(arguments).findIndex((arg) => typeof arg === "function");
            const parentContext = api_1.context.active();
            if (cbIndex === -1) {
              const streamableQuery = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
                return originalQuery.apply(connection, arguments);
              });
              api_1.context.bind(parentContext, streamableQuery);
              return streamableQuery.on("error", (err) => span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: err.message
              })).on("end", () => {
                span.end();
              });
            } else {
              thisPlugin._wrap(arguments, cbIndex, thisPlugin._patchCallbackQuery(span, parentContext));
              return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
                return originalQuery.apply(connection, arguments);
              });
            }
          };
        };
      }
      _patchCallbackQuery(span, parentContext) {
        return (originalCallback) => {
          return function(err, results, fields) {
            if (err) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: err.message
              });
            }
            span.end();
            return api_1.context.with(parentContext, () => originalCallback(...arguments));
          };
        };
      }
      _setPoolcallbacks(pool, thisPlugin, id) {
        const poolName = id || (0, utils_1.getPoolName)(pool);
        pool.on("connection", (connection) => {
          thisPlugin._connectionsUsage.add(1, {
            state: "idle",
            name: poolName
          });
        });
        pool.on("acquire", (connection) => {
          thisPlugin._connectionsUsage.add(-1, {
            state: "idle",
            name: poolName
          });
          thisPlugin._connectionsUsage.add(1, {
            state: "used",
            name: poolName
          });
        });
        pool.on("release", (connection) => {
          thisPlugin._connectionsUsage.add(-1, {
            state: "used",
            name: poolName
          });
          thisPlugin._connectionsUsage.add(1, {
            state: "idle",
            name: poolName
          });
        });
      }
    };
    exports2.MySQLInstrumentation = MySQLInstrumentation2;
    MySQLInstrumentation2.COMMON_ATTRIBUTES = {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
    };
  }
});

// node_modules/@opentelemetry/instrumentation-mysql/build/src/types.js
var require_types8 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-mysql/build/src/index.js
var require_src16 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation9(), exports2);
    __exportStar(require_types8(), exports2);
  }
});

// node_modules/@opentelemetry/sql-common/build/src/index.js
var require_src17 = __commonJS({
  "node_modules/@opentelemetry/sql-common/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addSqlCommenterComment = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    function hasValidSqlComment(query) {
      const indexOpeningDashDashComment = query.indexOf("--");
      if (indexOpeningDashDashComment >= 0) {
        return true;
      }
      const indexOpeningSlashComment = query.indexOf("/*");
      if (indexOpeningSlashComment < 0) {
        return false;
      }
      const indexClosingSlashComment = query.indexOf("*/");
      return indexOpeningDashDashComment < indexClosingSlashComment;
    }
    function fixedEncodeURIComponent(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
    }
    function addSqlCommenterComment(span, query) {
      if (typeof query !== "string" || query.length === 0) {
        return query;
      }
      if (hasValidSqlComment(query)) {
        return query;
      }
      const propagator = new core_1.W3CTraceContextPropagator();
      const headers = {};
      propagator.inject(api_1.trace.setSpan(api_1.ROOT_CONTEXT, span), headers, api_1.defaultTextMapSetter);
      const sortedKeys = Object.keys(headers).sort();
      if (sortedKeys.length === 0) {
        return query;
      }
      const commentString = sortedKeys.map((key) => {
        const encodedValue = fixedEncodeURIComponent(headers[key]);
        return `${key}='${encodedValue}'`;
      }).join(",");
      return `${query} /*${commentString}*/`;
    }
    exports2.addSqlCommenterComment = addSqlCommenterComment;
  }
});

// node_modules/@opentelemetry/instrumentation-mysql2/build/src/utils.js
var require_utils11 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql2/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getConnectionPrototypeToInstrument = exports2.once = exports2.getSpanName = exports2.getDbStatement = exports2.getConnectionAttributes = void 0;
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    function getConnectionAttributes(config2) {
      const { host, port, database, user } = getConfig(config2);
      const portNumber = parseInt(port, 10);
      if (!isNaN(portNumber)) {
        return {
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
          [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
          [semantic_conventions_1.SEMATTRS_DB_USER]: user
        };
      }
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    exports2.getConnectionAttributes = getConnectionAttributes;
    function getConfig(config2) {
      const { host, port, database, user } = config2 && config2.connectionConfig || config2 || {};
      return { host, port, database, user };
    }
    function getJDBCString(host, port, database) {
      let jdbcString = `jdbc:mysql://${host || "localhost"}`;
      if (typeof port === "number") {
        jdbcString += `:${port}`;
      }
      if (typeof database === "string") {
        jdbcString += `/${database}`;
      }
      return jdbcString;
    }
    function getDbStatement(query, format2, values) {
      if (!format2) {
        return typeof query === "string" ? query : query.sql;
      }
      if (typeof query === "string") {
        return values ? format2(query, values) : query;
      } else {
        return values || query.values ? format2(query.sql, values || query.values) : query.sql;
      }
    }
    exports2.getDbStatement = getDbStatement;
    function getSpanName(query) {
      const rawQuery = typeof query === "object" ? query.sql : query;
      const firstSpace = rawQuery === null || rawQuery === void 0 ? void 0 : rawQuery.indexOf(" ");
      if (typeof firstSpace === "number" && firstSpace !== -1) {
        return rawQuery === null || rawQuery === void 0 ? void 0 : rawQuery.substring(0, firstSpace);
      }
      return rawQuery;
    }
    exports2.getSpanName = getSpanName;
    var once = (fn) => {
      let called = false;
      return (...args) => {
        if (called)
          return;
        called = true;
        return fn(...args);
      };
    };
    exports2.once = once;
    function getConnectionPrototypeToInstrument(connection) {
      const connectionPrototype = connection.prototype;
      const basePrototype = Object.getPrototypeOf(connectionPrototype);
      if (typeof (basePrototype === null || basePrototype === void 0 ? void 0 : basePrototype.query) === "function" && typeof (basePrototype === null || basePrototype === void 0 ? void 0 : basePrototype.execute) === "function") {
        return basePrototype;
      }
      return connectionPrototype;
    }
    exports2.getConnectionPrototypeToInstrument = getConnectionPrototypeToInstrument;
  }
});

// node_modules/@opentelemetry/instrumentation-mysql2/build/src/version.js
var require_version12 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql2/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.45.2";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql2";
  }
});

// node_modules/@opentelemetry/instrumentation-mysql2/build/src/instrumentation.js
var require_instrumentation10 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql2/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MySQL2Instrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var sql_common_1 = require_src17();
    var utils_1 = require_utils11();
    var version_1 = require_version12();
    var supportedVersions = [">=1.4.2 <4"];
    var MySQL2Instrumentation2 = class _MySQL2Instrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        let format2;
        function setFormatFunction(moduleExports) {
          if (!format2 && moduleExports.format) {
            format2 = moduleExports.format;
          }
        }
        const patch = (ConnectionPrototype) => {
          if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.query)) {
            this._unwrap(ConnectionPrototype, "query");
          }
          this._wrap(ConnectionPrototype, "query", this._patchQuery(format2, false));
          if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.execute)) {
            this._unwrap(ConnectionPrototype, "execute");
          }
          this._wrap(ConnectionPrototype, "execute", this._patchQuery(format2, true));
        };
        const unpatch = (ConnectionPrototype) => {
          this._unwrap(ConnectionPrototype, "query");
          this._unwrap(ConnectionPrototype, "execute");
        };
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("mysql2", supportedVersions, (moduleExports) => {
            setFormatFunction(moduleExports);
            return moduleExports;
          }, () => {
          }, [
            new instrumentation_1.InstrumentationNodeModuleFile("mysql2/promise.js", supportedVersions, (moduleExports) => {
              setFormatFunction(moduleExports);
              return moduleExports;
            }, () => {
            }),
            new instrumentation_1.InstrumentationNodeModuleFile("mysql2/lib/connection.js", supportedVersions, (moduleExports) => {
              const ConnectionPrototype = (0, utils_1.getConnectionPrototypeToInstrument)(moduleExports);
              patch(ConnectionPrototype);
              return moduleExports;
            }, (moduleExports) => {
              if (moduleExports === void 0)
                return;
              const ConnectionPrototype = (0, utils_1.getConnectionPrototypeToInstrument)(moduleExports);
              unpatch(ConnectionPrototype);
            })
          ])
        ];
      }
      _patchQuery(format2, isPrepared) {
        return (originalQuery) => {
          const thisPlugin = this;
          return function query(query, _valuesOrCallback, _callback) {
            let values;
            if (Array.isArray(_valuesOrCallback)) {
              values = _valuesOrCallback;
            } else if (arguments[2]) {
              values = [_valuesOrCallback];
            }
            const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
              kind: api.SpanKind.CLIENT,
              attributes: Object.assign(Object.assign(Object.assign({}, _MySQL2Instrumentation.COMMON_ATTRIBUTES), (0, utils_1.getConnectionAttributes)(this.config)), { [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: (0, utils_1.getDbStatement)(query, format2, values) })
            });
            if (!isPrepared && thisPlugin.getConfig().addSqlCommenterCommentToQueries) {
              arguments[0] = query = typeof query === "string" ? (0, sql_common_1.addSqlCommenterComment)(span, query) : Object.assign(query, {
                sql: (0, sql_common_1.addSqlCommenterComment)(span, query.sql)
              });
            }
            const endSpan = (0, utils_1.once)((err, results) => {
              if (err) {
                span.setStatus({
                  code: api.SpanStatusCode.ERROR,
                  message: err.message
                });
              } else {
                const { responseHook } = thisPlugin.getConfig();
                if (typeof responseHook === "function") {
                  (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                    responseHook(span, {
                      queryResults: results
                    });
                  }, (err2) => {
                    if (err2) {
                      thisPlugin._diag.warn("Failed executing responseHook", err2);
                    }
                  }, true);
                }
              }
              span.end();
            });
            if (arguments.length === 1) {
              if (typeof query.onResult === "function") {
                thisPlugin._wrap(query, "onResult", thisPlugin._patchCallbackQuery(endSpan));
              }
              const streamableQuery = originalQuery.apply(this, arguments);
              streamableQuery.once("error", (err) => {
                endSpan(err);
              }).once("result", (results) => {
                endSpan(void 0, results);
              });
              return streamableQuery;
            }
            if (typeof arguments[1] === "function") {
              thisPlugin._wrap(arguments, 1, thisPlugin._patchCallbackQuery(endSpan));
            } else if (typeof arguments[2] === "function") {
              thisPlugin._wrap(arguments, 2, thisPlugin._patchCallbackQuery(endSpan));
            }
            return originalQuery.apply(this, arguments);
          };
        };
      }
      _patchCallbackQuery(endSpan) {
        return (originalCallback) => {
          return function(err, results, fields) {
            endSpan(err, results);
            return originalCallback(...arguments);
          };
        };
      }
    };
    exports2.MySQL2Instrumentation = MySQL2Instrumentation2;
    MySQL2Instrumentation2.COMMON_ATTRIBUTES = {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
    };
  }
});

// node_modules/@opentelemetry/instrumentation-mysql2/build/src/types.js
var require_types9 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql2/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-mysql2/build/src/index.js
var require_src18 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-mysql2/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation10(), exports2);
    __exportStar(require_types9(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-ioredis/build/src/utils.js
var require_utils12 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-ioredis/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.endSpan = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var endSpan = (span, err) => {
      if (err) {
        span.recordException(err);
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      }
      span.end();
    };
    exports2.endSpan = endSpan;
  }
});

// node_modules/@opentelemetry/redis-common/build/src/index.js
var require_src19 = __commonJS({
  "node_modules/@opentelemetry/redis-common/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultDbStatementSerializer = void 0;
    var serializationSubsets = [
      {
        regex: /^ECHO/i,
        args: 0
      },
      {
        regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,
        args: 1
      },
      {
        regex: /^(HSET|HMSET|LSET|LINSERT)/i,
        args: 2
      },
      {
        regex: /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
        args: -1
      }
    ];
    var defaultDbStatementSerializer = (cmdName, cmdArgs) => {
      var _a, _b;
      if (Array.isArray(cmdArgs) && cmdArgs.length) {
        const nArgsToSerialize = (_b = (_a = serializationSubsets.find(({ regex }) => {
          return regex.test(cmdName);
        })) === null || _a === void 0 ? void 0 : _a.args) !== null && _b !== void 0 ? _b : 0;
        const argsToSerialize = nArgsToSerialize >= 0 ? cmdArgs.slice(0, nArgsToSerialize) : cmdArgs;
        if (cmdArgs.length > argsToSerialize.length) {
          argsToSerialize.push(`[${cmdArgs.length - nArgsToSerialize} other arguments]`);
        }
        return `${cmdName} ${argsToSerialize.join(" ")}`;
      }
      return cmdName;
    };
    exports2.defaultDbStatementSerializer = defaultDbStatementSerializer;
  }
});

// node_modules/@opentelemetry/instrumentation-ioredis/build/src/version.js
var require_version13 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-ioredis/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.47.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-ioredis";
  }
});

// node_modules/@opentelemetry/instrumentation-ioredis/build/src/instrumentation.js
var require_instrumentation11 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-ioredis/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IORedisInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var instrumentation_2 = require_src4();
    var utils_1 = require_utils12();
    var redis_common_1 = require_src19();
    var version_1 = require_version13();
    var DEFAULT_CONFIG = {
      requireParentSpan: true
    };
    var IORedisInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      setConfig(config2 = {}) {
        super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("ioredis", [">=2.0.0 <6"], (module3, moduleVersion) => {
            const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
            if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.sendCommand)) {
              this._unwrap(moduleExports.prototype, "sendCommand");
            }
            this._wrap(moduleExports.prototype, "sendCommand", this._patchSendCommand(moduleVersion));
            if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
              this._unwrap(moduleExports.prototype, "connect");
            }
            this._wrap(moduleExports.prototype, "connect", this._patchConnection());
            return module3;
          }, (module3) => {
            if (module3 === void 0)
              return;
            const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
            this._unwrap(moduleExports.prototype, "sendCommand");
            this._unwrap(moduleExports.prototype, "connect");
          })
        ];
      }
      /**
       * Patch send command internal to trace requests
       */
      _patchSendCommand(moduleVersion) {
        return (original) => {
          return this._traceSendCommand(original, moduleVersion);
        };
      }
      _patchConnection() {
        return (original) => {
          return this._traceConnection(original);
        };
      }
      _traceSendCommand(original, moduleVersion) {
        const instrumentation = this;
        return function(cmd) {
          if (arguments.length < 1 || typeof cmd !== "object") {
            return original.apply(this, arguments);
          }
          const config2 = instrumentation.getConfig();
          const dbStatementSerializer = config2.dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
          const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === void 0;
          if (config2.requireParentSpan === true && hasNoParentSpan) {
            return original.apply(this, arguments);
          }
          const span = instrumentation.tracer.startSpan(cmd.name, {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: dbStatementSerializer(cmd.name, cmd.args)
            }
          });
          const { requestHook: requestHook2 } = config2;
          if (requestHook2) {
            (0, instrumentation_2.safeExecuteInTheMiddle)(() => requestHook2(span, {
              moduleVersion,
              cmdName: cmd.name,
              cmdArgs: cmd.args
            }), (e) => {
              if (e) {
                api_1.diag.error("ioredis instrumentation: request hook failed", e);
              }
            }, true);
          }
          const { host, port } = this.options;
          span.setAttributes({
            [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
            [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
            [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
          });
          try {
            const result = original.apply(this, arguments);
            const origResolve = cmd.resolve;
            cmd.resolve = function(result2) {
              (0, instrumentation_2.safeExecuteInTheMiddle)(() => {
                var _a;
                return (_a = config2.responseHook) === null || _a === void 0 ? void 0 : _a.call(config2, span, cmd.name, cmd.args, result2);
              }, (e) => {
                if (e) {
                  api_1.diag.error("ioredis instrumentation: response hook failed", e);
                }
              }, true);
              (0, utils_1.endSpan)(span, null);
              origResolve(result2);
            };
            const origReject = cmd.reject;
            cmd.reject = function(err) {
              (0, utils_1.endSpan)(span, err);
              origReject(err);
            };
            return result;
          } catch (error) {
            (0, utils_1.endSpan)(span, error);
            throw error;
          }
        };
      }
      _traceConnection(original) {
        const instrumentation = this;
        return function() {
          const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === void 0;
          if (instrumentation.getConfig().requireParentSpan === true && hasNoParentSpan) {
            return original.apply(this, arguments);
          }
          const span = instrumentation.tracer.startSpan("connect", {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: "connect"
            }
          });
          const { host, port } = this.options;
          span.setAttributes({
            [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
            [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
            [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
          });
          try {
            const client = original.apply(this, arguments);
            (0, utils_1.endSpan)(span, null);
            return client;
          } catch (error) {
            (0, utils_1.endSpan)(span, error);
            throw error;
          }
        };
      }
    };
    exports2.IORedisInstrumentation = IORedisInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-ioredis/build/src/types.js
var require_types10 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-ioredis/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-ioredis/build/src/index.js
var require_src20 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-ioredis/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation11(), exports2);
    __exportStar(require_types10(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-redis-4/build/src/utils.js
var require_utils13 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-redis-4/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getClientAttributes = void 0;
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    function getClientAttributes(diag3, options) {
      var _a, _b;
      return {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: (_a = options === null || options === void 0 ? void 0 : options.socket) === null || _a === void 0 ? void 0 : _a.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: (_b = options === null || options === void 0 ? void 0 : options.socket) === null || _b === void 0 ? void 0 : _b.port,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: removeCredentialsFromDBConnectionStringAttribute(diag3, options === null || options === void 0 ? void 0 : options.url)
      };
    }
    exports2.getClientAttributes = getClientAttributes;
    function removeCredentialsFromDBConnectionStringAttribute(diag3, url2) {
      if (typeof url2 !== "string" || !url2) {
        return;
      }
      try {
        const u = new URL(url2);
        u.searchParams.delete("user_pwd");
        u.username = "";
        u.password = "";
        return u.href;
      } catch (err) {
        diag3.error("failed to sanitize redis connection url", err);
      }
      return;
    }
  }
});

// node_modules/@opentelemetry/instrumentation-redis-4/build/src/version.js
var require_version14 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-redis-4/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.46.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-redis-4";
  }
});

// node_modules/@opentelemetry/instrumentation-redis-4/build/src/instrumentation.js
var require_instrumentation12 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-redis-4/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RedisInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var utils_1 = require_utils13();
    var redis_common_1 = require_src19();
    var version_1 = require_version14();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var OTEL_OPEN_SPANS = Symbol("opentelemetry.instrumentation.redis.open_spans");
    var MULTI_COMMAND_OPTIONS = Symbol("opentelemetry.instrumentation.redis.multi_command_options");
    var DEFAULT_CONFIG = {
      requireParentSpan: false
    };
    var RedisInstrumentation2 = class _RedisInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      setConfig(config2 = {}) {
        super.setConfig(Object.assign(Object.assign({}, DEFAULT_CONFIG), config2));
      }
      init() {
        return [
          this._getInstrumentationNodeModuleDefinition("@redis/client"),
          this._getInstrumentationNodeModuleDefinition("@node-redis/client")
        ];
      }
      _getInstrumentationNodeModuleDefinition(basePackageName) {
        const commanderModuleFile = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/commander.js`, ["^1.0.0"], (moduleExports, moduleVersion) => {
          const transformCommandArguments = moduleExports.transformCommandArguments;
          if (!transformCommandArguments) {
            this._diag.error("internal instrumentation error, missing transformCommandArguments function");
            return moduleExports;
          }
          const functionToPatch = (moduleVersion === null || moduleVersion === void 0 ? void 0 : moduleVersion.startsWith("1.0.")) ? "extendWithCommands" : "attachCommands";
          if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports[functionToPatch])) {
            this._unwrap(moduleExports, functionToPatch);
          }
          this._wrap(moduleExports, functionToPatch, this._getPatchExtendWithCommands(transformCommandArguments));
          return moduleExports;
        }, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.extendWithCommands)) {
            this._unwrap(moduleExports, "extendWithCommands");
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.attachCommands)) {
            this._unwrap(moduleExports, "attachCommands");
          }
        });
        const multiCommanderModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/multi-command.js`, ["^1.0.0"], (moduleExports) => {
          var _a;
          const redisClientMultiCommandPrototype = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a === void 0 ? void 0 : _a.prototype;
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.exec)) {
            this._unwrap(redisClientMultiCommandPrototype, "exec");
          }
          this._wrap(redisClientMultiCommandPrototype, "exec", this._getPatchMultiCommandsExec());
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.addCommand)) {
            this._unwrap(redisClientMultiCommandPrototype, "addCommand");
          }
          this._wrap(redisClientMultiCommandPrototype, "addCommand", this._getPatchMultiCommandsAddCommand());
          return moduleExports;
        }, (moduleExports) => {
          var _a;
          const redisClientMultiCommandPrototype = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a === void 0 ? void 0 : _a.prototype;
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.exec)) {
            this._unwrap(redisClientMultiCommandPrototype, "exec");
          }
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.addCommand)) {
            this._unwrap(redisClientMultiCommandPrototype, "addCommand");
          }
        });
        const clientIndexModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/index.js`, ["^1.0.0"], (moduleExports) => {
          var _a;
          const redisClientPrototype = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a === void 0 ? void 0 : _a.prototype;
          if (redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.multi) {
            if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.multi)) {
              this._unwrap(redisClientPrototype, "multi");
            }
            this._wrap(redisClientPrototype, "multi", this._getPatchRedisClientMulti());
          }
          if (redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.MULTI) {
            if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.MULTI)) {
              this._unwrap(redisClientPrototype, "MULTI");
            }
            this._wrap(redisClientPrototype, "MULTI", this._getPatchRedisClientMulti());
          }
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.sendCommand)) {
            this._unwrap(redisClientPrototype, "sendCommand");
          }
          this._wrap(redisClientPrototype, "sendCommand", this._getPatchRedisClientSendCommand());
          this._wrap(redisClientPrototype, "connect", this._getPatchedClientConnect());
          return moduleExports;
        }, (moduleExports) => {
          var _a;
          const redisClientPrototype = (_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a === void 0 ? void 0 : _a.prototype;
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.multi)) {
            this._unwrap(redisClientPrototype, "multi");
          }
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.MULTI)) {
            this._unwrap(redisClientPrototype, "MULTI");
          }
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.sendCommand)) {
            this._unwrap(redisClientPrototype, "sendCommand");
          }
        });
        return new instrumentation_1.InstrumentationNodeModuleDefinition(basePackageName, ["^1.0.0"], (moduleExports) => {
          return moduleExports;
        }, () => {
        }, [commanderModuleFile, multiCommanderModule, clientIndexModule]);
      }
      // serves both for redis 4.0.x where function name is extendWithCommands
      // and redis ^4.1.0 where function name is attachCommands
      _getPatchExtendWithCommands(transformCommandArguments) {
        const plugin = this;
        return function extendWithCommandsPatchWrapper(original) {
          return function extendWithCommandsPatch(config2) {
            var _a;
            if (((_a = config2 === null || config2 === void 0 ? void 0 : config2.BaseClass) === null || _a === void 0 ? void 0 : _a.name) !== "RedisClient") {
              return original.apply(this, arguments);
            }
            const origExecutor = config2.executor;
            config2.executor = function(command, args) {
              const redisCommandArguments = transformCommandArguments(command, args).args;
              return plugin._traceClientCommand(origExecutor, this, arguments, redisCommandArguments);
            };
            return original.apply(this, arguments);
          };
        };
      }
      _getPatchMultiCommandsExec() {
        const plugin = this;
        return function execPatchWrapper(original) {
          return function execPatch() {
            const execRes = original.apply(this, arguments);
            if (typeof (execRes === null || execRes === void 0 ? void 0 : execRes.then) !== "function") {
              plugin._diag.error("got non promise result when patching RedisClientMultiCommand.exec");
              return execRes;
            }
            return execRes.then((redisRes) => {
              const openSpans = this[OTEL_OPEN_SPANS];
              plugin._endSpansWithRedisReplies(openSpans, redisRes);
              return redisRes;
            }).catch((err) => {
              const openSpans = this[OTEL_OPEN_SPANS];
              if (!openSpans) {
                plugin._diag.error("cannot find open spans to end for redis multi command");
              } else {
                const replies = err.constructor.name === "MultiErrorReply" ? err.replies : new Array(openSpans.length).fill(err);
                plugin._endSpansWithRedisReplies(openSpans, replies);
              }
              return Promise.reject(err);
            });
          };
        };
      }
      _getPatchMultiCommandsAddCommand() {
        const plugin = this;
        return function addCommandWrapper(original) {
          return function addCommandPatch(args) {
            return plugin._traceClientCommand(original, this, arguments, args);
          };
        };
      }
      _getPatchRedisClientMulti() {
        return function multiPatchWrapper(original) {
          return function multiPatch() {
            const multiRes = original.apply(this, arguments);
            multiRes[MULTI_COMMAND_OPTIONS] = this.options;
            return multiRes;
          };
        };
      }
      _getPatchRedisClientSendCommand() {
        const plugin = this;
        return function sendCommandWrapper(original) {
          return function sendCommandPatch(args) {
            return plugin._traceClientCommand(original, this, arguments, args);
          };
        };
      }
      _getPatchedClientConnect() {
        const plugin = this;
        return function connectWrapper(original) {
          return function patchedConnect() {
            const options = this.options;
            const attributes = (0, utils_1.getClientAttributes)(plugin._diag, options);
            const span = plugin.tracer.startSpan(`${_RedisInstrumentation.COMPONENT}-connect`, {
              kind: api_1.SpanKind.CLIENT,
              attributes
            });
            const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return original.apply(this);
            });
            return res.then((result) => {
              span.end();
              return result;
            }).catch((error) => {
              span.recordException(error);
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: error.message
              });
              span.end();
              return Promise.reject(error);
            });
          };
        };
      }
      _traceClientCommand(origFunction, origThis, origArguments, redisCommandArguments) {
        const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === void 0;
        if (hasNoParentSpan && this.getConfig().requireParentSpan) {
          return origFunction.apply(origThis, origArguments);
        }
        const clientOptions = origThis.options || origThis[MULTI_COMMAND_OPTIONS];
        const commandName = redisCommandArguments[0];
        const commandArgs = redisCommandArguments.slice(1);
        const dbStatementSerializer = this.getConfig().dbStatementSerializer || redis_common_1.defaultDbStatementSerializer;
        const attributes = (0, utils_1.getClientAttributes)(this._diag, clientOptions);
        try {
          const dbStatement = dbStatementSerializer(commandName, commandArgs);
          if (dbStatement != null) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatement;
          }
        } catch (e) {
          this._diag.error("dbStatementSerializer throw an exception", e, {
            commandName
          });
        }
        const span = this.tracer.startSpan(`${_RedisInstrumentation.COMPONENT}-${commandName}`, {
          kind: api_1.SpanKind.CLIENT,
          attributes
        });
        const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return origFunction.apply(origThis, origArguments);
        });
        if (typeof (res === null || res === void 0 ? void 0 : res.then) === "function") {
          res.then((redisRes) => {
            this._endSpanWithResponse(span, commandName, commandArgs, redisRes, void 0);
          }, (err) => {
            this._endSpanWithResponse(span, commandName, commandArgs, null, err);
          });
        } else {
          const redisClientMultiCommand = res;
          redisClientMultiCommand[OTEL_OPEN_SPANS] = redisClientMultiCommand[OTEL_OPEN_SPANS] || [];
          redisClientMultiCommand[OTEL_OPEN_SPANS].push({
            span,
            commandName,
            commandArgs
          });
        }
        return res;
      }
      _endSpansWithRedisReplies(openSpans, replies) {
        if (!openSpans) {
          return this._diag.error("cannot find open spans to end for redis multi command");
        }
        if (replies.length !== openSpans.length) {
          return this._diag.error("number of multi command spans does not match response from redis");
        }
        for (let i = 0; i < openSpans.length; i++) {
          const { span, commandName, commandArgs } = openSpans[i];
          const currCommandRes = replies[i];
          const [res, err] = currCommandRes instanceof Error ? [null, currCommandRes] : [currCommandRes, void 0];
          this._endSpanWithResponse(span, commandName, commandArgs, res, err);
        }
      }
      _endSpanWithResponse(span, commandName, commandArgs, response, error) {
        const { responseHook } = this.getConfig();
        if (!error && responseHook) {
          try {
            responseHook(span, commandName, commandArgs, response);
          } catch (err) {
            this._diag.error("responseHook throw an exception", err);
          }
        }
        if (error) {
          span.recordException(error);
          span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error === null || error === void 0 ? void 0 : error.message });
        }
        span.end();
      }
    };
    exports2.RedisInstrumentation = RedisInstrumentation2;
    RedisInstrumentation2.COMPONENT = "redis";
  }
});

// node_modules/@opentelemetry/instrumentation-redis-4/build/src/types.js
var require_types11 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-redis-4/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-redis-4/build/src/index.js
var require_src21 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-redis-4/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation12(), exports2);
    __exportStar(require_types11(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/internal-types.js
var require_internal_types4 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EVENT_LISTENERS_SET = void 0;
    exports2.EVENT_LISTENERS_SET = Symbol("opentelemetry.instrumentation.pg.eventListenersSet");
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/enums/AttributeNames.js
var require_AttributeNames6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["PG_VALUES"] = "db.postgresql.values";
      AttributeNames3["PG_PLAN"] = "db.postgresql.plan";
      AttributeNames3["IDLE_TIMEOUT_MILLIS"] = "db.postgresql.idle.timeout.millis";
      AttributeNames3["MAX_CLIENT"] = "db.postgresql.max.client";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/semconv.js
var require_semconv = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/semconv.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.METRIC_DB_CLIENT_OPERATION_DURATION = exports2.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS = exports2.METRIC_DB_CLIENT_CONNECTION_COUNT = exports2.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE = exports2.DB_CLIENT_CONNECTION_STATE_VALUE_USED = exports2.ATTR_DB_OPERATION_NAME = exports2.ATTR_DB_NAMESPACE = exports2.ATTR_DB_CLIENT_CONNECTION_STATE = exports2.ATTR_DB_CLIENT_CONNECTION_POOL_NAME = void 0;
    exports2.ATTR_DB_CLIENT_CONNECTION_POOL_NAME = "db.client.connection.pool.name";
    exports2.ATTR_DB_CLIENT_CONNECTION_STATE = "db.client.connection.state";
    exports2.ATTR_DB_NAMESPACE = "db.namespace";
    exports2.ATTR_DB_OPERATION_NAME = "db.operation.name";
    exports2.DB_CLIENT_CONNECTION_STATE_VALUE_USED = "used";
    exports2.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE = "idle";
    exports2.METRIC_DB_CLIENT_CONNECTION_COUNT = "db.client.connection.count";
    exports2.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS = "db.client.connection.pending_requests";
    exports2.METRIC_DB_CLIENT_OPERATION_DURATION = "db.client.operation.duration";
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/enums/SpanNames.js
var require_SpanNames = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/enums/SpanNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpanNames = void 0;
    var SpanNames;
    (function(SpanNames2) {
      SpanNames2["QUERY_PREFIX"] = "pg.query";
      SpanNames2["CONNECT"] = "pg.connect";
      SpanNames2["POOL_CONNECT"] = "pg-pool.connect";
    })(SpanNames = exports2.SpanNames || (exports2.SpanNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/utils.js
var require_utils14 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObjectWithTextString = exports2.getErrorMessage = exports2.patchClientConnectCallback = exports2.patchCallbackPGPool = exports2.updateCounter = exports2.getPoolName = exports2.patchCallback = exports2.handleExecutionResult = exports2.handleConfigQuery = exports2.shouldSkipInstrumentation = exports2.getSemanticAttributesFromPool = exports2.getSemanticAttributesFromConnection = exports2.getConnectionString = exports2.parseNormalizedOperationName = exports2.getQuerySpanName = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AttributeNames_1 = require_AttributeNames6();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var semconv_1 = require_semconv();
    var instrumentation_1 = require_src4();
    var SpanNames_1 = require_SpanNames();
    function getQuerySpanName(dbName, queryConfig) {
      if (!queryConfig)
        return SpanNames_1.SpanNames.QUERY_PREFIX;
      const command = typeof queryConfig.name === "string" && queryConfig.name ? queryConfig.name : parseNormalizedOperationName(queryConfig.text);
      return `${SpanNames_1.SpanNames.QUERY_PREFIX}:${command}${dbName ? ` ${dbName}` : ""}`;
    }
    exports2.getQuerySpanName = getQuerySpanName;
    function parseNormalizedOperationName(queryText) {
      const indexOfFirstSpace = queryText.indexOf(" ");
      let sqlCommand = indexOfFirstSpace === -1 ? queryText : queryText.slice(0, indexOfFirstSpace);
      sqlCommand = sqlCommand.toUpperCase();
      return sqlCommand.endsWith(";") ? sqlCommand.slice(0, -1) : sqlCommand;
    }
    exports2.parseNormalizedOperationName = parseNormalizedOperationName;
    function getConnectionString(params) {
      const host = params.host || "localhost";
      const port = params.port || 5432;
      const database = params.database || "";
      return `postgresql://${host}:${port}/${database}`;
    }
    exports2.getConnectionString = getConnectionString;
    function getPort(port) {
      if (Number.isInteger(port)) {
        return port;
      }
      return void 0;
    }
    function getSemanticAttributesFromConnection(params) {
      return {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: params.database,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getConnectionString(params),
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: params.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: getPort(params.port),
        [semantic_conventions_1.SEMATTRS_DB_USER]: params.user
      };
    }
    exports2.getSemanticAttributesFromConnection = getSemanticAttributesFromConnection;
    function getSemanticAttributesFromPool(params) {
      return {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: params.database,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getConnectionString(params),
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: params.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: getPort(params.port),
        [semantic_conventions_1.SEMATTRS_DB_USER]: params.user,
        [AttributeNames_1.AttributeNames.IDLE_TIMEOUT_MILLIS]: params.idleTimeoutMillis,
        [AttributeNames_1.AttributeNames.MAX_CLIENT]: params.maxClient
      };
    }
    exports2.getSemanticAttributesFromPool = getSemanticAttributesFromPool;
    function shouldSkipInstrumentation(instrumentationConfig) {
      return instrumentationConfig.requireParentSpan === true && api_1.trace.getSpan(api_1.context.active()) === void 0;
    }
    exports2.shouldSkipInstrumentation = shouldSkipInstrumentation;
    function handleConfigQuery(tracer, instrumentationConfig, queryConfig) {
      const { connectionParameters } = this;
      const dbName = connectionParameters.database;
      const spanName = getQuerySpanName(dbName, queryConfig);
      const span = tracer.startSpan(spanName, {
        kind: api_1.SpanKind.CLIENT,
        attributes: getSemanticAttributesFromConnection(connectionParameters)
      });
      if (!queryConfig) {
        return span;
      }
      if (queryConfig.text) {
        span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, queryConfig.text);
      }
      if (instrumentationConfig.enhancedDatabaseReporting && Array.isArray(queryConfig.values)) {
        try {
          const convertedValues = queryConfig.values.map((value) => {
            if (value == null) {
              return "null";
            } else if (value instanceof Buffer) {
              return value.toString();
            } else if (typeof value === "object") {
              if (typeof value.toPostgres === "function") {
                return value.toPostgres();
              }
              return JSON.stringify(value);
            } else {
              return value.toString();
            }
          });
          span.setAttribute(AttributeNames_1.AttributeNames.PG_VALUES, convertedValues);
        } catch (e) {
          api_1.diag.error("failed to stringify ", queryConfig.values, e);
        }
      }
      if (typeof queryConfig.name === "string") {
        span.setAttribute(AttributeNames_1.AttributeNames.PG_PLAN, queryConfig.name);
      }
      return span;
    }
    exports2.handleConfigQuery = handleConfigQuery;
    function handleExecutionResult(config2, span, pgResult) {
      if (typeof config2.responseHook === "function") {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          config2.responseHook(span, {
            data: pgResult
          });
        }, (err) => {
          if (err) {
            api_1.diag.error("Error running response hook", err);
          }
        }, true);
      }
    }
    exports2.handleExecutionResult = handleExecutionResult;
    function patchCallback(instrumentationConfig, span, cb, attributes, recordDuration) {
      return function patchedCallback(err, res) {
        if (err) {
          if (Object.prototype.hasOwnProperty.call(err, "code")) {
            attributes[semantic_conventions_1.ATTR_ERROR_TYPE] = err["code"];
          }
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
        } else {
          handleExecutionResult(instrumentationConfig, span, res);
        }
        recordDuration();
        span.end();
        cb.call(this, err, res);
      };
    }
    exports2.patchCallback = patchCallback;
    function getPoolName(pool) {
      let poolName = "";
      poolName += ((pool === null || pool === void 0 ? void 0 : pool.host) ? `${pool.host}` : "unknown_host") + ":";
      poolName += ((pool === null || pool === void 0 ? void 0 : pool.port) ? `${pool.port}` : "unknown_port") + "/";
      poolName += (pool === null || pool === void 0 ? void 0 : pool.database) ? `${pool.database}` : "unknown_database";
      return poolName.trim();
    }
    exports2.getPoolName = getPoolName;
    function updateCounter(poolName, pool, connectionCount, connectionPendingRequests, latestCounter) {
      const all = pool.totalCount;
      const pending = pool.waitingCount;
      const idle = pool.idleCount;
      const used = all - idle;
      connectionCount.add(used - latestCounter.used, {
        [semconv_1.ATTR_DB_CLIENT_CONNECTION_STATE]: semconv_1.DB_CLIENT_CONNECTION_STATE_VALUE_USED,
        [semconv_1.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: poolName
      });
      connectionCount.add(idle - latestCounter.idle, {
        [semconv_1.ATTR_DB_CLIENT_CONNECTION_STATE]: semconv_1.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE,
        [semconv_1.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: poolName
      });
      connectionPendingRequests.add(pending - latestCounter.pending, {
        [semconv_1.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: poolName
      });
      return { used, idle, pending };
    }
    exports2.updateCounter = updateCounter;
    function patchCallbackPGPool(span, cb) {
      return function patchedCallback(err, res, done) {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
        }
        span.end();
        cb.call(this, err, res, done);
      };
    }
    exports2.patchCallbackPGPool = patchCallbackPGPool;
    function patchClientConnectCallback(span, cb) {
      return function patchedClientConnectCallback(err) {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
        }
        span.end();
        cb.apply(this, arguments);
      };
    }
    exports2.patchClientConnectCallback = patchClientConnectCallback;
    function getErrorMessage(e) {
      return typeof e === "object" && e !== null && "message" in e ? String(e.message) : void 0;
    }
    exports2.getErrorMessage = getErrorMessage;
    function isObjectWithTextString(it) {
      var _a;
      return typeof it === "object" && typeof ((_a = it) === null || _a === void 0 ? void 0 : _a.text) === "string";
    }
    exports2.isObjectWithTextString = isObjectWithTextString;
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/version.js
var require_version15 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.51.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-pg";
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/instrumentation.js
var require_instrumentation13 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PgInstrumentation = void 0;
    var instrumentation_1 = require_src4();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var internal_types_1 = require_internal_types4();
    var utils = require_utils14();
    var sql_common_1 = require_src17();
    var version_1 = require_version15();
    var SpanNames_1 = require_SpanNames();
    var core_1 = require_src();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var semconv_1 = require_semconv();
    function extractModuleExports(module3) {
      return module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
    }
    var PgInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
        this._connectionsCounter = {
          used: 0,
          idle: 0,
          pending: 0
        };
      }
      _updateMetricInstruments() {
        this._operationDuration = this.meter.createHistogram(semconv_1.METRIC_DB_CLIENT_OPERATION_DURATION, {
          description: "Duration of database client operations.",
          unit: "s",
          valueType: api_1.ValueType.DOUBLE,
          advice: {
            explicitBucketBoundaries: [
              1e-3,
              5e-3,
              0.01,
              0.05,
              0.1,
              0.5,
              1,
              5,
              10
            ]
          }
        });
        this._connectionsCounter = {
          idle: 0,
          pending: 0,
          used: 0
        };
        this._connectionsCount = this.meter.createUpDownCounter(semconv_1.METRIC_DB_CLIENT_CONNECTION_COUNT, {
          description: "The number of connections that are currently in state described by the state attribute.",
          unit: "{connection}"
        });
        this._connectionPendingRequests = this.meter.createUpDownCounter(semconv_1.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS, {
          description: "The number of current pending requests for an open connection.",
          unit: "{connection}"
        });
      }
      init() {
        const SUPPORTED_PG_VERSIONS = [">=8.0.3 <9"];
        const modulePgNativeClient = new instrumentation_1.InstrumentationNodeModuleFile("pg/lib/native/client.js", SUPPORTED_PG_VERSIONS, this._patchPgClient.bind(this), this._unpatchPgClient.bind(this));
        const modulePgClient = new instrumentation_1.InstrumentationNodeModuleFile("pg/lib/client.js", SUPPORTED_PG_VERSIONS, this._patchPgClient.bind(this), this._unpatchPgClient.bind(this));
        const modulePG = new instrumentation_1.InstrumentationNodeModuleDefinition("pg", SUPPORTED_PG_VERSIONS, (module3) => {
          const moduleExports = extractModuleExports(module3);
          this._patchPgClient(moduleExports.Client);
          return module3;
        }, (module3) => {
          const moduleExports = extractModuleExports(module3);
          this._unpatchPgClient(moduleExports.Client);
          return module3;
        }, [modulePgClient, modulePgNativeClient]);
        const modulePGPool = new instrumentation_1.InstrumentationNodeModuleDefinition("pg-pool", [">=2.0.0 <4"], (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
            this._unwrap(moduleExports.prototype, "connect");
          }
          this._wrap(moduleExports.prototype, "connect", this._getPoolConnectPatch());
          return moduleExports;
        }, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
            this._unwrap(moduleExports.prototype, "connect");
          }
        });
        return [modulePG, modulePGPool];
      }
      _patchPgClient(module3) {
        if (!module3) {
          return;
        }
        const moduleExports = extractModuleExports(module3);
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.query)) {
          this._unwrap(moduleExports.prototype, "query");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
          this._unwrap(moduleExports.prototype, "connect");
        }
        this._wrap(moduleExports.prototype, "query", this._getClientQueryPatch());
        this._wrap(moduleExports.prototype, "connect", this._getClientConnectPatch());
        return module3;
      }
      _unpatchPgClient(module3) {
        const moduleExports = extractModuleExports(module3);
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.query)) {
          this._unwrap(moduleExports.prototype, "query");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
          this._unwrap(moduleExports.prototype, "connect");
        }
        return module3;
      }
      _getClientConnectPatch() {
        const plugin = this;
        return (original) => {
          return function connect3(callback) {
            if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
              return original.call(this, callback);
            }
            const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.CONNECT, {
              kind: api_1.SpanKind.CLIENT,
              attributes: utils.getSemanticAttributesFromConnection(this)
            });
            if (callback) {
              const parentSpan = api_1.trace.getSpan(api_1.context.active());
              callback = utils.patchClientConnectCallback(span, callback);
              if (parentSpan) {
                callback = api_1.context.bind(api_1.context.active(), callback);
              }
            }
            const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return original.call(this, callback);
            });
            return handleConnectResult(span, connectResult);
          };
        };
      }
      recordOperationDuration(attributes, startTime) {
        const metricsAttributes = {};
        const keysToCopy = [
          semantic_conventions_1.SEMATTRS_DB_SYSTEM,
          semconv_1.ATTR_DB_NAMESPACE,
          semantic_conventions_1.ATTR_ERROR_TYPE,
          semantic_conventions_1.ATTR_SERVER_PORT,
          semantic_conventions_1.ATTR_SERVER_ADDRESS,
          semconv_1.ATTR_DB_OPERATION_NAME
        ];
        keysToCopy.forEach((key) => {
          if (key in attributes) {
            metricsAttributes[key] = attributes[key];
          }
        });
        const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1e3;
        this._operationDuration.record(durationSeconds, metricsAttributes);
      }
      _getClientQueryPatch() {
        const plugin = this;
        return (original) => {
          this._diag.debug("Patching pg.Client.prototype.query");
          return function query(...args) {
            if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
              return original.apply(this, args);
            }
            const startTime = (0, core_1.hrTime)();
            const arg0 = args[0];
            const firstArgIsString = typeof arg0 === "string";
            const firstArgIsQueryObjectWithText = utils.isObjectWithTextString(arg0);
            const queryConfig = firstArgIsString ? {
              text: arg0,
              values: Array.isArray(args[1]) ? args[1] : void 0
            } : firstArgIsQueryObjectWithText ? arg0 : void 0;
            const attributes = {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
              [semconv_1.ATTR_DB_NAMESPACE]: this.database,
              [semantic_conventions_1.ATTR_SERVER_PORT]: this.connectionParameters.port,
              [semantic_conventions_1.ATTR_SERVER_ADDRESS]: this.connectionParameters.host
            };
            if (queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.text) {
              attributes[semconv_1.ATTR_DB_OPERATION_NAME] = utils.parseNormalizedOperationName(queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.text);
            }
            const recordDuration = () => {
              plugin.recordOperationDuration(attributes, startTime);
            };
            const instrumentationConfig = plugin.getConfig();
            const span = utils.handleConfigQuery.call(this, plugin.tracer, instrumentationConfig, queryConfig);
            if (instrumentationConfig.addSqlCommenterCommentToQueries) {
              if (firstArgIsString) {
                args[0] = (0, sql_common_1.addSqlCommenterComment)(span, arg0);
              } else if (firstArgIsQueryObjectWithText && !("name" in arg0)) {
                args[0] = Object.assign(Object.assign({}, arg0), { text: (0, sql_common_1.addSqlCommenterComment)(span, arg0.text) });
              }
            }
            if (args.length > 0) {
              const parentSpan = api_1.trace.getSpan(api_1.context.active());
              if (typeof args[args.length - 1] === "function") {
                args[args.length - 1] = utils.patchCallback(
                  instrumentationConfig,
                  span,
                  args[args.length - 1],
                  // nb: not type safe.
                  attributes,
                  recordDuration
                );
                if (parentSpan) {
                  args[args.length - 1] = api_1.context.bind(api_1.context.active(), args[args.length - 1]);
                }
              } else if (typeof (queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.callback) === "function") {
                let callback = utils.patchCallback(
                  plugin.getConfig(),
                  span,
                  queryConfig.callback,
                  // nb: not type safe.
                  attributes,
                  recordDuration
                );
                if (parentSpan) {
                  callback = api_1.context.bind(api_1.context.active(), callback);
                }
                args[0].callback = callback;
              }
            }
            const { requestHook: requestHook2 } = instrumentationConfig;
            if (typeof requestHook2 === "function" && queryConfig) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                const { database, host, port, user } = this.connectionParameters;
                const connection = { database, host, port, user };
                requestHook2(span, {
                  connection,
                  query: {
                    text: queryConfig.text,
                    // nb: if `client.query` is called with illegal arguments
                    // (e.g., if `queryConfig.values` is passed explicitly, but a
                    // non-array is given), then the type casts will be wrong. But
                    // we leave it up to the queryHook to handle that, and we
                    // catch and swallow any errors it throws. The other options
                    // are all worse. E.g., we could leave `queryConfig.values`
                    // and `queryConfig.name` as `unknown`, but then the hook body
                    // would be forced to validate (or cast) them before using
                    // them, which seems incredibly cumbersome given that these
                    // casts will be correct 99.9% of the time -- and pg.query
                    // will immediately throw during development in the other .1%
                    // of cases. Alternatively, we could simply skip calling the
                    // hook when `values` or `name` don't have the expected type,
                    // but that would add unnecessary validation overhead to every
                    // hook invocation and possibly be even more confusing/unexpected.
                    values: queryConfig.values,
                    name: queryConfig.name
                  }
                });
              }, (err) => {
                if (err) {
                  plugin._diag.error("Error running query hook", err);
                }
              }, true);
            }
            let result;
            try {
              result = original.apply(this, args);
            } catch (e) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: utils.getErrorMessage(e)
              });
              span.end();
              throw e;
            }
            if (result instanceof Promise) {
              return result.then((result2) => {
                return new Promise((resolve2) => {
                  utils.handleExecutionResult(plugin.getConfig(), span, result2);
                  recordDuration();
                  span.end();
                  resolve2(result2);
                });
              }).catch((error) => {
                return new Promise((_, reject) => {
                  span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: error.message
                  });
                  recordDuration();
                  span.end();
                  reject(error);
                });
              });
            }
            return result;
          };
        };
      }
      _setPoolConnectEventListeners(pgPool) {
        if (pgPool[internal_types_1.EVENT_LISTENERS_SET])
          return;
        const poolName = utils.getPoolName(pgPool.options);
        pgPool.on("connect", () => {
          this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
        });
        pgPool.on("acquire", () => {
          this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
        });
        pgPool.on("remove", () => {
          this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
        });
        pgPool.on("release", () => {
          this._connectionsCounter = utils.updateCounter(poolName, pgPool, this._connectionsCount, this._connectionPendingRequests, this._connectionsCounter);
        });
        pgPool[internal_types_1.EVENT_LISTENERS_SET] = true;
      }
      _getPoolConnectPatch() {
        const plugin = this;
        return (originalConnect) => {
          return function connect3(callback) {
            if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
              return originalConnect.call(this, callback);
            }
            const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.POOL_CONNECT, {
              kind: api_1.SpanKind.CLIENT,
              attributes: utils.getSemanticAttributesFromPool(this.options)
            });
            plugin._setPoolConnectEventListeners(this);
            if (callback) {
              const parentSpan = api_1.trace.getSpan(api_1.context.active());
              callback = utils.patchCallbackPGPool(span, callback);
              if (parentSpan) {
                callback = api_1.context.bind(api_1.context.active(), callback);
              }
            }
            const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return originalConnect.call(this, callback);
            });
            return handleConnectResult(span, connectResult);
          };
        };
      }
    };
    exports2.PgInstrumentation = PgInstrumentation2;
    function handleConnectResult(span, connectResult) {
      if (!(connectResult instanceof Promise)) {
        return connectResult;
      }
      const connectResultPromise = connectResult;
      return api_1.context.bind(api_1.context.active(), connectResultPromise.then((result) => {
        span.end();
        return result;
      }).catch((error) => {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: utils.getErrorMessage(error)
        });
        span.end();
        return Promise.reject(error);
      }));
    }
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/types.js
var require_types12 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-pg/build/src/index.js
var require_src22 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-pg/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation13(), exports2);
    __exportStar(require_types12(), exports2);
    __exportStar(require_AttributeNames6(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-hapi/build/src/version.js
var require_version16 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-hapi/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.45.2";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-hapi";
  }
});

// node_modules/@opentelemetry/instrumentation-hapi/build/src/internal-types.js
var require_internal_types5 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-hapi/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HapiLifecycleMethodNames = exports2.HapiLayerType = exports2.handlerPatched = exports2.HapiComponentName = void 0;
    exports2.HapiComponentName = "@hapi/hapi";
    exports2.handlerPatched = Symbol("hapi-handler-patched");
    exports2.HapiLayerType = {
      ROUTER: "router",
      PLUGIN: "plugin",
      EXT: "server.ext"
    };
    exports2.HapiLifecycleMethodNames = /* @__PURE__ */ new Set([
      "onPreAuth",
      "onCredentials",
      "onPostAuth",
      "onPreHandler",
      "onPostHandler",
      "onPreResponse",
      "onRequest"
    ]);
  }
});

// node_modules/@opentelemetry/instrumentation-hapi/build/src/enums/AttributeNames.js
var require_AttributeNames7 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-hapi/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["HAPI_TYPE"] = "hapi.type";
      AttributeNames3["PLUGIN_NAME"] = "hapi.plugin.name";
      AttributeNames3["EXT_TYPE"] = "server.ext.type";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-hapi/build/src/utils.js
var require_utils15 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-hapi/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPluginFromInput = exports2.getExtMetadata = exports2.getRouteMetadata = exports2.isPatchableExtMethod = exports2.isDirectExtInput = exports2.isLifecycleExtEventObj = exports2.isLifecycleExtType = exports2.getPluginName = void 0;
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var internal_types_1 = require_internal_types5();
    var AttributeNames_1 = require_AttributeNames7();
    function getPluginName(plugin) {
      if (plugin.name) {
        return plugin.name;
      } else {
        return plugin.pkg.name;
      }
    }
    exports2.getPluginName = getPluginName;
    var isLifecycleExtType = (variableToCheck) => {
      return typeof variableToCheck === "string" && internal_types_1.HapiLifecycleMethodNames.has(variableToCheck);
    };
    exports2.isLifecycleExtType = isLifecycleExtType;
    var isLifecycleExtEventObj = (variableToCheck) => {
      var _a;
      const event = (_a = variableToCheck) === null || _a === void 0 ? void 0 : _a.type;
      return event !== void 0 && (0, exports2.isLifecycleExtType)(event);
    };
    exports2.isLifecycleExtEventObj = isLifecycleExtEventObj;
    var isDirectExtInput = (variableToCheck) => {
      return Array.isArray(variableToCheck) && variableToCheck.length <= 3 && (0, exports2.isLifecycleExtType)(variableToCheck[0]) && typeof variableToCheck[1] === "function";
    };
    exports2.isDirectExtInput = isDirectExtInput;
    var isPatchableExtMethod = (variableToCheck) => {
      return !Array.isArray(variableToCheck);
    };
    exports2.isPatchableExtMethod = isPatchableExtMethod;
    var getRouteMetadata = (route, pluginName) => {
      if (pluginName) {
        return {
          attributes: {
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.path,
            [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: route.method,
            [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.PLUGIN,
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
          },
          name: `${pluginName}: route - ${route.path}`
        };
      }
      return {
        attributes: {
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.path,
          [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: route.method,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.ROUTER
        },
        name: `route - ${route.path}`
      };
    };
    exports2.getRouteMetadata = getRouteMetadata;
    var getExtMetadata = (extPoint, pluginName) => {
      if (pluginName) {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
            [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT,
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
          },
          name: `${pluginName}: ext - ${extPoint}`
        };
      }
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT
        },
        name: `ext - ${extPoint}`
      };
    };
    exports2.getExtMetadata = getExtMetadata;
    var getPluginFromInput = (pluginObj) => {
      if ("plugin" in pluginObj) {
        if ("plugin" in pluginObj.plugin) {
          return pluginObj.plugin.plugin;
        }
        return pluginObj.plugin;
      }
      return pluginObj;
    };
    exports2.getPluginFromInput = getPluginFromInput;
  }
});

// node_modules/@opentelemetry/instrumentation-hapi/build/src/instrumentation.js
var require_instrumentation14 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-hapi/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HapiInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var instrumentation_1 = require_src4();
    var version_1 = require_version16();
    var internal_types_1 = require_internal_types5();
    var utils_1 = require_utils15();
    var HapiInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition(internal_types_1.HapiComponentName, [">=17.0.0 <22"], (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if (!(0, instrumentation_1.isWrapped)(moduleExports.server)) {
            this._wrap(moduleExports, "server", this._getServerPatch.bind(this));
          }
          if (!(0, instrumentation_1.isWrapped)(moduleExports.Server)) {
            this._wrap(moduleExports, "Server", this._getServerPatch.bind(this));
          }
          return moduleExports;
        }, (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          this._massUnwrap([moduleExports], ["server", "Server"]);
        });
      }
      /**
       * Patches the Hapi.server and Hapi.Server functions in order to instrument
       * the server.route, server.ext, and server.register functions via calls to the
       * @function _getServerRoutePatch, @function _getServerExtPatch, and
       * @function _getServerRegisterPatch functions
       * @param original - the original Hapi Server creation function
       */
      _getServerPatch(original) {
        const instrumentation = this;
        const self = this;
        return function server(opts) {
          const newServer = original.apply(this, [opts]);
          self._wrap(newServer, "route", (originalRouter) => {
            return instrumentation._getServerRoutePatch.bind(instrumentation)(originalRouter);
          });
          self._wrap(newServer, "ext", (originalExtHandler) => {
            return instrumentation._getServerExtPatch.bind(instrumentation)(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              originalExtHandler
            );
          });
          self._wrap(
            newServer,
            "register",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            instrumentation._getServerRegisterPatch.bind(instrumentation)
          );
          return newServer;
        };
      }
      /**
       * Patches the plugin register function used by the Hapi Server. This function
       * goes through each plugin that is being registered and adds instrumentation
       * via a call to the @function _wrapRegisterHandler function.
       * @param {RegisterFunction<T>} original - the original register function which
       * registers each plugin on the server
       */
      _getServerRegisterPatch(original) {
        const instrumentation = this;
        return function register(pluginInput, options) {
          if (Array.isArray(pluginInput)) {
            for (const pluginObj of pluginInput) {
              const plugin = (0, utils_1.getPluginFromInput)(pluginObj);
              instrumentation._wrapRegisterHandler(plugin);
            }
          } else {
            const plugin = (0, utils_1.getPluginFromInput)(pluginInput);
            instrumentation._wrapRegisterHandler(plugin);
          }
          return original.apply(this, [pluginInput, options]);
        };
      }
      /**
       * Patches the Server.ext function which adds extension methods to the specified
       * point along the request lifecycle. This function accepts the full range of
       * accepted input into the standard Hapi `server.ext` function. For each extension,
       * it adds instrumentation to the handler via a call to the @function _wrapExtMethods
       * function.
       * @param original - the original ext function which adds the extension method to the server
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server extension. Else, signifies that the extension was added directly
       */
      _getServerExtPatch(original, pluginName) {
        const instrumentation = this;
        return function ext(...args) {
          if (Array.isArray(args[0])) {
            const eventsList = args[0];
            for (let i = 0; i < eventsList.length; i++) {
              const eventObj = eventsList[i];
              if ((0, utils_1.isLifecycleExtType)(eventObj.type)) {
                const lifecycleEventObj = eventObj;
                const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, eventObj.type, pluginName);
                lifecycleEventObj.method = handler;
                eventsList[i] = lifecycleEventObj;
              }
            }
            return original.apply(this, args);
          } else if ((0, utils_1.isDirectExtInput)(args)) {
            const extInput = args;
            const method = extInput[1];
            const handler = instrumentation._wrapExtMethods(method, extInput[0], pluginName);
            return original.apply(this, [extInput[0], handler, extInput[2]]);
          } else if ((0, utils_1.isLifecycleExtEventObj)(args[0])) {
            const lifecycleEventObj = args[0];
            const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, lifecycleEventObj.type, pluginName);
            lifecycleEventObj.method = handler;
            return original.call(this, lifecycleEventObj);
          }
          return original.apply(this, args);
        };
      }
      /**
       * Patches the Server.route function. This function accepts either one or an array
       * of Hapi.ServerRoute objects and adds instrumentation on each route via a call to
       * the @function _wrapRouteHandler function.
       * @param {HapiServerRouteInputMethod} original - the original route function which adds
       * the route to the server
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server route. Else, signifies that the route was added directly
       */
      _getServerRoutePatch(original, pluginName) {
        const instrumentation = this;
        return function route(route) {
          if (Array.isArray(route)) {
            for (let i = 0; i < route.length; i++) {
              const newRoute = instrumentation._wrapRouteHandler.call(instrumentation, route[i], pluginName);
              route[i] = newRoute;
            }
          } else {
            route = instrumentation._wrapRouteHandler.call(instrumentation, route, pluginName);
          }
          return original.apply(this, [route]);
        };
      }
      /**
       * Wraps newly registered plugins to add instrumentation to the plugin's clone of
       * the original server. Specifically, wraps the server.route and server.ext functions
       * via calls to @function _getServerRoutePatch and @function _getServerExtPatch
       * @param {Hapi.Plugin<T>} plugin - the new plugin which is being instrumented
       */
      _wrapRegisterHandler(plugin) {
        const instrumentation = this;
        const pluginName = (0, utils_1.getPluginName)(plugin);
        const oldRegister = plugin.register;
        const self = this;
        const newRegisterHandler = function(server, options) {
          self._wrap(server, "route", (original) => {
            return instrumentation._getServerRoutePatch.bind(instrumentation)(original, pluginName);
          });
          self._wrap(server, "ext", (originalExtHandler) => {
            return instrumentation._getServerExtPatch.bind(instrumentation)(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              originalExtHandler,
              pluginName
            );
          });
          return oldRegister.call(this, server, options);
        };
        plugin.register = newRegisterHandler;
      }
      /**
       * Wraps request extension methods to add instrumentation to each new extension handler.
       * Patches each individual extension in order to create the
       * span and propagate context. It does not create spans when there is no parent span.
       * @param {PatchableExtMethod | PatchableExtMethod[]} method - the request extension
       * handler which is being instrumented
       * @param {Hapi.ServerRequestExtType} extPoint - the point in the Hapi request lifecycle
       * which this extension targets
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server route. Else, signifies that the route was added directly
       */
      _wrapExtMethods(method, extPoint, pluginName) {
        const instrumentation = this;
        if (method instanceof Array) {
          for (let i = 0; i < method.length; i++) {
            method[i] = instrumentation._wrapExtMethods(method[i], extPoint);
          }
          return method;
        } else if ((0, utils_1.isPatchableExtMethod)(method)) {
          if (method[internal_types_1.handlerPatched] === true)
            return method;
          method[internal_types_1.handlerPatched] = true;
          const newHandler = async function(...params) {
            if (api.trace.getSpan(api.context.active()) === void 0) {
              return await method.apply(this, params);
            }
            const metadata = (0, utils_1.getExtMetadata)(extPoint, pluginName);
            const span = instrumentation.tracer.startSpan(metadata.name, {
              attributes: metadata.attributes
            });
            try {
              return await api.context.with(api.trace.setSpan(api.context.active(), span), method, void 0, ...params);
            } catch (err) {
              span.recordException(err);
              span.setStatus({
                code: api.SpanStatusCode.ERROR,
                message: err.message
              });
              throw err;
            } finally {
              span.end();
            }
          };
          return newHandler;
        }
        return method;
      }
      /**
       * Patches each individual route handler method in order to create the
       * span and propagate context. It does not create spans when there is no parent span.
       * @param {PatchableServerRoute} route - the route handler which is being instrumented
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server route. Else, signifies that the route was added directly
       */
      _wrapRouteHandler(route, pluginName) {
        var _a;
        const instrumentation = this;
        if (route[internal_types_1.handlerPatched] === true)
          return route;
        route[internal_types_1.handlerPatched] = true;
        const wrapHandler = (oldHandler) => {
          return async function(...params) {
            if (api.trace.getSpan(api.context.active()) === void 0) {
              return await oldHandler.call(this, ...params);
            }
            const rpcMetadata = (0, core_1.getRPCMetadata)(api.context.active());
            if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
              rpcMetadata.route = route.path;
            }
            const metadata = (0, utils_1.getRouteMetadata)(route, pluginName);
            const span = instrumentation.tracer.startSpan(metadata.name, {
              attributes: metadata.attributes
            });
            try {
              return await api.context.with(api.trace.setSpan(api.context.active(), span), () => oldHandler.call(this, ...params));
            } catch (err) {
              span.recordException(err);
              span.setStatus({
                code: api.SpanStatusCode.ERROR,
                message: err.message
              });
              throw err;
            } finally {
              span.end();
            }
          };
        };
        if (typeof route.handler === "function") {
          route.handler = wrapHandler(route.handler);
        } else if (typeof route.options === "function") {
          const oldOptions = route.options;
          route.options = function(server) {
            const options = oldOptions(server);
            if (typeof options.handler === "function") {
              options.handler = wrapHandler(options.handler);
            }
            return options;
          };
        } else if (typeof ((_a = route.options) === null || _a === void 0 ? void 0 : _a.handler) === "function") {
          route.options.handler = wrapHandler(route.options.handler);
        }
        return route;
      }
    };
    exports2.HapiInstrumentation = HapiInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-hapi/build/src/index.js
var require_src23 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-hapi/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation14(), exports2);
    __exportStar(require_AttributeNames7(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/types.js
var require_types13 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KoaLayerType = void 0;
    var KoaLayerType;
    (function(KoaLayerType2) {
      KoaLayerType2["ROUTER"] = "router";
      KoaLayerType2["MIDDLEWARE"] = "middleware";
    })(KoaLayerType = exports2.KoaLayerType || (exports2.KoaLayerType = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/version.js
var require_version17 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.47.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-koa";
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/enums/AttributeNames.js
var require_AttributeNames8 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["KOA_TYPE"] = "koa.type";
      AttributeNames3["KOA_NAME"] = "koa.name";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/utils.js
var require_utils16 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isLayerIgnored = exports2.getMiddlewareMetadata = void 0;
    var types_1 = require_types13();
    var AttributeNames_1 = require_AttributeNames8();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var getMiddlewareMetadata = (context3, layer, isRouter, layerPath) => {
      var _a;
      if (isRouter) {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.KOA_NAME]: layerPath === null || layerPath === void 0 ? void 0 : layerPath.toString(),
            [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.ROUTER,
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: layerPath === null || layerPath === void 0 ? void 0 : layerPath.toString()
          },
          name: context3._matchedRouteName || `router - ${layerPath}`
        };
      } else {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.KOA_NAME]: (_a = layer.name) !== null && _a !== void 0 ? _a : "middleware",
            [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.MIDDLEWARE
          },
          name: `middleware - ${layer.name}`
        };
      }
    };
    exports2.getMiddlewareMetadata = getMiddlewareMetadata;
    var isLayerIgnored2 = (type, config2) => {
      var _a;
      return !!(Array.isArray(config2 === null || config2 === void 0 ? void 0 : config2.ignoreLayersType) && ((_a = config2 === null || config2 === void 0 ? void 0 : config2.ignoreLayersType) === null || _a === void 0 ? void 0 : _a.includes(type)));
    };
    exports2.isLayerIgnored = isLayerIgnored2;
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/internal-types.js
var require_internal_types6 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kLayerPatched = void 0;
    exports2.kLayerPatched = Symbol("koa-layer-patched");
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/instrumentation.js
var require_instrumentation15 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KoaInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var types_1 = require_types13();
    var version_1 = require_version17();
    var utils_1 = require_utils16();
    var core_1 = require_src();
    var internal_types_1 = require_internal_types6();
    var KoaInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition("koa", [">=2.0.0 <3"], (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if (moduleExports == null) {
            return moduleExports;
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
            this._unwrap(moduleExports.prototype, "use");
          }
          this._wrap(moduleExports.prototype, "use", this._getKoaUsePatch.bind(this));
          return module3;
        }, (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
            this._unwrap(moduleExports.prototype, "use");
          }
        });
      }
      /**
       * Patches the Koa.use function in order to instrument each original
       * middleware layer which is introduced
       * @param {KoaMiddleware} middleware - the original middleware function
       */
      _getKoaUsePatch(original) {
        const plugin = this;
        return function use(middlewareFunction) {
          let patchedFunction;
          if (middlewareFunction.router) {
            patchedFunction = plugin._patchRouterDispatch(middlewareFunction);
          } else {
            patchedFunction = plugin._patchLayer(middlewareFunction, false);
          }
          return original.apply(this, [patchedFunction]);
        };
      }
      /**
       * Patches the dispatch function used by @koa/router. This function
       * goes through each routed middleware and adds instrumentation via a call
       * to the @function _patchLayer function.
       * @param {KoaMiddleware} dispatchLayer - the original dispatch function which dispatches
       * routed middleware
       */
      _patchRouterDispatch(dispatchLayer) {
        var _a;
        api.diag.debug("Patching @koa/router dispatch");
        const router = dispatchLayer.router;
        const routesStack = (_a = router === null || router === void 0 ? void 0 : router.stack) !== null && _a !== void 0 ? _a : [];
        for (const pathLayer of routesStack) {
          const path = pathLayer.path;
          const pathStack = pathLayer.stack;
          for (let j = 0; j < pathStack.length; j++) {
            const routedMiddleware = pathStack[j];
            pathStack[j] = this._patchLayer(routedMiddleware, true, path);
          }
        }
        return dispatchLayer;
      }
      /**
       * Patches each individual @param middlewareLayer function in order to create the
       * span and propagate context. It does not create spans when there is no parent span.
       * @param {KoaMiddleware} middlewareLayer - the original middleware function.
       * @param {boolean} isRouter - tracks whether the original middleware function
       * was dispatched by the router originally
       * @param {string?} layerPath - if present, provides additional data from the
       * router about the routed path which the middleware is attached to
       */
      _patchLayer(middlewareLayer, isRouter, layerPath) {
        const layerType = isRouter ? types_1.KoaLayerType.ROUTER : types_1.KoaLayerType.MIDDLEWARE;
        if (middlewareLayer[internal_types_1.kLayerPatched] === true || (0, utils_1.isLayerIgnored)(layerType, this.getConfig()))
          return middlewareLayer;
        if (middlewareLayer.constructor.name === "GeneratorFunction" || middlewareLayer.constructor.name === "AsyncGeneratorFunction") {
          api.diag.debug("ignoring generator-based Koa middleware layer");
          return middlewareLayer;
        }
        middlewareLayer[internal_types_1.kLayerPatched] = true;
        api.diag.debug("patching Koa middleware layer");
        return async (context3, next) => {
          const parent = api.trace.getSpan(api.context.active());
          if (parent === void 0) {
            return middlewareLayer(context3, next);
          }
          const metadata = (0, utils_1.getMiddlewareMetadata)(context3, middlewareLayer, isRouter, layerPath);
          const span = this.tracer.startSpan(metadata.name, {
            attributes: metadata.attributes
          });
          const rpcMetadata = (0, core_1.getRPCMetadata)(api.context.active());
          if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP && context3._matchedRoute) {
            rpcMetadata.route = context3._matchedRoute.toString();
          }
          const { requestHook: requestHook2 } = this.getConfig();
          if (requestHook2) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => requestHook2(span, {
              context: context3,
              middlewareLayer,
              layerType
            }), (e) => {
              if (e) {
                api.diag.error("koa instrumentation: request hook failed", e);
              }
            }, true);
          }
          const newContext = api.trace.setSpan(api.context.active(), span);
          return api.context.with(newContext, async () => {
            try {
              return await middlewareLayer(context3, next);
            } catch (err) {
              span.recordException(err);
              throw err;
            } finally {
              span.end();
            }
          });
        };
      }
    };
    exports2.KoaInstrumentation = KoaInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-koa/build/src/index.js
var require_src24 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-koa/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation15(), exports2);
    __exportStar(require_types13(), exports2);
    __exportStar(require_AttributeNames8(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-connect/build/src/enums/AttributeNames.js
var require_AttributeNames9 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-connect/build/src/enums/AttributeNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectNames = exports2.ConnectTypes = exports2.AttributeNames = void 0;
    var AttributeNames2;
    (function(AttributeNames3) {
      AttributeNames3["CONNECT_TYPE"] = "connect.type";
      AttributeNames3["CONNECT_NAME"] = "connect.name";
    })(AttributeNames2 = exports2.AttributeNames || (exports2.AttributeNames = {}));
    var ConnectTypes;
    (function(ConnectTypes2) {
      ConnectTypes2["MIDDLEWARE"] = "middleware";
      ConnectTypes2["REQUEST_HANDLER"] = "request_handler";
    })(ConnectTypes = exports2.ConnectTypes || (exports2.ConnectTypes = {}));
    var ConnectNames;
    (function(ConnectNames2) {
      ConnectNames2["MIDDLEWARE"] = "middleware";
      ConnectNames2["REQUEST_HANDLER"] = "request handler";
    })(ConnectNames = exports2.ConnectNames || (exports2.ConnectNames = {}));
  }
});

// node_modules/@opentelemetry/instrumentation-connect/build/src/version.js
var require_version18 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-connect/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.43.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-connect";
  }
});

// node_modules/@opentelemetry/instrumentation-connect/build/src/internal-types.js
var require_internal_types7 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-connect/build/src/internal-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._LAYERS_STORE_PROPERTY = void 0;
    exports2._LAYERS_STORE_PROPERTY = Symbol("opentelemetry.instrumentation-connect.request-route-stack");
  }
});

// node_modules/@opentelemetry/instrumentation-connect/build/src/utils.js
var require_utils17 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-connect/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateRoute = exports2.replaceCurrentStackRoute = exports2.addNewStackLayer = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var internal_types_1 = require_internal_types7();
    var addNewStackLayer = (request) => {
      if (Array.isArray(request[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
        Object.defineProperty(request, internal_types_1._LAYERS_STORE_PROPERTY, {
          enumerable: false,
          value: []
        });
      }
      request[internal_types_1._LAYERS_STORE_PROPERTY].push("/");
      const stackLength = request[internal_types_1._LAYERS_STORE_PROPERTY].length;
      return () => {
        if (stackLength === request[internal_types_1._LAYERS_STORE_PROPERTY].length) {
          request[internal_types_1._LAYERS_STORE_PROPERTY].pop();
        } else {
          api_1.diag.warn("Connect: Trying to pop the stack multiple time");
        }
      };
    };
    exports2.addNewStackLayer = addNewStackLayer;
    var replaceCurrentStackRoute = (request, newRoute) => {
      if (newRoute) {
        request[internal_types_1._LAYERS_STORE_PROPERTY].splice(-1, 1, newRoute);
      }
    };
    exports2.replaceCurrentStackRoute = replaceCurrentStackRoute;
    var generateRoute = (request) => {
      return request[internal_types_1._LAYERS_STORE_PROPERTY].reduce((acc, sub) => acc.replace(/\/+$/, "") + sub);
    };
    exports2.generateRoute = generateRoute;
  }
});

// node_modules/@opentelemetry/instrumentation-connect/build/src/instrumentation.js
var require_instrumentation16 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-connect/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectInstrumentation = exports2.ANONYMOUS_NAME = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var AttributeNames_1 = require_AttributeNames9();
    var version_1 = require_version18();
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var utils_1 = require_utils17();
    exports2.ANONYMOUS_NAME = "anonymous";
    var ConnectInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("connect", [">=3.0.0 <4"], (moduleExports) => {
            return this._patchConstructor(moduleExports);
          })
        ];
      }
      _patchApp(patchedApp) {
        if (!(0, instrumentation_1.isWrapped)(patchedApp.use)) {
          this._wrap(patchedApp, "use", this._patchUse.bind(this));
        }
        if (!(0, instrumentation_1.isWrapped)(patchedApp.handle)) {
          this._wrap(patchedApp, "handle", this._patchHandle.bind(this));
        }
      }
      _patchConstructor(original) {
        const instrumentation = this;
        return function(...args) {
          const app = original.apply(this, args);
          instrumentation._patchApp(app);
          return app;
        };
      }
      _patchNext(next, finishSpan) {
        return function nextFunction(err) {
          const result = next.apply(this, [err]);
          finishSpan();
          return result;
        };
      }
      _startSpan(routeName, middleWare) {
        let connectType;
        let connectName;
        let connectTypeName;
        if (routeName) {
          connectType = AttributeNames_1.ConnectTypes.REQUEST_HANDLER;
          connectTypeName = AttributeNames_1.ConnectNames.REQUEST_HANDLER;
          connectName = routeName;
        } else {
          connectType = AttributeNames_1.ConnectTypes.MIDDLEWARE;
          connectTypeName = AttributeNames_1.ConnectNames.MIDDLEWARE;
          connectName = middleWare.name || exports2.ANONYMOUS_NAME;
        }
        const spanName = `${connectTypeName} - ${connectName}`;
        const options = {
          attributes: {
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: routeName.length > 0 ? routeName : "/",
            [AttributeNames_1.AttributeNames.CONNECT_TYPE]: connectType,
            [AttributeNames_1.AttributeNames.CONNECT_NAME]: connectName
          }
        };
        return this.tracer.startSpan(spanName, options);
      }
      _patchMiddleware(routeName, middleWare) {
        const instrumentation = this;
        const isErrorMiddleware = middleWare.length === 4;
        function patchedMiddleware() {
          if (!instrumentation.isEnabled()) {
            return middleWare.apply(this, arguments);
          }
          const [reqArgIdx, resArgIdx, nextArgIdx] = isErrorMiddleware ? [1, 2, 3] : [0, 1, 2];
          const req = arguments[reqArgIdx];
          const res = arguments[resArgIdx];
          const next = arguments[nextArgIdx];
          (0, utils_1.replaceCurrentStackRoute)(req, routeName);
          const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
          if (routeName && (rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
            rpcMetadata.route = (0, utils_1.generateRoute)(req);
          }
          let spanName = "";
          if (routeName) {
            spanName = `request handler - ${routeName}`;
          } else {
            spanName = `middleware - ${middleWare.name || exports2.ANONYMOUS_NAME}`;
          }
          const span = instrumentation._startSpan(routeName, middleWare);
          instrumentation._diag.debug("start span", spanName);
          let spanFinished = false;
          function finishSpan() {
            if (!spanFinished) {
              spanFinished = true;
              instrumentation._diag.debug(`finishing span ${span.name}`);
              span.end();
            } else {
              instrumentation._diag.debug(`span ${span.name} - already finished`);
            }
            res.removeListener("close", finishSpan);
          }
          res.addListener("close", finishSpan);
          arguments[nextArgIdx] = instrumentation._patchNext(next, finishSpan);
          return middleWare.apply(this, arguments);
        }
        Object.defineProperty(patchedMiddleware, "length", {
          value: middleWare.length,
          writable: false,
          configurable: true
        });
        return patchedMiddleware;
      }
      _patchUse(original) {
        const instrumentation = this;
        return function(...args) {
          const middleWare = args[args.length - 1];
          const routeName = args[args.length - 2] || "";
          args[args.length - 1] = instrumentation._patchMiddleware(routeName, middleWare);
          return original.apply(this, args);
        };
      }
      _patchHandle(original) {
        const instrumentation = this;
        return function() {
          const [reqIdx, outIdx] = [0, 2];
          const req = arguments[reqIdx];
          const out = arguments[outIdx];
          const completeStack = (0, utils_1.addNewStackLayer)(req);
          if (typeof out === "function") {
            arguments[outIdx] = instrumentation._patchOut(out, completeStack);
          }
          return original.apply(this, arguments);
        };
      }
      _patchOut(out, completeStack) {
        return function nextFunction(...args) {
          completeStack();
          return Reflect.apply(out, this, args);
        };
      }
    };
    exports2.ConnectInstrumentation = ConnectInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-connect/build/src/index.js
var require_src25 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-connect/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_AttributeNames9(), exports2);
    __exportStar(require_instrumentation16(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-tedious/build/src/utils.js
var require_utils18 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-tedious/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.once = exports2.getSpanName = void 0;
    function getSpanName(operation, db, sql, bulkLoadTable) {
      if (operation === "execBulkLoad" && bulkLoadTable && db) {
        return `${operation} ${bulkLoadTable} ${db}`;
      }
      if (operation === "callProcedure") {
        if (db) {
          return `${operation} ${sql} ${db}`;
        }
        return `${operation} ${sql}`;
      }
      if (db) {
        return `${operation} ${db}`;
      }
      return `${operation}`;
    }
    exports2.getSpanName = getSpanName;
    var once = (fn) => {
      let called = false;
      return (...args) => {
        if (called)
          return;
        called = true;
        return fn(...args);
      };
    };
    exports2.once = once;
  }
});

// node_modules/@opentelemetry/instrumentation-tedious/build/src/version.js
var require_version19 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-tedious/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.18.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-tedious";
  }
});

// node_modules/@opentelemetry/instrumentation-tedious/build/src/instrumentation.js
var require_instrumentation17 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-tedious/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TediousInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var events_1 = require("events");
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var utils_1 = require_utils18();
    var version_1 = require_version19();
    var CURRENT_DATABASE = Symbol("opentelemetry.instrumentation-tedious.current-database");
    var PATCHED_METHODS = [
      "callProcedure",
      "execSql",
      "execSqlBatch",
      "execBulkLoad",
      "prepare",
      "execute"
    ];
    function setDatabase(databaseName) {
      Object.defineProperty(this, CURRENT_DATABASE, {
        value: databaseName,
        writable: true
      });
    }
    var TediousInstrumentation2 = class _TediousInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition(_TediousInstrumentation.COMPONENT, [">=1.11.0 <20"], (moduleExports) => {
            const ConnectionPrototype = moduleExports.Connection.prototype;
            for (const method of PATCHED_METHODS) {
              if ((0, instrumentation_1.isWrapped)(ConnectionPrototype[method])) {
                this._unwrap(ConnectionPrototype, method);
              }
              this._wrap(ConnectionPrototype, method, this._patchQuery(method));
            }
            if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.connect)) {
              this._unwrap(ConnectionPrototype, "connect");
            }
            this._wrap(ConnectionPrototype, "connect", this._patchConnect);
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === void 0)
              return;
            const ConnectionPrototype = moduleExports.Connection.prototype;
            for (const method of PATCHED_METHODS) {
              this._unwrap(ConnectionPrototype, method);
            }
            this._unwrap(ConnectionPrototype, "connect");
          })
        ];
      }
      _patchConnect(original) {
        return function patchedConnect() {
          var _a, _b;
          setDatabase.call(this, (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.database);
          this.removeListener("databaseChange", setDatabase);
          this.on("databaseChange", setDatabase);
          this.once("end", () => {
            this.removeListener("databaseChange", setDatabase);
          });
          return original.apply(this, arguments);
        };
      }
      _patchQuery(operation) {
        return (originalMethod) => {
          const thisPlugin = this;
          function patchedMethod(request) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (!(request instanceof events_1.EventEmitter)) {
              thisPlugin._diag.warn(`Unexpected invocation of patched ${operation} method. Span not recorded`);
              return originalMethod.apply(this, arguments);
            }
            let procCount = 0;
            let statementCount = 0;
            const incrementStatementCount = () => statementCount++;
            const incrementProcCount = () => procCount++;
            const databaseName = this[CURRENT_DATABASE];
            const sql = ((request2) => {
              var _a2, _b2;
              if (request2.sqlTextOrProcedure === "sp_prepare" && ((_b2 = (_a2 = request2.parametersByName) === null || _a2 === void 0 ? void 0 : _a2.stmt) === null || _b2 === void 0 ? void 0 : _b2.value)) {
                return request2.parametersByName.stmt.value;
              }
              return request2.sqlTextOrProcedure;
            })(request);
            const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(operation, databaseName, sql, request.table), {
              kind: api.SpanKind.CLIENT,
              attributes: {
                [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MSSQL,
                [semantic_conventions_1.SEMATTRS_DB_NAME]: databaseName,
                [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.port,
                [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: (_c = this.config) === null || _c === void 0 ? void 0 : _c.server,
                // >=4 uses `authentication` object, older versions just userName and password pair
                [semantic_conventions_1.SEMATTRS_DB_USER]: (_e = (_d = this.config) === null || _d === void 0 ? void 0 : _d.userName) !== null && _e !== void 0 ? _e : (_h = (_g = (_f = this.config) === null || _f === void 0 ? void 0 : _f.authentication) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.userName,
                [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: sql,
                [semantic_conventions_1.SEMATTRS_DB_SQL_TABLE]: request.table
              }
            });
            const endSpan = (0, utils_1.once)((err) => {
              request.removeListener("done", incrementStatementCount);
              request.removeListener("doneInProc", incrementStatementCount);
              request.removeListener("doneProc", incrementProcCount);
              request.removeListener("error", endSpan);
              this.removeListener("end", endSpan);
              span.setAttribute("tedious.procedure_count", procCount);
              span.setAttribute("tedious.statement_count", statementCount);
              if (err) {
                span.setStatus({
                  code: api.SpanStatusCode.ERROR,
                  message: err.message
                });
              }
              span.end();
            });
            request.on("done", incrementStatementCount);
            request.on("doneInProc", incrementStatementCount);
            request.on("doneProc", incrementProcCount);
            request.once("error", endSpan);
            this.on("end", endSpan);
            if (typeof request.callback === "function") {
              thisPlugin._wrap(request, "callback", thisPlugin._patchCallbackQuery(endSpan));
            } else {
              thisPlugin._diag.error("Expected request.callback to be a function");
            }
            return api.context.with(api.trace.setSpan(api.context.active(), span), originalMethod, this, ...arguments);
          }
          Object.defineProperty(patchedMethod, "length", {
            value: originalMethod.length,
            writable: false
          });
          return patchedMethod;
        };
      }
      _patchCallbackQuery(endSpan) {
        return (originalCallback) => {
          return function(err, rowCount, rows) {
            endSpan(err);
            return originalCallback.apply(this, arguments);
          };
        };
      }
    };
    exports2.TediousInstrumentation = TediousInstrumentation2;
    TediousInstrumentation2.COMPONENT = "tedious";
  }
});

// node_modules/@opentelemetry/instrumentation-tedious/build/src/types.js
var require_types14 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-tedious/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/instrumentation-tedious/build/src/index.js
var require_src26 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-tedious/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation17(), exports2);
    __exportStar(require_types14(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-generic-pool/build/src/version.js
var require_version20 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-generic-pool/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.43.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-generic-pool";
  }
});

// node_modules/@opentelemetry/instrumentation-generic-pool/build/src/instrumentation.js
var require_instrumentation18 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-generic-pool/build/src/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GenericPoolInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = require_src4();
    var version_1 = require_version20();
    var MODULE_NAME = "generic-pool";
    var GenericPoolInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config2);
        this._isDisabled = false;
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=3.0.0 <4"], (moduleExports) => {
            const Pool = moduleExports.Pool;
            if ((0, instrumentation_1.isWrapped)(Pool.prototype.acquire)) {
              this._unwrap(Pool.prototype, "acquire");
            }
            this._wrap(Pool.prototype, "acquire", this._acquirePatcher.bind(this));
            return moduleExports;
          }, (moduleExports) => {
            const Pool = moduleExports.Pool;
            this._unwrap(Pool.prototype, "acquire");
            return moduleExports;
          }),
          new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=2.4.0 <3"], (moduleExports) => {
            const Pool = moduleExports.Pool;
            if ((0, instrumentation_1.isWrapped)(Pool.prototype.acquire)) {
              this._unwrap(Pool.prototype, "acquire");
            }
            this._wrap(Pool.prototype, "acquire", this._acquireWithCallbacksPatcher.bind(this));
            return moduleExports;
          }, (moduleExports) => {
            const Pool = moduleExports.Pool;
            this._unwrap(Pool.prototype, "acquire");
            return moduleExports;
          }),
          new instrumentation_1.InstrumentationNodeModuleDefinition(MODULE_NAME, [">=2.0.0 <2.4"], (moduleExports) => {
            this._isDisabled = false;
            if ((0, instrumentation_1.isWrapped)(moduleExports.Pool)) {
              this._unwrap(moduleExports, "Pool");
            }
            this._wrap(moduleExports, "Pool", this._poolWrapper.bind(this));
            return moduleExports;
          }, (moduleExports) => {
            this._isDisabled = true;
            return moduleExports;
          })
        ];
      }
      _acquirePatcher(original) {
        const instrumentation = this;
        return function wrapped_acquire(...args) {
          const parent = api.context.active();
          const span = instrumentation.tracer.startSpan("generic-pool.acquire", {}, parent);
          return api.context.with(api.trace.setSpan(parent, span), () => {
            return original.call(this, ...args).then((value) => {
              span.end();
              return value;
            }, (err) => {
              span.recordException(err);
              span.end();
              throw err;
            });
          });
        };
      }
      _poolWrapper(original) {
        const instrumentation = this;
        return function wrapped_pool() {
          const pool = original.apply(this, arguments);
          instrumentation._wrap(pool, "acquire", instrumentation._acquireWithCallbacksPatcher.bind(instrumentation));
          return pool;
        };
      }
      _acquireWithCallbacksPatcher(original) {
        const instrumentation = this;
        return function wrapped_acquire(cb, priority) {
          if (instrumentation._isDisabled) {
            return original.call(this, cb, priority);
          }
          const parent = api.context.active();
          const span = instrumentation.tracer.startSpan("generic-pool.acquire", {}, parent);
          return api.context.with(api.trace.setSpan(parent, span), () => {
            original.call(this, (err, client) => {
              span.end();
              if (cb) {
                return cb(err, client);
              }
            }, priority);
          });
        };
      }
    };
    exports2.GenericPoolInstrumentation = GenericPoolInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-generic-pool/build/src/index.js
var require_src27 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-generic-pool/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_instrumentation18(), exports2);
  }
});

// node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js
var require_types15 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_CONFIG = exports2.EndOperation = void 0;
    var EndOperation;
    (function(EndOperation2) {
      EndOperation2["AutoAck"] = "auto ack";
      EndOperation2["Ack"] = "ack";
      EndOperation2["AckAll"] = "ackAll";
      EndOperation2["Reject"] = "reject";
      EndOperation2["Nack"] = "nack";
      EndOperation2["NackAll"] = "nackAll";
      EndOperation2["ChannelClosed"] = "channel closed";
      EndOperation2["ChannelError"] = "channel error";
      EndOperation2["InstrumentationTimeout"] = "instrumentation timeout";
    })(EndOperation = exports2.EndOperation || (exports2.EndOperation = {}));
    exports2.DEFAULT_CONFIG = {
      consumeTimeoutMs: 1e3 * 60,
      useLinksForConsume: false
    };
  }
});

// node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js
var require_utils19 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isConfirmChannelTracing = exports2.unmarkConfirmChannelTracing = exports2.markConfirmChannelTracing = exports2.getConnectionAttributesFromUrl = exports2.getConnectionAttributesFromServer = exports2.normalizeExchange = exports2.CONNECTION_ATTRIBUTES = exports2.CHANNEL_CONSUME_TIMEOUT_TIMER = exports2.CHANNEL_SPANS_NOT_ENDED = exports2.MESSAGE_STORED_SPAN = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    exports2.MESSAGE_STORED_SPAN = Symbol("opentelemetry.amqplib.message.stored-span");
    exports2.CHANNEL_SPANS_NOT_ENDED = Symbol("opentelemetry.amqplib.channel.spans-not-ended");
    exports2.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol("opentelemetry.amqplib.channel.consumer-timeout-timer");
    exports2.CONNECTION_ATTRIBUTES = Symbol("opentelemetry.amqplib.connection.attributes");
    var IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)("opentelemetry.amqplib.channel.is-confirm-channel");
    var normalizeExchange = (exchangeName) => exchangeName !== "" ? exchangeName : "<default>";
    exports2.normalizeExchange = normalizeExchange;
    var censorPassword = (url2) => {
      return url2.replace(/:[^:@/]*@/, ":***@");
    };
    var getPort = (portFromUrl, resolvedProtocol) => {
      return portFromUrl || (resolvedProtocol === "AMQP" ? 5672 : 5671);
    };
    var getProtocol = (protocolFromUrl) => {
      const resolvedProtocol = protocolFromUrl || "amqp";
      const noEndingColon = resolvedProtocol.endsWith(":") ? resolvedProtocol.substring(0, resolvedProtocol.length - 1) : resolvedProtocol;
      return noEndingColon.toUpperCase();
    };
    var getHostname = (hostnameFromUrl) => {
      return hostnameFromUrl || "localhost";
    };
    var extractConnectionAttributeOrLog = (url2, attributeKey, attributeValue, nameForLog) => {
      if (attributeValue) {
        return { [attributeKey]: attributeValue };
      } else {
        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {
          url: url2
        });
        return {};
      }
    };
    var getConnectionAttributesFromServer = (conn) => {
      var _a, _b;
      const product = (_b = (_a = conn.serverProperties.product) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a);
      if (product) {
        return {
          [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product
        };
      } else {
        return {};
      }
    };
    exports2.getConnectionAttributesFromServer = getConnectionAttributesFromServer;
    var getConnectionAttributesFromUrl = (url2) => {
      const attributes = {
        [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: "0.9.1"
        // this is the only protocol supported by the instrumented library
      };
      url2 = url2 || "amqp://localhost";
      if (typeof url2 === "object") {
        const connectOptions = url2;
        const protocol = getProtocol(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.protocol);
        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url2, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, "protocol")));
        const hostname2 = getHostname(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.hostname);
        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url2, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname2, "hostname")));
        const port = getPort(connectOptions.port, protocol);
        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url2, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, "port")));
      } else {
        const censoredUrl = censorPassword(url2);
        attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;
        try {
          const urlParts = new URL(censoredUrl);
          const protocol = getProtocol(urlParts.protocol);
          Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, "protocol")));
          const hostname2 = getHostname(urlParts.hostname);
          Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname2, "hostname")));
          const port = getPort(urlParts.port ? parseInt(urlParts.port) : void 0, protocol);
          Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, "port")));
        } catch (err) {
          api_1.diag.error("amqplib instrumentation: error while extracting connection details from connection url", {
            censoredUrl,
            err
          });
        }
      }
      return attributes;
    };
    exports2.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;
    var markConfirmChannelTracing = (context3) => {
      return context3.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);
    };
    exports2.markConfirmChannelTracing = markConfirmChannelTracing;
    var unmarkConfirmChannelTracing = (context3) => {
      return context3.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);
    };
    exports2.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;
    var isConfirmChannelTracing = (context3) => {
      return context3.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;
    };
    exports2.isConfirmChannelTracing = isConfirmChannelTracing;
  }
});

// node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js
var require_version21 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PACKAGE_NAME = exports2.PACKAGE_VERSION = void 0;
    exports2.PACKAGE_VERSION = "0.46.1";
    exports2.PACKAGE_NAME = "@opentelemetry/instrumentation-amqplib";
  }
});

// node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js
var require_amqplib = __commonJS({
  "node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AmqplibInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var instrumentation_1 = require_src4();
    var semantic_conventions_1 = (init_esm4(), __toCommonJS(esm_exports4));
    var types_1 = require_types15();
    var utils_1 = require_utils19();
    var version_1 = require_version21();
    var supportedVersions = [">=0.5.5 <1"];
    var AmqplibInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config2 = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config2));
      }
      setConfig(config2 = {}) {
        super.setConfig(Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config2));
      }
      init() {
        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/channel_model.js", supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));
        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/callback_model.js", supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));
        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile("amqplib/lib/connect.js", supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition("amqplib", supportedVersions, void 0, void 0, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);
        return module3;
      }
      patchConnect(moduleExports) {
        moduleExports = this.unpatchConnect(moduleExports);
        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {
          this._wrap(moduleExports, "connect", this.getConnectPatch.bind(this));
        }
        return moduleExports;
      }
      unpatchConnect(moduleExports) {
        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
          this._unwrap(moduleExports, "connect");
        }
        return moduleExports;
      }
      patchChannelModel(moduleExports, moduleVersion) {
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {
          this._wrap(moduleExports.Channel.prototype, "publish", this.getPublishPatch.bind(this, moduleVersion));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {
          this._wrap(moduleExports.Channel.prototype, "consume", this.getConsumePatch.bind(this, moduleVersion));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {
          this._wrap(moduleExports.Channel.prototype, "ack", this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {
          this._wrap(moduleExports.Channel.prototype, "nack", this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {
          this._wrap(moduleExports.Channel.prototype, "reject", this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {
          this._wrap(moduleExports.Channel.prototype, "ackAll", this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {
          this._wrap(moduleExports.Channel.prototype, "nackAll", this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {
          this._wrap(moduleExports.Channel.prototype, "emit", this.getChannelEmitPatch.bind(this));
        }
        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {
          this._wrap(moduleExports.ConfirmChannel.prototype, "publish", this.getConfirmedPublishPatch.bind(this, moduleVersion));
        }
        return moduleExports;
      }
      unpatchChannelModel(moduleExports) {
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {
          this._unwrap(moduleExports.Channel.prototype, "publish");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {
          this._unwrap(moduleExports.Channel.prototype, "consume");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {
          this._unwrap(moduleExports.Channel.prototype, "ack");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {
          this._unwrap(moduleExports.Channel.prototype, "nack");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {
          this._unwrap(moduleExports.Channel.prototype, "reject");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {
          this._unwrap(moduleExports.Channel.prototype, "ackAll");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {
          this._unwrap(moduleExports.Channel.prototype, "nackAll");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {
          this._unwrap(moduleExports.Channel.prototype, "emit");
        }
        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {
          this._unwrap(moduleExports.ConfirmChannel.prototype, "publish");
        }
        return moduleExports;
      }
      getConnectPatch(original) {
        return function patchedConnect(url2, socketOptions, openCallback) {
          return original.call(this, url2, socketOptions, function(err, conn) {
            if (err == null) {
              const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url2);
              const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);
              conn[utils_1.CONNECTION_ATTRIBUTES] = Object.assign(Object.assign({}, urlAttributes), serverAttributes);
            }
            openCallback.apply(this, arguments);
          });
        };
      }
      getChannelEmitPatch(original) {
        const self = this;
        return function emit(eventName) {
          if (eventName === "close") {
            self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, void 0);
            const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];
            if (activeTimer) {
              clearInterval(activeTimer);
            }
            this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = void 0;
          } else if (eventName === "error") {
            self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, void 0);
          }
          return original.apply(this, arguments);
        };
      }
      getAckAllPatch(isRejected, endOperation, original) {
        const self = this;
        return function ackAll(requeueOrEmpty) {
          self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);
          return original.apply(this, arguments);
        };
      }
      getAckPatch(isRejected, endOperation, original) {
        const self = this;
        return function ack(message, allUpToOrRequeue, requeue) {
          var _a;
          const channel3 = this;
          const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;
          const spansNotEnded = (_a = channel3[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null && _a !== void 0 ? _a : [];
          const msgIndex = spansNotEnded.findIndex((msgDetails) => msgDetails.msg === message);
          if (msgIndex < 0) {
            self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);
          } else if (endOperation !== types_1.EndOperation.Reject && allUpToOrRequeue) {
            for (let i = 0; i <= msgIndex; i++) {
              self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);
            }
            spansNotEnded.splice(0, msgIndex + 1);
          } else {
            self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);
            spansNotEnded.splice(msgIndex, 1);
          }
          return original.apply(this, arguments);
        };
      }
      getConsumePatch(moduleVersion, original) {
        const self = this;
        return function consume(queue, onMessage, options) {
          const channel3 = this;
          if (!Object.prototype.hasOwnProperty.call(channel3, utils_1.CHANNEL_SPANS_NOT_ENDED)) {
            const { consumeTimeoutMs } = self.getConfig();
            if (consumeTimeoutMs) {
              const timer = setInterval(() => {
                self.checkConsumeTimeoutOnChannel(channel3);
              }, consumeTimeoutMs);
              timer.unref();
              channel3[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;
            }
            channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];
          }
          const patchedOnMessage = function(msg) {
            var _a, _b, _c, _d, _e;
            if (!msg) {
              return onMessage.call(this, msg);
            }
            const headers = (_a = msg.properties.headers) !== null && _a !== void 0 ? _a : {};
            let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
            const exchange = (_b = msg.fields) === null || _b === void 0 ? void 0 : _b.exchange;
            let links;
            if (self._config.useLinksForConsume) {
              const parentSpanContext = parentContext ? (_c = api_1.trace.getSpan(parentContext)) === null || _c === void 0 ? void 0 : _c.spanContext() : void 0;
              parentContext = void 0;
              if (parentSpanContext) {
                links = [
                  {
                    context: parentSpanContext
                  }
                ];
              }
            }
            const span = self.tracer.startSpan(`${queue} process`, {
              kind: api_1.SpanKind.CONSUMER,
              attributes: Object.assign(Object.assign({}, (_d = channel3 === null || channel3 === void 0 ? void 0 : channel3.connection) === null || _d === void 0 ? void 0 : _d[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: (_e = msg.fields) === null || _e === void 0 ? void 0 : _e.routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.correlationId }),
              links
            }, parentContext);
            const { consumeHook } = self.getConfig();
            if (consumeHook) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeHook(span, { moduleVersion, msg }), (e) => {
                if (e) {
                  api_1.diag.error("amqplib instrumentation: consumerHook error", e);
                }
              }, true);
            }
            if (!(options === null || options === void 0 ? void 0 : options.noAck)) {
              channel3[utils_1.CHANNEL_SPANS_NOT_ENDED].push({
                msg,
                timeOfConsume: (0, core_1.hrTime)()
              });
              msg[utils_1.MESSAGE_STORED_SPAN] = span;
            }
            const setContext2 = parentContext ? parentContext : api_1.ROOT_CONTEXT;
            api_1.context.with(api_1.trace.setSpan(setContext2, span), () => {
              onMessage.call(this, msg);
            });
            if (options === null || options === void 0 ? void 0 : options.noAck) {
              self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);
              span.end();
            }
          };
          arguments[1] = patchedOnMessage;
          return original.apply(this, arguments);
        };
      }
      getConfirmedPublishPatch(moduleVersion, original) {
        const self = this;
        return function confirmedPublish(exchange, routingKey, content, options, callback) {
          const channel3 = this;
          const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel3, options);
          const { publishHook } = self.getConfig();
          if (publishHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {
              moduleVersion,
              exchange,
              routingKey,
              content,
              options: modifiedOptions,
              isConfirmChannel: true
            }), (e) => {
              if (e) {
                api_1.diag.error("amqplib instrumentation: publishHook error", e);
              }
            }, true);
          }
          const patchedOnConfirm = function(err, ok) {
            try {
              callback === null || callback === void 0 ? void 0 : callback.call(this, err, ok);
            } finally {
              const { publishConfirmHook } = self.getConfig();
              if (publishConfirmHook) {
                (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishConfirmHook(span, {
                  moduleVersion,
                  exchange,
                  routingKey,
                  content,
                  options,
                  isConfirmChannel: true,
                  confirmError: err
                }), (e) => {
                  if (e) {
                    api_1.diag.error("amqplib instrumentation: publishConfirmHook error", e);
                  }
                }, true);
              }
              if (err) {
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message: "message confirmation has been nack'ed"
                });
              }
              span.end();
            }
          };
          const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());
          const argumentsCopy = [...arguments];
          argumentsCopy[3] = modifiedOptions;
          argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);
          return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));
        };
      }
      getPublishPatch(moduleVersion, original) {
        const self = this;
        return function publish(exchange, routingKey, content, options) {
          if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {
            return original.apply(this, arguments);
          } else {
            const channel3 = this;
            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel3, options);
            const { publishHook } = self.getConfig();
            if (publishHook) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {
                moduleVersion,
                exchange,
                routingKey,
                content,
                options: modifiedOptions,
                isConfirmChannel: false
              }), (e) => {
                if (e) {
                  api_1.diag.error("amqplib instrumentation: publishHook error", e);
                }
              }, true);
            }
            const argumentsCopy = [...arguments];
            argumentsCopy[3] = modifiedOptions;
            const originalRes = original.apply(this, argumentsCopy);
            span.end();
            return originalRes;
          }
        };
      }
      createPublishSpan(self, exchange, routingKey, channel3, options) {
        var _a;
        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);
        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {
          kind: api_1.SpanKind.PRODUCER,
          attributes: Object.assign(Object.assign({}, channel3.connection[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options === null || options === void 0 ? void 0 : options.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options === null || options === void 0 ? void 0 : options.correlationId })
        });
        const modifiedOptions = options !== null && options !== void 0 ? options : {};
        modifiedOptions.headers = (_a = modifiedOptions.headers) !== null && _a !== void 0 ? _a : {};
        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);
        return { span, modifiedOptions };
      }
      endConsumerSpan(message, isRejected, operation, requeue) {
        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];
        if (!storedSpan)
          return;
        if (isRejected !== false) {
          storedSpan.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: operation !== types_1.EndOperation.ChannelClosed && operation !== types_1.EndOperation.ChannelError ? `${operation} called on message${requeue === true ? " with requeue" : requeue === false ? " without requeue" : ""}` : operation
          });
        }
        this.callConsumeEndHook(storedSpan, message, isRejected, operation);
        storedSpan.end();
        message[utils_1.MESSAGE_STORED_SPAN] = void 0;
      }
      endAllSpansOnChannel(channel3, isRejected, operation, requeue) {
        var _a;
        const spansNotEnded = (_a = channel3[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null && _a !== void 0 ? _a : [];
        spansNotEnded.forEach((msgDetails) => {
          this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);
        });
        channel3[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];
      }
      callConsumeEndHook(span, msg, rejected, endOperation) {
        const { consumeEndHook } = this.getConfig();
        if (!consumeEndHook)
          return;
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeEndHook(span, { msg, rejected, endOperation }), (e) => {
          if (e) {
            api_1.diag.error("amqplib instrumentation: consumerEndHook error", e);
          }
        }, true);
      }
      checkConsumeTimeoutOnChannel(channel3) {
        var _a;
        const currentTime = (0, core_1.hrTime)();
        const spansNotEnded = (_a = channel3[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null && _a !== void 0 ? _a : [];
        let i;
        const { consumeTimeoutMs } = this.getConfig();
        for (i = 0; i < spansNotEnded.length; i++) {
          const currMessage = spansNotEnded[i];
          const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);
          if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) < consumeTimeoutMs) {
            break;
          }
          this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);
        }
        spansNotEnded.splice(0, i);
      }
    };
    exports2.AmqplibInstrumentation = AmqplibInstrumentation2;
  }
});

// node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js
var require_src28 = __commonJS({
  "node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_amqplib(), exports2);
    __exportStar(require_types15(), exports2);
  }
});

// node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js
var require_AbstractAsyncHooksContextManager = __commonJS({
  "node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractAsyncHooksContextManager = void 0;
    var events_1 = require("events");
    var ADD_LISTENER_METHODS = [
      "addListener",
      "on",
      "once",
      "prependListener",
      "prependOnceListener"
    ];
    var AbstractAsyncHooksContextManager = class {
      constructor() {
        this._kOtListeners = Symbol("OtListeners");
        this._wrapped = false;
      }
      /**
       * Binds a the certain context or the active one to the target function and then returns the target
       * @param context A context (span) to be bind to target
       * @param target a function or event emitter. When target or one of its callbacks is called,
       *  the provided context will be used as the active context for the duration of the call.
       */
      bind(context3, target) {
        if (target instanceof events_1.EventEmitter) {
          return this._bindEventEmitter(context3, target);
        }
        if (typeof target === "function") {
          return this._bindFunction(context3, target);
        }
        return target;
      }
      _bindFunction(context3, target) {
        const manager = this;
        const contextWrapper = function(...args) {
          return manager.with(context3, () => target.apply(this, args));
        };
        Object.defineProperty(contextWrapper, "length", {
          enumerable: false,
          configurable: true,
          writable: false,
          value: target.length
        });
        return contextWrapper;
      }
      /**
       * By default, EventEmitter call their callback with their context, which we do
       * not want, instead we will bind a specific context to all callbacks that
       * go through it.
       * @param context the context we want to bind
       * @param ee EventEmitter an instance of EventEmitter to patch
       */
      _bindEventEmitter(context3, ee) {
        const map = this._getPatchMap(ee);
        if (map !== void 0)
          return ee;
        this._createPatchMap(ee);
        ADD_LISTENER_METHODS.forEach((methodName) => {
          if (ee[methodName] === void 0)
            return;
          ee[methodName] = this._patchAddListener(ee, ee[methodName], context3);
        });
        if (typeof ee.removeListener === "function") {
          ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);
        }
        if (typeof ee.off === "function") {
          ee.off = this._patchRemoveListener(ee, ee.off);
        }
        if (typeof ee.removeAllListeners === "function") {
          ee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners);
        }
        return ee;
      }
      /**
       * Patch methods that remove a given listener so that we match the "patched"
       * version of that listener (the one that propagate context).
       * @param ee EventEmitter instance
       * @param original reference to the patched method
       */
      _patchRemoveListener(ee, original) {
        const contextManager = this;
        return function(event, listener) {
          var _a;
          const events = (_a = contextManager._getPatchMap(ee)) === null || _a === void 0 ? void 0 : _a[event];
          if (events === void 0) {
            return original.call(this, event, listener);
          }
          const patchedListener = events.get(listener);
          return original.call(this, event, patchedListener || listener);
        };
      }
      /**
       * Patch methods that remove all listeners so we remove our
       * internal references for a given event.
       * @param ee EventEmitter instance
       * @param original reference to the patched method
       */
      _patchRemoveAllListeners(ee, original) {
        const contextManager = this;
        return function(event) {
          const map = contextManager._getPatchMap(ee);
          if (map !== void 0) {
            if (arguments.length === 0) {
              contextManager._createPatchMap(ee);
            } else if (map[event] !== void 0) {
              delete map[event];
            }
          }
          return original.apply(this, arguments);
        };
      }
      /**
       * Patch methods on an event emitter instance that can add listeners so we
       * can force them to propagate a given context.
       * @param ee EventEmitter instance
       * @param original reference to the patched method
       * @param [context] context to propagate when calling listeners
       */
      _patchAddListener(ee, original, context3) {
        const contextManager = this;
        return function(event, listener) {
          if (contextManager._wrapped) {
            return original.call(this, event, listener);
          }
          let map = contextManager._getPatchMap(ee);
          if (map === void 0) {
            map = contextManager._createPatchMap(ee);
          }
          let listeners = map[event];
          if (listeners === void 0) {
            listeners = /* @__PURE__ */ new WeakMap();
            map[event] = listeners;
          }
          const patchedListener = contextManager.bind(context3, listener);
          listeners.set(listener, patchedListener);
          contextManager._wrapped = true;
          try {
            return original.call(this, event, patchedListener);
          } finally {
            contextManager._wrapped = false;
          }
        };
      }
      _createPatchMap(ee) {
        const map = /* @__PURE__ */ Object.create(null);
        ee[this._kOtListeners] = map;
        return map;
      }
      _getPatchMap(ee) {
        return ee[this._kOtListeners];
      }
    };
    exports2.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager;
  }
});

// node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js
var require_AsyncHooksContextManager = __commonJS({
  "node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncHooksContextManager = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var asyncHooks = require("async_hooks");
    var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();
    var AsyncHooksContextManager = class extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
      constructor() {
        super();
        this._contexts = /* @__PURE__ */ new Map();
        this._stack = [];
        this._asyncHook = asyncHooks.createHook({
          init: this._init.bind(this),
          before: this._before.bind(this),
          after: this._after.bind(this),
          destroy: this._destroy.bind(this),
          promiseResolve: this._destroy.bind(this)
        });
      }
      active() {
        var _a;
        return (_a = this._stack[this._stack.length - 1]) !== null && _a !== void 0 ? _a : api_1.ROOT_CONTEXT;
      }
      with(context3, fn, thisArg, ...args) {
        this._enterContext(context3);
        try {
          return fn.call(thisArg, ...args);
        } finally {
          this._exitContext();
        }
      }
      enable() {
        this._asyncHook.enable();
        return this;
      }
      disable() {
        this._asyncHook.disable();
        this._contexts.clear();
        this._stack = [];
        return this;
      }
      /**
       * Init hook will be called when userland create a async context, setting the
       * context as the current one if it exist.
       * @param uid id of the async context
       * @param type the resource type
       */
      _init(uid, type) {
        if (type === "TIMERWRAP")
          return;
        const context3 = this._stack[this._stack.length - 1];
        if (context3 !== void 0) {
          this._contexts.set(uid, context3);
        }
      }
      /**
       * Destroy hook will be called when a given context is no longer used so we can
       * remove its attached context.
       * @param uid uid of the async context
       */
      _destroy(uid) {
        this._contexts.delete(uid);
      }
      /**
       * Before hook is called just before executing a async context.
       * @param uid uid of the async context
       */
      _before(uid) {
        const context3 = this._contexts.get(uid);
        if (context3 !== void 0) {
          this._enterContext(context3);
        }
      }
      /**
       * After hook is called just after completing the execution of a async context.
       */
      _after() {
        this._exitContext();
      }
      /**
       * Set the given context as active
       */
      _enterContext(context3) {
        this._stack.push(context3);
      }
      /**
       * Remove the context at the root of the stack
       */
      _exitContext() {
        this._stack.pop();
      }
    };
    exports2.AsyncHooksContextManager = AsyncHooksContextManager;
  }
});

// node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js
var require_AsyncLocalStorageContextManager = __commonJS({
  "node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncLocalStorageContextManager = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var async_hooks_1 = require("async_hooks");
    var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();
    var AsyncLocalStorageContextManager2 = class extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
      constructor() {
        super();
        this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage();
      }
      active() {
        var _a;
        return (_a = this._asyncLocalStorage.getStore()) !== null && _a !== void 0 ? _a : api_1.ROOT_CONTEXT;
      }
      with(context3, fn, thisArg, ...args) {
        const cb = thisArg == null ? fn : fn.bind(thisArg);
        return this._asyncLocalStorage.run(context3, cb, ...args);
      }
      enable() {
        return this;
      }
      disable() {
        this._asyncLocalStorage.disable();
        return this;
      }
    };
    exports2.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager2;
  }
});

// node_modules/@opentelemetry/context-async-hooks/build/src/index.js
var require_src29 = __commonJS({
  "node_modules/@opentelemetry/context-async-hooks/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncLocalStorageContextManager = exports2.AsyncHooksContextManager = void 0;
    var AsyncHooksContextManager_1 = require_AsyncHooksContextManager();
    Object.defineProperty(exports2, "AsyncHooksContextManager", { enumerable: true, get: function() {
      return AsyncHooksContextManager_1.AsyncHooksContextManager;
    } });
    var AsyncLocalStorageContextManager_1 = require_AsyncLocalStorageContextManager();
    Object.defineProperty(exports2, "AsyncLocalStorageContextManager", { enumerable: true, get: function() {
      return AsyncLocalStorageContextManager_1.AsyncLocalStorageContextManager;
    } });
  }
});

// node_modules/@actions/core/lib/utils.js
var require_utils20 = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issue = exports2.issueCommand = void 0;
    var os4 = __importStar(require("os"));
    var utils_1 = require_utils20();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os4.EOL);
    }
    exports2.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareKeyValueMessage = exports2.issueFileCommand = void 0;
    var crypto = __importStar(require("crypto"));
    var fs = __importStar(require("fs"));
    var os4 = __importStar(require("os"));
    var utils_1 = require_utils20();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os4.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
      const convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os4.EOL}${convertedValue}${os4.EOL}${delimiter}`;
    }
    exports2.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new URL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new URL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports2.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net2 = require("net");
    var tls2 = require("tls");
    var http4 = require("http");
    var https2 = require("https");
    var events = require("events");
    var assert = require("assert");
    var util3 = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http4.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http4.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self = this;
      self.options = options || {};
      self.proxyOptions = self.options.proxy || {};
      self.maxSockets = self.options.maxSockets || http4.Agent.defaultMaxSockets;
      self.requests = [];
      self.sockets = [];
      self.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self.removeSocket(socket);
      });
    }
    util3.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self = this;
      var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
      if (self.sockets.length >= this.maxSockets) {
        self.requests.push(options);
        return;
      }
      self.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this;
      var placeholder = {};
      self.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug3("making CONNECT request");
      var connectReq = self.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug3(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug3("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
          return;
        }
        debug3("tunneling connection has established");
        self.sockets[self.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug3(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self = this;
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls2.connect(0, tlsOptions);
        self.sockets[self.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug3;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug3 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug3 = function() {
      };
    }
    exports2.debug = debug3;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/undici/lib/core/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols2();
    var { IncomingMessage } = require("http");
    var stream = require("stream");
    var net2 = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require("buffer");
    var nodeUtil = require("util");
    var { stringify } = require("querystring");
    var { headerNameLowerCasedRecord } = require_constants4();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url2, queryParams) {
      if (url2.includes("?") || url2.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url2 += "?" + stringified;
      }
      return url2;
    }
    function parseURL(url2) {
      if (typeof url2 === "string") {
        url2 = new URL(url2);
        if (!/^https?:/.test(url2.origin || url2.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url2;
      }
      if (!url2 || typeof url2 !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url2.origin || url2.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url2 instanceof URL)) {
        if (url2.port != null && url2.port !== "" && !Number.isFinite(parseInt(url2.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url2.path != null && typeof url2.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url2.pathname != null && typeof url2.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url2.hostname != null && typeof url2.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url2.origin != null && typeof url2.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url2.port != null ? url2.port : url2.protocol === "https:" ? 443 : 80;
        let origin = url2.origin != null ? url2.origin : `${url2.protocol}//${url2.hostname}:${port}`;
        let path = url2.path != null ? url2.path : `${url2.pathname || ""}${url2.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url2 = new URL(origin + path);
      }
      return url2;
    }
    function parseOrigin(url2) {
      url2 = parseURL(url2);
      if (url2.pathname !== "/" || url2.search || url2.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url2;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net2.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer2(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer2(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer: isBuffer2,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter3 = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter3);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require("node:util").inherits;
    var ReadableStream = require("node:stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module2.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter3 = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter3.call(this);
      cfg = cfg || {};
      const self = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self.maxed) {
          if (self.nread + end - start >= self.maxHeaderSize) {
            end = self.maxHeaderSize - self.nread + start;
            self.nread = self.maxHeaderSize;
            self.maxed = true;
          } else {
            self.nread += end - start;
          }
          self.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter3);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var inherits = require("node:util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self._inHeader = false;
        self._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self = this;
          process.nextTick(function() {
            self.emit("error", new Error("Unexpected end of multipart data"));
            if (self._part && !self._ignoreData) {
              const type = self._isPreamble ? "Preamble" : "Part";
              self._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self._part.push(null);
              process.nextTick(function() {
                self._realFinish = true;
                self.emit("finish");
                self._realFinish = false;
              });
              return;
            }
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self._parts === 0) {
            self._realFinish = true;
            self.emit("finish");
            self._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self._parts === 0) {
                if (self._finished) {
                  self._realFinish = true;
                  self.emit("finish");
                  self._realFinish = false;
                } else {
                  self._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports2.toString())) {
          try {
            return textDecoders.get(exports2).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module2.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function basename2(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          // '/'
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable: Readable2 } = require("node:stream");
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename2 = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self._needDrain = false;
        if (self._cb && !self._pause) {
          const cb = self._cb;
          self._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self._nparts > partsLimit) {
          self.parser.removeListener("part", onPart);
          self.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename2(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self._pause = false;
              checkFinished();
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self._pause) {
                return;
              }
              self._pause = false;
              if (self._cb && !self._needDrain) {
                const cb = self._cb;
                self._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self = this;
      if (self.parser.writable) {
        self.parser.end();
      } else if (!self._boy._done) {
        process.nextTick(function() {
          self._boy._done = true;
          self._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable2.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable2);
    FileStream.prototype._read = function(n) {
    };
    module2.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module2.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants5 = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel3;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel3) {
        channel3 = new MessageChannel();
      }
      channel3.port1.unref();
      channel3.port2.unref();
      channel3.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel3.port2).message;
    };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants5();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = require("assert");
    var { isUint8Array } = require("util/types");
    var supportedHashes = [];
    var crypto;
    try {
      crypto = require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url2 = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url2) && badPortsSet.has(url2.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * requests current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * requests current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url2, originOnly) {
      assert(url2 instanceof URL);
      if (url2.protocol === "file:" || url2.protocol === "about:" || url2.protocol === "blank:") {
        return "no-referrer";
      }
      url2.username = "";
      url2.password = "";
      url2.hash = "";
      if (originOnly) {
        url2.pathname = "";
        url2.search = "";
      }
      return url2;
    }
    function isURLPotentiallyTrustworthy(url2) {
      if (!(url2 instanceof URL)) {
        return false;
      }
      if (url2.href === "about:blank" || url2.href === "about:srcdoc") {
        return true;
      }
      if (url2.protocol === "data:") return true;
      if (url2.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url2.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve2, reject) => {
        res = resolve2;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted2(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url2) {
      assert("protocol" in url2);
      const protocol = url2.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url2) {
      if (typeof url2 === "string") {
        return url2.startsWith("https:");
      }
      return url2.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url2) {
      assert("protocol" in url2);
      const protocol = url2.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted: isAborted2,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context3) {
      const plural = context3.types.length === 1 ? "" : " one of";
      const message = `${context3.argument} could not be converted to${plural}: ${context3.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context3.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context3) {
      return webidl.errors.exception({
        header: context3.prefix,
        message: `"${context3.value}" is an invalid ${context3.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url2, excludeFragment = false) {
      if (!excludeFragment) {
        return url2.href;
      }
      const href = url2.href;
      const hashLength = url2.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { types } = require("util");
    var { kState } = require_symbols3();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols3();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var File = NativeFile ?? UndiciFile;
    var FormData = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main();
    var util3 = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols3();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants5();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { kBodyUsed } = require_symbols2();
    var assert = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var random;
    try {
      const crypto = require("node:crypto");
      random = (max) => crypto.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random(max));
    }
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util3.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util3.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util3.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util3.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util3.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve2, reject) => {
              busboy.on("finish", resolve2);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util3.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols2();
    var util3 = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel2 = require("diagnostics_channel");
      channels.create = diagnosticsChannel2.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel2.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel2.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel2.channel("undici:request:trailers");
      channels.error = diagnosticsChannel2.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request2 = class _Request {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util3.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util3.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util3.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util3.isFormDataLike(body) || util3.isIterable(body) || util3.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util3.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util3.isFormDataLike(this.body)) {
          if (util3.nodeMajor < 16 || util3.nodeMajor === 16 && util3.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util3.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util3.validateHandler(handler, method, upgrade);
        this.servername = util3.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume2, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume2, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request2;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter3 = require("events");
    var Dispatcher = class extends EventEmitter3 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols2();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve2, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve2, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net2 = require("net");
    var assert = require("assert");
    var util3 = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls2;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect3({ hostname: hostname2, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls2) {
            tls2 = require("tls");
          }
          servername = servername || options.servername || util3.getServerName(host) || null;
          const sessionKey = servername || hostname2;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls2.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname2
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net2.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname2
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util3.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils21 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants6 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils21();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util3 = require_util();
    var { kBodyUsed } = require_symbols2();
    var assert = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util3.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util3.isStream(this.opts.body)) {
          if (util3.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util3.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume2, statusText) {
        this.location = this.history.length >= this.maxRedirections || util3.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume2, statusText);
        }
        const { origin, pathname, search } = util3.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util3.headerNameToString(header) === "host";
      }
      if (removeContent && util3.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util3.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var net2 = require("net");
    var http4 = require("http");
    var { pipeline } = require("stream");
    var util3 = require_util();
    var timers = require_timers();
    var Request2 = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols2();
    var http22;
    try {
      http22 = require("http2");
    } catch {
      http22 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http22;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel2 = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel2.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel2.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel2.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel2.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client2 = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url2, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls: tls2,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect4,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect4 != null && typeof connect4 !== "function" && typeof connect4 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net2.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect4 !== "function") {
          connect4 = buildConnector({
            ...tls2,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util3.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect4
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util3.parseOrigin(url2);
        this[kConnector] = connect4;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http4.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume2(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect3(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request2[kHTTP2BuildRequest](origin, opts, handler) : Request2[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util3.bodyLength(request.body) == null && util3.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume2, this);
        } else {
          resume2(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve2) => {
          if (!this[kSize]) {
            resolve2(null);
          } else {
            this[kClosedResolve] = resolve2;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve2) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve2();
          };
          if (this[kHTTP2Session] != null) {
            util3.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util3.destroy(this[kSocket].on("close", callback), err);
          }
          resume2(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util3.destroy(this, new SocketError("other side closed"));
      util3.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume2(client);
    }
    var constants = require_constants6();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util3.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util3.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util3.destroy(socket, err);
        }
        resume2(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util3.destroy(socket, new SocketError("bad response", util3.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util3.destroy(socket, new SocketError("bad upgrade", util3.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util3.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume2(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util3.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util3.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util3.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util3.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util3.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume2, client);
        } else {
          resume2(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util3.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util3.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util3.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util3.destroy(this, new SocketError("other side closed", util3.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util3.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume2(client);
    }
    async function connect3(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname: hostname2, protocol, port } = client[kUrl];
      if (hostname2[0] === "[") {
        const idx = hostname2.indexOf("]");
        assert(idx !== -1);
        const ip = hostname2.substring(1, idx);
        assert(net2.isIP(ip));
        hostname2 = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname: hostname2,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve2, reject) => {
          client[kConnector]({
            host,
            hostname: hostname2,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve2(socket2);
            }
          });
        });
        if (client.destroyed) {
          util3.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http22.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname: hostname2,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname: hostname2,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume2(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume2(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util3.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect3(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util3.bodyLength(request.body) !== 0 && (util3.isStream(request.body) || util3.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util3.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util3.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util3.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util3.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util3.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util3.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string") headers = Request2[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util3.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util3.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util3.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util3.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util3.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util3.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util3.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util3.destroy(body, err);
              util3.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util3.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util3.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util3.destroy(body, err);
        } else {
          util3.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume2(client);
      } catch (err) {
        util3.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve2, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve2;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume2(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util3.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client2;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols2();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols2();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve2) => {
            this[kClosedResolve] = resolve2;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client2 = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util3 = require_util();
    var { kUrl, kInterceptors } = require_symbols2();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client2(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect: connect3,
        connectTimeout,
        tls: tls2,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect3 != null && typeof connect3 !== "function" && typeof connect3 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect3 !== "function") {
          connect3 = buildConnector({
            ...tls2,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util3.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect3
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util3.parseOrigin(origin);
        this[kOptions] = { ...util3.deepClone(options), connect: connect3, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connectionError", (origin2, targets, error) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols2();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0) return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols2();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols2();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client2 = require_client();
    var util3 = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
    }
    var Agent3 = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect: connect3, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect3 != null && typeof connect3 !== "function" && typeof connect3 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect3 && typeof connect3 !== "function") {
          connect3 = { ...connect3 };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util3.deepClone(options), connect: connect3 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent3;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { Readable: Readable2 } = require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util3 = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    var noop = () => {
    };
    module2.exports = class BodyReadable extends Readable2 {
      constructor({
        resume: resume2,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume2,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util3.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util3.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve2, reject) => {
          const signalListenerCleanup = signal ? util3.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve2(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self) {
      return self[kBody] && self[kBody].locked === true || self[kConsume];
    }
    function isUnusable(self) {
      return util3.isDisturbed(self) || isLocked(self);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve2, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve: resolve2,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve: resolve2, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve2(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve2(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve2(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require("buffer").Blob;
          }
          resolve2(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert = require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self) {
      if (self.abort) {
        self.abort();
      } else {
        self.onError(new RequestAbortedError());
      }
    }
    function addSignal(self, signal) {
      self[kSignal] = null;
      self[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self);
        return;
      }
      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };
      addAbortListener(self[kSignal], self[kListener]);
    }
    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }
      if ("removeEventListener" in self[kSignal]) {
        self[kSignal].removeEventListener("abort", self[kListener]);
      } else {
        self[kSignal].removeListener("abort", self[kListener]);
      }
      self[kSignal] = null;
      self[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable2 = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util3 = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util3.isStream(body)) {
            util3.destroy(body.on("error", util3.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util3.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context3) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context3;
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        const { callback, opaque, abort, context: context3, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util3.parseRawHeaders(rawHeaders) : util3.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util3.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable2({ resume: resume2, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context: context3
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util3.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util3.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util3.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util3 = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util3.isStream(body)) {
            util3.destroy(body.on("error", util3.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util3.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context3) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context3;
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        const { factory, opaque, context: context3, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util3.parseRawHeaders(rawHeaders) : util3.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util3.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context: context3
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util3.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume2);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util3.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util3.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util3.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable: Readable2,
      Duplex,
      PassThrough
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util3 = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable2 {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume2 } = this;
        if (resume2) {
          this[kResume] = null;
          resume2();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable2 {
      constructor(resume2) {
        super({ autoDestroy: true });
        this[kResume] = resume2;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util3.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util3.destroy(body, err);
            util3.destroy(req, err);
            util3.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context3) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context3;
      }
      onHeaders(statusCode, rawHeaders, resume2) {
        const { opaque, handler, context: context3 } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util3.parseRawHeaders(rawHeaders) : util3.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume2);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util3.parseRawHeaders(rawHeaders) : util3.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context: context3
          });
        } catch (err) {
          this.res.on("error", util3.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util3.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util3.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util3.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util3 = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context3) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context: context3 } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util3.parseRawHeaders(rawHeaders) : util3.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context: context3
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util3 = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context3) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context3;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context: context3 } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util3.parseRawHeaders(rawHeaders) : util3.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context: context3
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect3(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          connect3.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect3;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = require("http");
    var {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume2, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume2() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url2 = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url2.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify2 } = require("util");
    var Client2 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols2();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client2 {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify2(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify2 } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols2();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify2(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols2();
    var Agent3 = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent3(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols2();
    var { URL: URL3 } = require("url");
    var Agent3 = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent3(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL3(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect3 = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect: connect3 });
        this[kAgent] = new Agent3({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL3(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/undici/lib/handler/RetryHandler.js"(exports2, module2) {
    var assert = require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols2();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers2) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers2.dispatch;
        this.handler = handlers2.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume2;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume2,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume2;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume2,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent3 = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent3());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols2();
    var { kGuard } = require_symbols3();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var util3 = require("util");
    var { webidl } = require_webidl();
    var assert = require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill2(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      constructor(init2) {
        /** @type {[string, string][]|null} */
        __publicField(this, "cookies", null);
        if (init2 instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init2[kHeadersMap]);
          this[kHeadersSortedMap] = init2[kHeadersSortedMap];
          this.cookies = init2.cookies === null ? null : [...init2.cookies];
        } else {
          this[kHeadersMap] = new Map(init2);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ?? (this.cookies = []);
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init2 = void 0) {
        if (init2 === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init2 !== void 0) {
          init2 = webidl.converters.HeadersInit(init2);
          fill2(this, init2);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          const [name, value] = names[i];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util3.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill: fill2,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill: fill2 } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util3 = require_util();
    var { kEnumerableProperty } = util3;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted: isAborted2,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants5();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols3();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols2();
    var assert = require("assert");
    var { types } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init2 = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init2 !== null) {
          init2 = webidl.converters.ResponseInit(init2);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init2, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url2, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url2 = webidl.converters.USVString(url2);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url2, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url2), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init2 = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init2 = webidl.converters.ResponseInit(init2);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init2, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url2 = urlList[urlList.length - 1] ?? null;
        if (url2 === null) {
          return "";
        }
        return URLSerializer(url2, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util3.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init2) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init2,
        headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList(),
        urlList: init2.urlList ? [...init2.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError2 = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError2 ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted2(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init2, body) {
      if (init2.status !== null && (init2.status < 200 || init2.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init2 && init2.statusText != null) {
        if (!isValidReasonPhrase(String(init2.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init2 && init2.status != null) {
        response[kState].status = init2.status;
      }
      if ("statusText" in init2 && init2.statusText != null) {
        response[kState].statusText = init2.statusText;
      }
      if ("headers" in init2 && init2.headers != null) {
        fill2(response[kHeaders], init2.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util3.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util3 = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants5();
    var { kEnumerableProperty } = util3;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols3();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols2();
    var assert = require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request2 = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init2 = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init2 = webidl.converters.RequestInit(init2);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init2.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init2) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window: window2,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init2).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init2.referrer !== void 0) {
          const referrer = init2.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init2.referrerPolicy !== void 0) {
          request.referrerPolicy = init2.referrerPolicy;
        }
        let mode;
        if (init2.mode !== void 0) {
          mode = init2.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init2.credentials !== void 0) {
          request.credentials = init2.credentials;
        }
        if (init2.cache !== void 0) {
          request.cache = init2.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init2.redirect !== void 0) {
          request.redirect = init2.redirect;
        }
        if (init2.integrity != null) {
          request.integrity = String(init2.integrity);
        }
        if (init2.keepalive !== void 0) {
          request.keepalive = Boolean(init2.keepalive);
        }
        if (init2.method !== void 0) {
          let method = init2.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init2.signal !== void 0) {
          signal = init2.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util3.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init2.headers !== void 0 ? init2.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init2.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init2.body != null) {
          const [extractedBody, contentType] = extractBody(
            init2.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init2.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util3.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util3.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util3.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request2);
    function makeRequest(init2) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init2,
        headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request2.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request2
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request2) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request: Request2, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request: Request2, makeRequest } = require_request2();
    var zlib = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted: isAborted2,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols3();
    var assert = require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants5();
    var { kHeadersList } = require_symbols2();
    var EE = require("events");
    var { Readable: Readable2, pipeline } = require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    function fetch(input, init2 = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request2(input, init2);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init2.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted2(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted2(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url2 = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve2, reject) => agent.dispatch(
          {
            path: url2.pathname + url2.search,
            origin: url2.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume2, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable2({ read: resume2 });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve2({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve2({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols4();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants5();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require("util");
    var { StringDecoder } = require("string_decoder");
    var { btoa } = require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols4();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols2().kConstruct
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols5();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols2();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request: Request2 } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols3();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = require("assert");
    var { getGlobalDispatcher } = require_global2();
    var _relevantRequestResponseList, _Cache_instances, batchCacheOperations_fn, queryCache_fn, requestMatchesCachedItem_fn;
    var _Cache = class _Cache {
      constructor() {
        __privateAdd(this, _Cache_instances);
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
         * @type {requestResponseList}
         */
        __privateAdd(this, _relevantRequestResponseList);
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request2) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request2(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request2(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request2) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request2(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request2) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request2(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request2) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request2(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request2("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
    };
    _relevantRequestResponseList = new WeakMap();
    _Cache_instances = new WeakSet();
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    batchCacheOperations_fn = function(operations) {
      const cache = __privateGet(this, _relevantRequestResponseList);
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (__privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        __privateGet(this, _relevantRequestResponseList).length = 0;
        __privateSet(this, _relevantRequestResponseList, backupCache);
        throw e;
      }
    };
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    queryCache_fn = function(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? __privateGet(this, _relevantRequestResponseList);
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (__privateMethod(this, _Cache_instances, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    };
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    requestMatchesCachedItem_fn = function(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    };
    var Cache = _Cache;
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols5();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var _caches;
    var _CacheStorage = class _CacheStorage {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
         * @type {Map<string, import('./cache').requestResponseList}
         */
        __privateAdd(this, _caches, /* @__PURE__ */ new Map());
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            const cacheList = __privateGet(this, _caches).get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of __privateGet(this, _caches).values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (__privateGet(this, _caches).has(cacheName)) {
          const cache2 = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        __privateGet(this, _caches).set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = __privateGet(this, _caches).keys();
        return [...keys];
      }
    };
    _caches = new WeakMap();
    var CacheStorage = _CacheStorage;
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants7 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module2.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse2 = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants7();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ?? (cookieAttributeList.unparsed = []);
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse2();
    var { stringify } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants8 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols6 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = require("worker_threads");
    var _eventInit;
    var _MessageEvent = class _MessageEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit);
        __privateSet(this, _eventInit, eventInitDict);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
          Object.freeze(__privateGet(this, _eventInit).ports);
        }
        return __privateGet(this, _eventInit).ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId2 = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId: lastEventId2,
          source,
          ports
        });
      }
    };
    _eventInit = new WeakMap();
    var MessageEvent = _MessageEvent;
    var _eventInit2;
    var _CloseEvent = class _CloseEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit2);
        __privateSet(this, _eventInit2, eventInitDict);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).reason;
      }
    };
    _eventInit2 = new WeakMap();
    var CloseEvent = _CloseEvent;
    var _eventInit3;
    var _ErrorEvent = class _ErrorEvent extends Event {
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        __privateAdd(this, _eventInit3);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        __privateSet(this, _eventInit3, eventInitDict);
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).error;
      }
    };
    _eventInit3 = new WeakMap();
    var ErrorEvent = _ErrorEvent;
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols6();
    var { states, opcodes } = require_constants8();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel2 = require("diagnostics_channel");
    var { uid, states } = require_constants8();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols6();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols2();
    var channels = {};
    channels.open = diagnosticsChannel2.channel("undici:websocket:open");
    channels.close = diagnosticsChannel2.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel2.channel("undici:websocket:socket_error");
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url2, protocols, ws, onEstablish, options) {
      const requestURL = url2;
      requestURL.protocol = url2.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants8();
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var diagnosticsChannel2 = require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants8();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols6();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel2.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel2.channel("undici:websocket:pong");
    var _buffers, _byteOffset, _state, _info, _fragments;
    var ByteParser = class extends Writable {
      constructor(ws) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        __privateGet(this, _buffers).push(chunk);
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        var _a;
        while (true) {
          if (__privateGet(this, _state) === parserStates.INFO) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).fin = (buffer[0] & 128) !== 0;
            __privateGet(this, _info).opcode = buffer[0] & 15;
            (_a = __privateGet(this, _info)).originalOpcode ?? (_a.originalOpcode = __privateGet(this, _info).opcode);
            __privateGet(this, _info).fragmented = !__privateGet(this, _info).fin && __privateGet(this, _info).opcode !== opcodes.CONTINUATION;
            if (__privateGet(this, _info).fragmented && __privateGet(this, _info).opcode !== opcodes.BINARY && __privateGet(this, _info).opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              __privateGet(this, _info).payloadLength = payloadLength;
              __privateSet(this, _state, parserStates.READ_DATA);
            } else if (payloadLength === 126) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_16);
            } else if (payloadLength === 127) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_64);
            }
            if (__privateGet(this, _info).fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((__privateGet(this, _info).opcode === opcodes.PING || __privateGet(this, _info).opcode === opcodes.PONG || __privateGet(this, _info).opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              __privateGet(this, _info).closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              __privateSet(this, _state, parserStates.INFO);
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (__privateGet(this, _info).opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
            if (__privateGet(this, _byteOffset) < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            __privateGet(this, _info).payloadLength = (upper << 8) + lower;
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
            if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
              return callback();
            } else if (__privateGet(this, _byteOffset) >= __privateGet(this, _info).payloadLength) {
              const body = this.consume(__privateGet(this, _info).payloadLength);
              __privateGet(this, _fragments).push(body);
              if (!__privateGet(this, _info).fragmented || __privateGet(this, _info).fin && __privateGet(this, _info).opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                websocketMessageReceived(this.ws, __privateGet(this, _info).originalOpcode, fullMessage);
                __privateSet(this, _info, {});
                __privateGet(this, _fragments).length = 0;
              }
              __privateSet(this, _state, parserStates.INFO);
            }
          }
          if (__privateGet(this, _byteOffset) > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (__privateGet(this, _buffers)[0].length === n) {
          __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
          return __privateGet(this, _buffers).shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += next.length;
          }
        }
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
    _buffers = new WeakMap();
    _byteOffset = new WeakMap();
    _state = new WeakMap();
    _info = new WeakMap();
    _fragments = new WeakMap();
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants5();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants8();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols6();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require("util");
    var experimentalWarned = false;
    var _events, _bufferedAmount, _protocol, _extensions, _WebSocket_instances, onConnectionEstablished_fn;
    var _WebSocket = class _WebSocket extends EventTarget {
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url2, protocols = []) {
        super();
        __privateAdd(this, _WebSocket_instances);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, "");
        __privateAdd(this, _extensions, "");
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url2 = webidl.converters.USVString(url2);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url2, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => __privateMethod(this, _WebSocket_instances, onConnectionEstablished_fn).call(this, response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + ab.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - ab.byteLength);
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
            socket.write(buffer, () => {
              __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _bufferedAmount);
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _extensions);
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _protocol);
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).open) {
          this.removeEventListener("open", __privateGet(this, _events).open);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).open = fn;
          this.addEventListener("open", fn);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).error) {
          this.removeEventListener("error", __privateGet(this, _events).error);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).error = fn;
          this.addEventListener("error", fn);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).close) {
          this.removeEventListener("close", __privateGet(this, _events).close);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).close = fn;
          this.addEventListener("close", fn);
        } else {
          __privateGet(this, _events).close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).message) {
          this.removeEventListener("message", __privateGet(this, _events).message);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).message = fn;
          this.addEventListener("message", fn);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
    };
    _events = new WeakMap();
    _bufferedAmount = new WeakMap();
    _protocol = new WeakMap();
    _extensions = new WeakMap();
    _WebSocket_instances = new WeakSet();
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    onConnectionEstablished_fn = function(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        __privateSet(this, _extensions, extensions);
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        __privateSet(this, _protocol, protocol);
      }
      fireEvent("open", this);
    };
    var WebSocket = _WebSocket;
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici2 = __commonJS({
  "node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client2 = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent3 = require_agent();
    var util3 = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client2;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent3;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url2, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url2 || typeof url2 !== "string" && typeof url2 !== "object" && !(url2 instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url2 = new URL(util3.parseOrigin(url2).origin + path);
        } else {
          if (!opts) {
            opts = typeof url2 === "object" ? url2 : {};
          }
          url2 = util3.parseURL(url2);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url2.origin,
          path: url2.search ? `${url2.pathname}${url2.search}` : url2.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util3.nodeMajor > 16 || util3.nodeMajor === 16 && util3.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols5();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util3.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util3.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http4 = __importStar(require("http"));
    var https2 = __importStar(require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = require_undici2();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports2.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports2.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve2(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve2(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers2, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers2 || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve2(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult2(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult2(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult2(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function(err) {
          handleResult2(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https2 : http4;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http4.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https2.Agent(options) : new http4.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `${proxyUrl.username}:${proxyUrl.password}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve2) => setTimeout(() => resolve2(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve2(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve2(response);
            }
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core4();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            (0, core_1.setSecret)(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/@actions/io/lib/io-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCmdPath = exports2.tryGetExecutablePath = exports2.isRooted = exports2.isDirectory = exports2.exists = exports2.READONLY = exports2.UV_FS_O_EXLOCK = exports2.IS_WINDOWS = exports2.unlink = exports2.symlink = exports2.stat = exports2.rmdir = exports2.rm = exports2.rename = exports2.readlink = exports2.readdir = exports2.open = exports2.mkdir = exports2.lstat = exports2.copyFile = exports2.chmod = void 0;
    var fs = __importStar(require("fs"));
    var path = __importStar(require("path"));
    _a = fs.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.open = _a.open, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rm = _a.rm, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
    exports2.IS_WINDOWS = process.platform === "win32";
    exports2.UV_FS_O_EXLOCK = 268435456;
    exports2.READONLY = fs.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports2.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports2.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports2.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports2.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports2.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            const upperExt = path.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports2.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports2.IS_WINDOWS) {
              try {
                const directory = path.dirname(filePath);
                const upperName = path.basename(filePath).toUpperCase();
                for (const actualName of yield exports2.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports2.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports2.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports2.getCmdPath = getCmdPath;
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/@actions/io/lib/io.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findInPath = exports2.which = exports2.mkdirP = exports2.rmRF = exports2.mv = exports2.cp = void 0;
    var assert_1 = require("assert");
    var path = __importStar(require("path"));
    var ioUtil = __importStar(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports2.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path.join(dest, path.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports2.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports2.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports2.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports2.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports2.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e) {
            if (e.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/@actions/exec/lib/toolrunner.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argStringToArray = exports2.ToolRunner = void 0;
    var os4 = __importStar(require("os"));
    var events = __importStar(require("events"));
    var child = __importStar(require("child_process"));
    var path = __importStar(require("path"));
    var io = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n = s.indexOf(os4.EOL);
          while (n > -1) {
            const line = s.substring(0, n);
            onLine(line);
            s = s.substring(n + os4.EOL.length);
            n = s.indexOf(os4.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x) => x === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os4.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error) {
                reject(error);
              } else {
                resolve2(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports2.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c) {
        if (escaped && c !== '"') {
          arg += "\\";
        }
        arg += c;
        escaped = false;
      }
      for (let i = 0; i < argString.length; i++) {
        const c = argString.charAt(i);
        if (c === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c);
          }
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports2.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error;
        if (this.processExited) {
          if (this.processError) {
            error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/@actions/exec/lib/exec.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExecOutput = exports2.exec = void 0;
    var string_decoder_1 = require("string_decoder");
    var tr = __importStar(require_toolrunner());
    function exec(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports2.exec = exec;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports2.getExecOutput = getExecOutput;
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform7 = __commonJS({
  "node_modules/@actions/core/lib/platform.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDetails = exports2.isLinux = exports2.isMacOS = exports2.isWindows = exports2.arch = exports2.platform = void 0;
    var os_1 = __importDefault(require("os"));
    var exec = __importStar(require_exec());
    var getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name.trim(),
        version: version.trim()
      };
    });
    var getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name,
        version
      };
    });
    var getLinuxInfo2 = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name, version] = stdout.trim().split("\n");
      return {
        name,
        version
      };
    });
    exports2.platform = os_1.default.platform();
    exports2.arch = os_1.default.arch();
    exports2.isWindows = exports2.platform === "win32";
    exports2.isMacOS = exports2.platform === "darwin";
    exports2.isLinux = exports2.platform === "linux";
    function getDetails() {
      return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports2.isWindows ? getWindowsInfo() : exports2.isMacOS ? getMacOsInfo() : getLinuxInfo2()), {
          platform: exports2.platform,
          arch: exports2.arch,
          isWindows: exports2.isWindows,
          isMacOS: exports2.isMacOS,
          isLinux: exports2.isLinux
        });
      });
    }
    exports2.getDetails = getDetails;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core4 = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.platform = exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = exports2.markdownSummary = exports2.summary = exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils20();
    var os4 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports2.ExitCode = ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
      }
      (0, command_1.issueCommand)("set-env", { name }, convertedVal);
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports2.addPath = addPath;
    function getInput(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports2.getInput = getInput;
    function getMultilineInput(name, options) {
      const inputs = getInput(name, options).split("\n").filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      process.stdout.write(os4.EOL);
      (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports2.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed2(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports2.setFailed = setFailed2;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports2.isDebug = isDebug;
    function debug3(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports2.debug = debug3;
    function error(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error;
    function warning(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info(message) {
      process.stdout.write(message + os4.EOL);
    }
    exports2.info = info;
    function startGroup(name) {
      (0, command_1.issue)("group", name);
    }
    exports2.startGroup = startGroup;
    function endGroup() {
      (0, command_1.issue)("endgroup");
    }
    exports2.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports2.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports2.platform = __importStar(require_platform7());
  }
});

// node_modules/@actions/tool-cache/node_modules/semver/semver.js
var require_semver3 = __commonJS({
  "node_modules/@actions/tool-cache/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug3;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug3 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug3 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re2 = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re2[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re2[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re2[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re2[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug3(i, src[i]);
      if (!re2[i]) {
        re2[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug3("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug3("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug3("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug3("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release2, identifier) {
      switch (release2) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release2);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release2, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release2, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major2;
    function major2(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug3("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug3("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug3("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug3("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug3("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug3("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug3("caret", comp);
      comp = replaceTildes(comp, options);
      debug3("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug3("xrange", comp);
      comp = replaceStars(comp, options);
      debug3("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug3("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug3("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug3("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug3("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug3("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug3("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug3("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug3("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug3("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug3("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug3("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug3("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug3(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce2;
    function coerce2(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// node_modules/@actions/tool-cache/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/@actions/tool-cache/lib/manifest.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._readLinuxVersionFile = exports2._getOsVersion = exports2._findMatch = void 0;
    var semver = __importStar(require_semver3());
    var core_1 = require_core4();
    var os4 = require("os");
    var cp = require("child_process");
    var fs = require("fs");
    function _findMatch(versionSpec, stable, candidates, archFilter) {
      return __awaiter(this, void 0, void 0, function* () {
        const platFilter = os4.platform();
        let result;
        let match;
        let file;
        for (const candidate of candidates) {
          const version = candidate.version;
          (0, core_1.debug)(`check ${version} satisfies ${versionSpec}`);
          if (semver.satisfies(version, versionSpec) && (!stable || candidate.stable === stable)) {
            file = candidate.files.find((item) => {
              (0, core_1.debug)(`${item.arch}===${archFilter} && ${item.platform}===${platFilter}`);
              let chk = item.arch === archFilter && item.platform === platFilter;
              if (chk && item.platform_version) {
                const osVersion = module2.exports._getOsVersion();
                if (osVersion === item.platform_version) {
                  chk = true;
                } else {
                  chk = semver.satisfies(osVersion, item.platform_version);
                }
              }
              return chk;
            });
            if (file) {
              (0, core_1.debug)(`matched ${candidate.version}`);
              match = candidate;
              break;
            }
          }
        }
        if (match && file) {
          result = Object.assign({}, match);
          result.files = [file];
        }
        return result;
      });
    }
    exports2._findMatch = _findMatch;
    function _getOsVersion() {
      const plat = os4.platform();
      let version = "";
      if (plat === "darwin") {
        version = cp.execSync("sw_vers -productVersion").toString();
      } else if (plat === "linux") {
        const lsbContents = module2.exports._readLinuxVersionFile();
        if (lsbContents) {
          const lines = lsbContents.split("\n");
          for (const line of lines) {
            const parts = line.split("=");
            if (parts.length === 2 && (parts[0].trim() === "VERSION_ID" || parts[0].trim() === "DISTRIB_RELEASE")) {
              version = parts[1].trim().replace(/^"/, "").replace(/"$/, "");
              break;
            }
          }
        }
      }
      return version;
    }
    exports2._getOsVersion = _getOsVersion;
    function _readLinuxVersionFile() {
      const lsbReleaseFile = "/etc/lsb-release";
      const osReleaseFile = "/etc/os-release";
      let contents = "";
      if (fs.existsSync(lsbReleaseFile)) {
        contents = fs.readFileSync(lsbReleaseFile).toString();
      } else if (fs.existsSync(osReleaseFile)) {
        contents = fs.readFileSync(osReleaseFile).toString();
      }
      return contents;
    }
    exports2._readLinuxVersionFile = _readLinuxVersionFile;
  }
});

// node_modules/@actions/tool-cache/lib/retry-helper.js
var require_retry_helper = __commonJS({
  "node_modules/@actions/tool-cache/lib/retry-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryHelper = void 0;
    var core4 = __importStar(require_core4());
    var RetryHelper = class {
      constructor(maxAttempts, minSeconds, maxSeconds) {
        if (maxAttempts < 1) {
          throw new Error("max attempts should be greater than or equal to 1");
        }
        this.maxAttempts = maxAttempts;
        this.minSeconds = Math.floor(minSeconds);
        this.maxSeconds = Math.floor(maxSeconds);
        if (this.minSeconds > this.maxSeconds) {
          throw new Error("min seconds should be less than or equal to max seconds");
        }
      }
      execute(action, isRetryable) {
        return __awaiter(this, void 0, void 0, function* () {
          let attempt = 1;
          while (attempt < this.maxAttempts) {
            try {
              return yield action();
            } catch (err) {
              if (isRetryable && !isRetryable(err)) {
                throw err;
              }
              core4.info(err.message);
            }
            const seconds = this.getSleepAmount();
            core4.info(`Waiting ${seconds} seconds before trying again`);
            yield this.sleep(seconds);
            attempt++;
          }
          return yield action();
        });
      }
      getSleepAmount() {
        return Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) + this.minSeconds;
      }
      sleep(seconds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => setTimeout(resolve2, seconds * 1e3));
        });
      }
    };
    exports2.RetryHelper = RetryHelper;
  }
});

// node_modules/@actions/tool-cache/lib/tool-cache.js
var require_tool_cache = __commonJS({
  "node_modules/@actions/tool-cache/lib/tool-cache.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.evaluateVersions = exports2.isExplicitVersion = exports2.findFromManifest = exports2.getManifestFromRepo = exports2.findAllVersions = exports2.find = exports2.cacheFile = exports2.cacheDir = exports2.extractZip = exports2.extractXar = exports2.extractTar = exports2.extract7z = exports2.downloadTool = exports2.HTTPError = void 0;
    var core4 = __importStar(require_core4());
    var io = __importStar(require_io());
    var crypto = __importStar(require("crypto"));
    var fs = __importStar(require("fs"));
    var mm = __importStar(require_manifest());
    var os4 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var httpm = __importStar(require_lib());
    var semver = __importStar(require_semver3());
    var stream = __importStar(require("stream"));
    var util3 = __importStar(require("util"));
    var assert_1 = require("assert");
    var exec_1 = require_exec();
    var retry_helper_1 = require_retry_helper();
    var HTTPError = class extends Error {
      constructor(httpStatusCode) {
        super(`Unexpected HTTP response: ${httpStatusCode}`);
        this.httpStatusCode = httpStatusCode;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports2.HTTPError = HTTPError;
    var IS_WINDOWS = process.platform === "win32";
    var IS_MAC = process.platform === "darwin";
    var userAgent = "actions/tool-cache";
    function downloadTool(url2, dest, auth, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        dest = dest || path.join(_getTempDirectory(), crypto.randomUUID());
        yield io.mkdirP(path.dirname(dest));
        core4.debug(`Downloading ${url2}`);
        core4.debug(`Destination ${dest}`);
        const maxAttempts = 3;
        const minSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS", 10);
        const maxSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS", 20);
        const retryHelper = new retry_helper_1.RetryHelper(maxAttempts, minSeconds, maxSeconds);
        return yield retryHelper.execute(() => __awaiter(this, void 0, void 0, function* () {
          return yield downloadToolAttempt(url2, dest || "", auth, headers);
        }), (err) => {
          if (err instanceof HTTPError && err.httpStatusCode) {
            if (err.httpStatusCode < 500 && err.httpStatusCode !== 408 && err.httpStatusCode !== 429) {
              return false;
            }
          }
          return true;
        });
      });
    }
    exports2.downloadTool = downloadTool;
    function downloadToolAttempt(url2, dest, auth, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (fs.existsSync(dest)) {
          throw new Error(`Destination file path ${dest} already exists`);
        }
        const http4 = new httpm.HttpClient(userAgent, [], {
          allowRetries: false
        });
        if (auth) {
          core4.debug("set auth");
          if (headers === void 0) {
            headers = {};
          }
          headers.authorization = auth;
        }
        const response = yield http4.get(url2, headers);
        if (response.message.statusCode !== 200) {
          const err = new HTTPError(response.message.statusCode);
          core4.debug(`Failed to download from "${url2}". Code(${response.message.statusCode}) Message(${response.message.statusMessage})`);
          throw err;
        }
        const pipeline = util3.promisify(stream.pipeline);
        const responseMessageFactory = _getGlobal("TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY", () => response.message);
        const readStream = responseMessageFactory();
        let succeeded = false;
        try {
          yield pipeline(readStream, fs.createWriteStream(dest));
          core4.debug("download complete");
          succeeded = true;
          return dest;
        } finally {
          if (!succeeded) {
            core4.debug("download failed");
            try {
              yield io.rmRF(dest);
            } catch (err) {
              core4.debug(`Failed to delete '${dest}'. ${err.message}`);
            }
          }
        }
      });
    }
    function extract7z(file, dest, _7zPath) {
      return __awaiter(this, void 0, void 0, function* () {
        (0, assert_1.ok)(IS_WINDOWS, "extract7z() not supported on current OS");
        (0, assert_1.ok)(file, 'parameter "file" is required');
        dest = yield _createExtractFolder(dest);
        const originalCwd = process.cwd();
        process.chdir(dest);
        if (_7zPath) {
          try {
            const logLevel = core4.isDebug() ? "-bb1" : "-bb0";
            const args = [
              "x",
              logLevel,
              "-bd",
              "-sccUTF-8",
              file
            ];
            const options = {
              silent: true
            };
            yield (0, exec_1.exec)(`"${_7zPath}"`, args, options);
          } finally {
            process.chdir(originalCwd);
          }
        } else {
          const escapedScript = path.join(__dirname, "..", "scripts", "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const escapedTarget = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const command = `& '${escapedScript}' -Source '${escapedFile}' -Target '${escapedTarget}'`;
          const args = [
            "-NoLogo",
            "-Sta",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            command
          ];
          const options = {
            silent: true
          };
          try {
            const powershellPath = yield io.which("powershell", true);
            yield (0, exec_1.exec)(`"${powershellPath}"`, args, options);
          } finally {
            process.chdir(originalCwd);
          }
        }
        return dest;
      });
    }
    exports2.extract7z = extract7z;
    function extractTar(file, dest, flags = "xz") {
      return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        dest = yield _createExtractFolder(dest);
        core4.debug("Checking tar --version");
        let versionOutput = "";
        yield (0, exec_1.exec)("tar --version", [], {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
        core4.debug(versionOutput.trim());
        const isGnuTar = versionOutput.toUpperCase().includes("GNU TAR");
        let args;
        if (flags instanceof Array) {
          args = flags;
        } else {
          args = [flags];
        }
        if (core4.isDebug() && !flags.includes("v")) {
          args.push("-v");
        }
        let destArg = dest;
        let fileArg = file;
        if (IS_WINDOWS && isGnuTar) {
          args.push("--force-local");
          destArg = dest.replace(/\\/g, "/");
          fileArg = file.replace(/\\/g, "/");
        }
        if (isGnuTar) {
          args.push("--warning=no-unknown-keyword");
          args.push("--overwrite");
        }
        args.push("-C", destArg, "-f", fileArg);
        yield (0, exec_1.exec)(`tar`, args);
        return dest;
      });
    }
    exports2.extractTar = extractTar;
    function extractXar(file, dest, flags = []) {
      return __awaiter(this, void 0, void 0, function* () {
        (0, assert_1.ok)(IS_MAC, "extractXar() not supported on current OS");
        (0, assert_1.ok)(file, 'parameter "file" is required');
        dest = yield _createExtractFolder(dest);
        let args;
        if (flags instanceof Array) {
          args = flags;
        } else {
          args = [flags];
        }
        args.push("-x", "-C", dest, "-f", file);
        if (core4.isDebug()) {
          args.push("-v");
        }
        const xarPath = yield io.which("xar", true);
        yield (0, exec_1.exec)(`"${xarPath}"`, _unique(args));
        return dest;
      });
    }
    exports2.extractXar = extractXar;
    function extractZip(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        dest = yield _createExtractFolder(dest);
        if (IS_WINDOWS) {
          yield extractZipWin(file, dest);
        } else {
          yield extractZipNix(file, dest);
        }
        return dest;
      });
    }
    exports2.extractZip = extractZip;
    function extractZipWin(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const escapedDest = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const pwshPath = yield io.which("pwsh", false);
        if (pwshPath) {
          const pwshCommand = [
            `$ErrorActionPreference = 'Stop' ;`,
            `try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;`,
            `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`,
            `catch { if (($_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or ($_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force } else { throw $_ } } ;`
          ].join(" ");
          const args = [
            "-NoLogo",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            pwshCommand
          ];
          core4.debug(`Using pwsh at path: ${pwshPath}`);
          yield (0, exec_1.exec)(`"${pwshPath}"`, args);
        } else {
          const powershellCommand = [
            `$ErrorActionPreference = 'Stop' ;`,
            `try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;`,
            `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force }`,
            `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`
          ].join(" ");
          const args = [
            "-NoLogo",
            "-Sta",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            powershellCommand
          ];
          const powershellPath = yield io.which("powershell", true);
          core4.debug(`Using powershell at path: ${powershellPath}`);
          yield (0, exec_1.exec)(`"${powershellPath}"`, args);
        }
      });
    }
    function extractZipNix(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        const unzipPath = yield io.which("unzip", true);
        const args = [file];
        if (!core4.isDebug()) {
          args.unshift("-q");
        }
        args.unshift("-o");
        yield (0, exec_1.exec)(`"${unzipPath}"`, args, { cwd: dest });
      });
    }
    function cacheDir(sourceDir, tool, version, arch2) {
      return __awaiter(this, void 0, void 0, function* () {
        version = semver.clean(version) || version;
        arch2 = arch2 || os4.arch();
        core4.debug(`Caching tool ${tool} ${version} ${arch2}`);
        core4.debug(`source dir: ${sourceDir}`);
        if (!fs.statSync(sourceDir).isDirectory()) {
          throw new Error("sourceDir is not a directory");
        }
        const destPath = yield _createToolPath(tool, version, arch2);
        for (const itemName of fs.readdirSync(sourceDir)) {
          const s = path.join(sourceDir, itemName);
          yield io.cp(s, destPath, { recursive: true });
        }
        _completeToolPath(tool, version, arch2);
        return destPath;
      });
    }
    exports2.cacheDir = cacheDir;
    function cacheFile(sourceFile, targetFile, tool, version, arch2) {
      return __awaiter(this, void 0, void 0, function* () {
        version = semver.clean(version) || version;
        arch2 = arch2 || os4.arch();
        core4.debug(`Caching tool ${tool} ${version} ${arch2}`);
        core4.debug(`source file: ${sourceFile}`);
        if (!fs.statSync(sourceFile).isFile()) {
          throw new Error("sourceFile is not a file");
        }
        const destFolder = yield _createToolPath(tool, version, arch2);
        const destPath = path.join(destFolder, targetFile);
        core4.debug(`destination file ${destPath}`);
        yield io.cp(sourceFile, destPath);
        _completeToolPath(tool, version, arch2);
        return destFolder;
      });
    }
    exports2.cacheFile = cacheFile;
    function find(toolName, versionSpec, arch2) {
      if (!toolName) {
        throw new Error("toolName parameter is required");
      }
      if (!versionSpec) {
        throw new Error("versionSpec parameter is required");
      }
      arch2 = arch2 || os4.arch();
      if (!isExplicitVersion(versionSpec)) {
        const localVersions = findAllVersions(toolName, arch2);
        const match = evaluateVersions(localVersions, versionSpec);
        versionSpec = match;
      }
      let toolPath = "";
      if (versionSpec) {
        versionSpec = semver.clean(versionSpec) || "";
        const cachePath = path.join(_getCacheDirectory(), toolName, versionSpec, arch2);
        core4.debug(`checking cache: ${cachePath}`);
        if (fs.existsSync(cachePath) && fs.existsSync(`${cachePath}.complete`)) {
          core4.debug(`Found tool in cache ${toolName} ${versionSpec} ${arch2}`);
          toolPath = cachePath;
        } else {
          core4.debug("not found");
        }
      }
      return toolPath;
    }
    exports2.find = find;
    function findAllVersions(toolName, arch2) {
      const versions = [];
      arch2 = arch2 || os4.arch();
      const toolPath = path.join(_getCacheDirectory(), toolName);
      if (fs.existsSync(toolPath)) {
        const children = fs.readdirSync(toolPath);
        for (const child of children) {
          if (isExplicitVersion(child)) {
            const fullPath = path.join(toolPath, child, arch2 || "");
            if (fs.existsSync(fullPath) && fs.existsSync(`${fullPath}.complete`)) {
              versions.push(child);
            }
          }
        }
      }
      return versions;
    }
    exports2.findAllVersions = findAllVersions;
    function getManifestFromRepo(owner, repo, auth, branch = "master") {
      return __awaiter(this, void 0, void 0, function* () {
        let releases = [];
        const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}`;
        const http4 = new httpm.HttpClient("tool-cache");
        const headers = {};
        if (auth) {
          core4.debug("set auth");
          headers.authorization = auth;
        }
        const response = yield http4.getJson(treeUrl, headers);
        if (!response.result) {
          return releases;
        }
        let manifestUrl = "";
        for (const item of response.result.tree) {
          if (item.path === "versions-manifest.json") {
            manifestUrl = item.url;
            break;
          }
        }
        headers["accept"] = "application/vnd.github.VERSION.raw";
        let versionsRaw = yield (yield http4.get(manifestUrl, headers)).readBody();
        if (versionsRaw) {
          versionsRaw = versionsRaw.replace(/^\uFEFF/, "");
          try {
            releases = JSON.parse(versionsRaw);
          } catch (_a) {
            core4.debug("Invalid json");
          }
        }
        return releases;
      });
    }
    exports2.getManifestFromRepo = getManifestFromRepo;
    function findFromManifest(versionSpec, stable, manifest, archFilter = os4.arch()) {
      return __awaiter(this, void 0, void 0, function* () {
        const match = yield mm._findMatch(versionSpec, stable, manifest, archFilter);
        return match;
      });
    }
    exports2.findFromManifest = findFromManifest;
    function _createExtractFolder(dest) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!dest) {
          dest = path.join(_getTempDirectory(), crypto.randomUUID());
        }
        yield io.mkdirP(dest);
        return dest;
      });
    }
    function _createToolPath(tool, version, arch2) {
      return __awaiter(this, void 0, void 0, function* () {
        const folderPath = path.join(_getCacheDirectory(), tool, semver.clean(version) || version, arch2 || "");
        core4.debug(`destination ${folderPath}`);
        const markerPath = `${folderPath}.complete`;
        yield io.rmRF(folderPath);
        yield io.rmRF(markerPath);
        yield io.mkdirP(folderPath);
        return folderPath;
      });
    }
    function _completeToolPath(tool, version, arch2) {
      const folderPath = path.join(_getCacheDirectory(), tool, semver.clean(version) || version, arch2 || "");
      const markerPath = `${folderPath}.complete`;
      fs.writeFileSync(markerPath, "");
      core4.debug("finished caching tool");
    }
    function isExplicitVersion(versionSpec) {
      const c = semver.clean(versionSpec) || "";
      core4.debug(`isExplicit: ${c}`);
      const valid = semver.valid(c) != null;
      core4.debug(`explicit? ${valid}`);
      return valid;
    }
    exports2.isExplicitVersion = isExplicitVersion;
    function evaluateVersions(versions, versionSpec) {
      let version = "";
      core4.debug(`evaluating ${versions.length} versions`);
      versions = versions.sort((a, b) => {
        if (semver.gt(a, b)) {
          return 1;
        }
        return -1;
      });
      for (let i = versions.length - 1; i >= 0; i--) {
        const potential = versions[i];
        const satisfied = semver.satisfies(potential, versionSpec);
        if (satisfied) {
          version = potential;
          break;
        }
      }
      if (version) {
        core4.debug(`matched: ${version}`);
      } else {
        core4.debug("match not found");
      }
      return version;
    }
    exports2.evaluateVersions = evaluateVersions;
    function _getCacheDirectory() {
      const cacheDirectory = process.env["RUNNER_TOOL_CACHE"] || "";
      (0, assert_1.ok)(cacheDirectory, "Expected RUNNER_TOOL_CACHE to be defined");
      return cacheDirectory;
    }
    function _getTempDirectory() {
      const tempDirectory = process.env["RUNNER_TEMP"] || "";
      (0, assert_1.ok)(tempDirectory, "Expected RUNNER_TEMP to be defined");
      return tempDirectory;
    }
    function _getGlobal(key, defaultValue) {
      const value = global[key];
      return value !== void 0 ? value : defaultValue;
    }
    function _unique(values) {
      return Array.from(new Set(values));
    }
  }
});

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-glob-options-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOptions = void 0;
    var core4 = __importStar(require_core4());
    function getOptions(copy) {
      const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        matchDirectories: true,
        omitBrokenSymbolicLinks: true,
        excludeHiddenFiles: false
      };
      if (copy) {
        if (typeof copy.followSymbolicLinks === "boolean") {
          result.followSymbolicLinks = copy.followSymbolicLinks;
          core4.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy.implicitDescendants === "boolean") {
          result.implicitDescendants = copy.implicitDescendants;
          core4.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy.matchDirectories === "boolean") {
          result.matchDirectories = copy.matchDirectories;
          core4.debug(`matchDirectories '${result.matchDirectories}'`);
        }
        if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
          result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
          core4.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
        if (typeof copy.excludeHiddenFiles === "boolean") {
          result.excludeHiddenFiles = copy.excludeHiddenFiles;
          core4.debug(`excludeHiddenFiles '${result.excludeHiddenFiles}'`);
        }
      }
      return result;
    }
    exports2.getOptions = getOptions;
  }
});

// node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-path-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeTrimTrailingSeparator = exports2.normalizeSeparators = exports2.hasRoot = exports2.hasAbsoluteRoot = exports2.ensureAbsoluteRoot = exports2.dirname = void 0;
    var path = __importStar(require("path"));
    var assert_1 = __importDefault(require("assert"));
    var IS_WINDOWS = process.platform === "win32";
    function dirname3(p) {
      p = safeTrimTrailingSeparator(p);
      if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
      }
      let result = path.dirname(p);
      if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
      }
      return result;
    }
    exports2.dirname = dirname3;
    function ensureAbsoluteRoot(root, itemPath) {
      (0, assert_1.default)(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
      (0, assert_1.default)(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
      if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
      }
      if (IS_WINDOWS) {
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
          let cwd = process.cwd();
          (0, assert_1.default)(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
          if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
            if (itemPath.length === 2) {
              return `${itemPath[0]}:\\${cwd.substr(3)}`;
            } else {
              if (!cwd.endsWith("\\")) {
                cwd += "\\";
              }
              return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
            }
          } else {
            return `${itemPath[0]}:\\${itemPath.substr(2)}`;
          }
        } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
          const cwd = process.cwd();
          (0, assert_1.default)(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
          return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
      }
      (0, assert_1.default)(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
      if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) {
      } else {
        root += path.sep;
      }
      return root + itemPath;
    }
    exports2.ensureAbsoluteRoot = ensureAbsoluteRoot;
    function hasAbsoluteRoot(itemPath) {
      (0, assert_1.default)(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
      itemPath = normalizeSeparators(itemPath);
      if (IS_WINDOWS) {
        return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
      }
      return itemPath.startsWith("/");
    }
    exports2.hasAbsoluteRoot = hasAbsoluteRoot;
    function hasRoot(itemPath) {
      (0, assert_1.default)(itemPath, `isRooted parameter 'itemPath' must not be empty`);
      itemPath = normalizeSeparators(itemPath);
      if (IS_WINDOWS) {
        return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
      }
      return itemPath.startsWith("/");
    }
    exports2.hasRoot = hasRoot;
    function normalizeSeparators(p) {
      p = p || "";
      if (IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        const isUnc = /^\\\\+[^\\]/.test(p);
        return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    exports2.normalizeSeparators = normalizeSeparators;
    function safeTrimTrailingSeparator(p) {
      if (!p) {
        return "";
      }
      p = normalizeSeparators(p);
      if (!p.endsWith(path.sep)) {
        return p;
      }
      if (p === path.sep) {
        return p;
      }
      if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
      }
      return p.substr(0, p.length - 1);
    }
    exports2.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
  }
});

// node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS({
  "node_modules/@actions/glob/lib/internal-match-kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MatchKind = void 0;
    var MatchKind;
    (function(MatchKind2) {
      MatchKind2[MatchKind2["None"] = 0] = "None";
      MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
      MatchKind2[MatchKind2["File"] = 2] = "File";
      MatchKind2[MatchKind2["All"] = 3] = "All";
    })(MatchKind || (exports2.MatchKind = MatchKind = {}));
  }
});

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS({
  "node_modules/@actions/glob/lib/internal-pattern-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.partialMatch = exports2.match = exports2.getSearchPaths = void 0;
    var pathHelper = __importStar(require_internal_path_helper());
    var internal_match_kind_1 = require_internal_match_kind();
    var IS_WINDOWS = process.platform === "win32";
    function getSearchPaths(patterns) {
      patterns = patterns.filter((x) => !x.negate);
      const searchPathMap = {};
      for (const pattern of patterns) {
        const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
        searchPathMap[key] = "candidate";
      }
      const result = [];
      for (const pattern of patterns) {
        const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
        if (searchPathMap[key] === "included") {
          continue;
        }
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
          if (searchPathMap[parent]) {
            foundAncestor = true;
            break;
          }
          tempKey = parent;
          parent = pathHelper.dirname(tempKey);
        }
        if (!foundAncestor) {
          result.push(pattern.searchPath);
          searchPathMap[key] = "included";
        }
      }
      return result;
    }
    exports2.getSearchPaths = getSearchPaths;
    function match(patterns, itemPath) {
      let result = internal_match_kind_1.MatchKind.None;
      for (const pattern of patterns) {
        if (pattern.negate) {
          result &= ~pattern.match(itemPath);
        } else {
          result |= pattern.match(itemPath);
        }
      }
      return result;
    }
    exports2.match = match;
    function partialMatch(patterns, itemPath) {
      return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
    }
    exports2.partialMatch = partialMatch;
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre)) return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z2 = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z2 + c.slice(1);
                else
                  c = z2 + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options) options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options) options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug) this.debug = function debug3() {
        console.error.apply(console, arguments);
      };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate) return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset) this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "") return "";
      var re2 = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re2 += star;
              hasMagic = true;
              break;
            case "?":
              re2 += qmark;
              hasMagic = true;
              break;
            default:
              re2 += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re2);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re2, c);
        if (escaping && reSpecials[c]) {
          re2 += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          /* istanbul ignore next */
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re2, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1) c = "^";
              re2 += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext) clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re2 += "(";
              continue;
            }
            if (!stateChar) {
              re2 += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re2.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re2);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re2 += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re2 += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re2.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re2 += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re2 += "|";
            continue;
          // these are mostly the same in regexp and glob
          case "[":
            clearStateChar();
            if (inClass) {
              re2 += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re2.length;
            re2 += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re2 += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re2 += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re2 += "\\";
            }
            re2 += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re2.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re2, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re2);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re2 = re2.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re2 += "\\\\";
      }
      var addPatternStart = false;
      switch (re2.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re2.slice(0, nl.reStart);
        var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re2.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re2 = newRe;
      }
      if (re2 !== "" && hasMagic) {
        re2 = "(?=.)" + re2;
      }
      if (addPatternStart) {
        re2 = patternStart + re2;
      }
      if (isSub === SUBPARSE) {
        return [re2, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re2 + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re2;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false) return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re2 = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re2 = "^(?:" + re2 + ")$";
      if (this.negate) re2 = "^(?!" + re2 + ").*$";
      try {
        this.regexp = new RegExp(re2, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined") partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment) return false;
      if (this.empty) return f === "";
      if (f === "/" && partial) return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename) break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) return true;
          return !this.negate;
        }
      }
      if (options.flipNegate) return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS({
  "node_modules/@actions/glob/lib/internal-path.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Path = void 0;
    var path = __importStar(require("path"));
    var pathHelper = __importStar(require_internal_path_helper());
    var assert_1 = __importDefault(require("assert"));
    var IS_WINDOWS = process.platform === "win32";
    var Path = class {
      /**
       * Constructs a Path
       * @param itemPath Path or array of segments
       */
      constructor(itemPath) {
        this.segments = [];
        if (typeof itemPath === "string") {
          (0, assert_1.default)(itemPath, `Parameter 'itemPath' must not be empty`);
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
          if (!pathHelper.hasRoot(itemPath)) {
            this.segments = itemPath.split(path.sep);
          } else {
            let remaining = itemPath;
            let dir = pathHelper.dirname(remaining);
            while (dir !== remaining) {
              const basename2 = path.basename(remaining);
              this.segments.unshift(basename2);
              remaining = dir;
              dir = pathHelper.dirname(remaining);
            }
            this.segments.unshift(remaining);
          }
        } else {
          (0, assert_1.default)(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
          for (let i = 0; i < itemPath.length; i++) {
            let segment = itemPath[i];
            (0, assert_1.default)(segment, `Parameter 'itemPath' must not contain any empty segments`);
            segment = pathHelper.normalizeSeparators(itemPath[i]);
            if (i === 0 && pathHelper.hasRoot(segment)) {
              segment = pathHelper.safeTrimTrailingSeparator(segment);
              (0, assert_1.default)(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
              this.segments.push(segment);
            } else {
              (0, assert_1.default)(!segment.includes(path.sep), `Parameter 'itemPath' contains unexpected path separators`);
              this.segments.push(segment);
            }
          }
        }
      }
      /**
       * Converts the path to it's string representation
       */
      toString() {
        let result = this.segments[0];
        let skipSlash = result.endsWith(path.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
        for (let i = 1; i < this.segments.length; i++) {
          if (skipSlash) {
            skipSlash = false;
          } else {
            result += path.sep;
          }
          result += this.segments[i];
        }
        return result;
      }
    };
    exports2.Path = Path;
  }
});

// node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS({
  "node_modules/@actions/glob/lib/internal-pattern.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var os4 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var pathHelper = __importStar(require_internal_path_helper());
    var assert_1 = __importDefault(require("assert"));
    var minimatch_1 = require_minimatch();
    var internal_match_kind_1 = require_internal_match_kind();
    var internal_path_1 = require_internal_path();
    var IS_WINDOWS = process.platform === "win32";
    var Pattern = class _Pattern {
      constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
        this.negate = false;
        let pattern;
        if (typeof patternOrNegate === "string") {
          pattern = patternOrNegate.trim();
        } else {
          segments = segments || [];
          (0, assert_1.default)(segments.length, `Parameter 'segments' must not empty`);
          const root = _Pattern.getLiteral(segments[0]);
          (0, assert_1.default)(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
          pattern = new internal_path_1.Path(segments).toString().trim();
          if (patternOrNegate) {
            pattern = `!${pattern}`;
          }
        }
        while (pattern.startsWith("!")) {
          this.negate = !this.negate;
          pattern = pattern.substr(1).trim();
        }
        pattern = _Pattern.fixupPattern(pattern, homedir);
        this.segments = new internal_path_1.Path(pattern).segments;
        this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        let foundGlob = false;
        const searchSegments = this.segments.map((x) => _Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        this.rootRegExp = new RegExp(_Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
        this.isImplicitPattern = isImplicitPattern;
        const minimatchOptions = {
          dot: true,
          nobrace: true,
          nocase: IS_WINDOWS,
          nocomment: true,
          noext: true,
          nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
      }
      /**
       * Matches the pattern against the specified path
       */
      match(itemPath) {
        if (this.segments[this.segments.length - 1] === "**") {
          itemPath = pathHelper.normalizeSeparators(itemPath);
          if (!itemPath.endsWith(path.sep) && this.isImplicitPattern === false) {
            itemPath = `${itemPath}${path.sep}`;
          }
        } else {
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        if (this.minimatch.match(itemPath)) {
          return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
      }
      /**
       * Indicates whether the pattern may match descendants of the specified path
       */
      partialMatch(itemPath) {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (pathHelper.dirname(itemPath) === itemPath) {
          return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
      }
      /**
       * Escapes glob patterns within a path
       */
      static globEscape(s) {
        return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
      }
      /**
       * Normalizes slashes and ensures absolute root
       */
      static fixupPattern(pattern, homedir) {
        (0, assert_1.default)(pattern, "pattern cannot be empty");
        const literalSegments = new internal_path_1.Path(pattern).segments.map((x) => _Pattern.getLiteral(x));
        (0, assert_1.default)(literalSegments.every((x, i) => (x !== "." || i === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        (0, assert_1.default)(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        pattern = pathHelper.normalizeSeparators(pattern);
        if (pattern === "." || pattern.startsWith(`.${path.sep}`)) {
          pattern = _Pattern.globEscape(process.cwd()) + pattern.substr(1);
        } else if (pattern === "~" || pattern.startsWith(`~${path.sep}`)) {
          homedir = homedir || os4.homedir();
          (0, assert_1.default)(homedir, "Unable to determine HOME directory");
          (0, assert_1.default)(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
          pattern = _Pattern.globEscape(homedir) + pattern.substr(1);
        } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
          let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
          if (pattern.length > 2 && !root.endsWith("\\")) {
            root += "\\";
          }
          pattern = _Pattern.globEscape(root) + pattern.substr(2);
        } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
          let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
          if (!root.endsWith("\\")) {
            root += "\\";
          }
          pattern = _Pattern.globEscape(root) + pattern.substr(1);
        } else {
          pattern = pathHelper.ensureAbsoluteRoot(_Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
      }
      /**
       * Attempts to unescape a pattern segment to create a literal path segment.
       * Otherwise returns empty string.
       */
      static getLiteral(segment) {
        let literal = "";
        for (let i = 0; i < segment.length; i++) {
          const c = segment[i];
          if (c === "\\" && !IS_WINDOWS && i + 1 < segment.length) {
            literal += segment[++i];
            continue;
          } else if (c === "*" || c === "?") {
            return "";
          } else if (c === "[" && i + 1 < segment.length) {
            let set = "";
            let closed = -1;
            for (let i2 = i + 1; i2 < segment.length; i2++) {
              const c2 = segment[i2];
              if (c2 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
                set += segment[++i2];
                continue;
              } else if (c2 === "]") {
                closed = i2;
                break;
              } else {
                set += c2;
              }
            }
            if (closed >= 0) {
              if (set.length > 1) {
                return "";
              }
              if (set) {
                literal += set;
                i = closed;
                continue;
              }
            }
          }
          literal += c;
        }
        return literal;
      }
      /**
       * Escapes regexp special characters
       * https://javascript.info/regexp-escaping
       */
      static regExpEscape(s) {
        return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
      }
    };
    exports2.Pattern = Pattern;
  }
});

// node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS({
  "node_modules/@actions/glob/lib/internal-search-state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SearchState = void 0;
    var SearchState = class {
      constructor(path, level) {
        this.path = path;
        this.level = level;
      }
    };
    exports2.SearchState = SearchState;
  }
});

// node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS({
  "node_modules/@actions/glob/lib/internal-globber.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o[n](v), settle(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve2, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume2(n, v);
          });
        };
      }
      function resume2(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume2("next", value);
      }
      function reject(value) {
        resume2("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume2(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultGlobber = void 0;
    var core4 = __importStar(require_core4());
    var fs = __importStar(require("fs"));
    var globOptionsHelper = __importStar(require_internal_glob_options_helper());
    var path = __importStar(require("path"));
    var patternHelper = __importStar(require_internal_pattern_helper());
    var internal_match_kind_1 = require_internal_match_kind();
    var internal_pattern_1 = require_internal_pattern();
    var internal_search_state_1 = require_internal_search_state();
    var IS_WINDOWS = process.platform === "win32";
    var DefaultGlobber = class _DefaultGlobber {
      constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
      }
      getSearchPaths() {
        return this.searchPaths.slice();
      }
      glob() {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          const result = [];
          try {
            for (var _d = true, _e = __asyncValues(this.globGenerator()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const itemPath = _c;
              result.push(itemPath);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return result;
        });
      }
      globGenerator() {
        return __asyncGenerator(this, arguments, function* globGenerator_1() {
          const options = globOptionsHelper.getOptions(this.options);
          const patterns = [];
          for (const pattern of this.patterns) {
            patterns.push(pattern);
            if (options.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
              patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
            }
          }
          const stack = [];
          for (const searchPath of patternHelper.getSearchPaths(patterns)) {
            core4.debug(`Search path '${searchPath}'`);
            try {
              yield __await(fs.promises.lstat(searchPath));
            } catch (err) {
              if (err.code === "ENOENT") {
                continue;
              }
              throw err;
            }
            stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
          }
          const traversalChain = [];
          while (stack.length) {
            const item = stack.pop();
            const match = patternHelper.match(patterns, item.path);
            const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
            if (!match && !partialMatch) {
              continue;
            }
            const stats = yield __await(
              _DefaultGlobber.stat(item, options, traversalChain)
              // Broken symlink, or symlink cycle detected, or no longer exists
            );
            if (!stats) {
              continue;
            }
            if (options.excludeHiddenFiles && path.basename(item.path).match(/^\./)) {
              continue;
            }
            if (stats.isDirectory()) {
              if (match & internal_match_kind_1.MatchKind.Directory && options.matchDirectories) {
                yield yield __await(item.path);
              } else if (!partialMatch) {
                continue;
              }
              const childLevel = item.level + 1;
              const childItems = (yield __await(fs.promises.readdir(item.path))).map((x) => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
              stack.push(...childItems.reverse());
            } else if (match & internal_match_kind_1.MatchKind.File) {
              yield yield __await(item.path);
            }
          }
        });
      }
      /**
       * Constructs a DefaultGlobber
       */
      static create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = new _DefaultGlobber(options);
          if (IS_WINDOWS) {
            patterns = patterns.replace(/\r\n/g, "\n");
            patterns = patterns.replace(/\r/g, "\n");
          }
          const lines = patterns.split("\n").map((x) => x.trim());
          for (const line of lines) {
            if (!line || line.startsWith("#")) {
              continue;
            } else {
              result.patterns.push(new internal_pattern_1.Pattern(line));
            }
          }
          result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
          return result;
        });
      }
      static stat(item, options, traversalChain) {
        return __awaiter(this, void 0, void 0, function* () {
          let stats;
          if (options.followSymbolicLinks) {
            try {
              stats = yield fs.promises.stat(item.path);
            } catch (err) {
              if (err.code === "ENOENT") {
                if (options.omitBrokenSymbolicLinks) {
                  core4.debug(`Broken symlink '${item.path}'`);
                  return void 0;
                }
                throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
              }
              throw err;
            }
          } else {
            stats = yield fs.promises.lstat(item.path);
          }
          if (stats.isDirectory() && options.followSymbolicLinks) {
            const realPath = yield fs.promises.realpath(item.path);
            while (traversalChain.length >= item.level) {
              traversalChain.pop();
            }
            if (traversalChain.some((x) => x === realPath)) {
              core4.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
              return void 0;
            }
            traversalChain.push(realPath);
          }
          return stats;
        });
      }
    };
    exports2.DefaultGlobber = DefaultGlobber;
  }
});

// node_modules/@actions/glob/lib/internal-hash-files.js
var require_internal_hash_files = __commonJS({
  "node_modules/@actions/glob/lib/internal-hash-files.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o[n](v), settle(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve2, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashFiles = void 0;
    var crypto = __importStar(require("crypto"));
    var core4 = __importStar(require_core4());
    var fs = __importStar(require("fs"));
    var stream = __importStar(require("stream"));
    var util3 = __importStar(require("util"));
    var path = __importStar(require("path"));
    function hashFiles(globber, currentWorkspace, verbose = false) {
      var _a, e_1, _b, _c;
      var _d;
      return __awaiter(this, void 0, void 0, function* () {
        const writeDelegate = verbose ? core4.info : core4.debug;
        let hasMatch = false;
        const githubWorkspace = currentWorkspace ? currentWorkspace : (_d = process.env["GITHUB_WORKSPACE"]) !== null && _d !== void 0 ? _d : process.cwd();
        const result = crypto.createHash("sha256");
        let count = 0;
        try {
          for (var _e = true, _f = __asyncValues(globber.globGenerator()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {
            _c = _g.value;
            _e = false;
            const file = _c;
            writeDelegate(file);
            if (!file.startsWith(`${githubWorkspace}${path.sep}`)) {
              writeDelegate(`Ignore '${file}' since it is not under GITHUB_WORKSPACE.`);
              continue;
            }
            if (fs.statSync(file).isDirectory()) {
              writeDelegate(`Skip directory '${file}'.`);
              continue;
            }
            const hash = crypto.createHash("sha256");
            const pipeline = util3.promisify(stream.pipeline);
            yield pipeline(fs.createReadStream(file), hash);
            result.write(hash.digest());
            count++;
            if (!hasMatch) {
              hasMatch = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        result.end();
        if (hasMatch) {
          writeDelegate(`Found ${count} files to hash.`);
          return result.digest("hex");
        } else {
          writeDelegate(`No matches found for glob`);
          return "";
        }
      });
    }
    exports2.hashFiles = hashFiles;
  }
});

// node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS({
  "node_modules/@actions/glob/lib/glob.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashFiles = exports2.create = void 0;
    var internal_globber_1 = require_internal_globber();
    var internal_hash_files_1 = require_internal_hash_files();
    function create2(patterns, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
      });
    }
    exports2.create = create2;
    function hashFiles(patterns, currentWorkspace = "", options, verbose = false) {
      return __awaiter(this, void 0, void 0, function* () {
        let followSymbolicLinks = true;
        if (options && typeof options.followSymbolicLinks === "boolean") {
          followSymbolicLinks = options.followSymbolicLinks;
        }
        const globber = yield create2(patterns, { followSymbolicLinks });
        return (0, internal_hash_files_1.hashFiles)(globber, currentWorkspace, verbose);
      });
    }
    exports2.hashFiles = hashFiles;
  }
});

// node_modules/@actions/github/lib/context.js
var require_context = __commonJS({
  "node_modules/@actions/github/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Context = void 0;
    var fs_1 = require("fs");
    var os_1 = require("os");
    var Context = class {
      /**
       * Hydrate the context from the environment
       */
      constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
          if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
            this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
          } else {
            const path = process.env.GITHUB_EVENT_PATH;
            process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
          }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
      }
      get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
      }
      get repo() {
        if (process.env.GITHUB_REPOSITORY) {
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
          return { owner, repo };
        }
        if (this.payload.repository) {
          return {
            owner: this.payload.repository.owner.login,
            repo: this.payload.repository.name
          };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
      }
    };
    exports2.Context = Context;
  }
});

// node_modules/@actions/github/lib/internal/utils.js
var require_utils22 = __commonJS({
  "node_modules/@actions/github/lib/internal/utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getApiBaseUrl = exports2.getProxyFetch = exports2.getProxyAgentDispatcher = exports2.getProxyAgent = exports2.getAuthString = void 0;
    var httpClient = __importStar(require_lib());
    var undici_1 = require_undici2();
    function getAuthString(token, options) {
      if (!token && !options.auth) {
        throw new Error("Parameter token or opts.auth is required");
      } else if (token && options.auth) {
        throw new Error("Parameters token and opts.auth may not both be specified");
      }
      return typeof options.auth === "string" ? options.auth : `token ${token}`;
    }
    exports2.getAuthString = getAuthString;
    function getProxyAgent(destinationUrl) {
      const hc = new httpClient.HttpClient();
      return hc.getAgent(destinationUrl);
    }
    exports2.getProxyAgent = getProxyAgent;
    function getProxyAgentDispatcher(destinationUrl) {
      const hc = new httpClient.HttpClient();
      return hc.getAgentDispatcher(destinationUrl);
    }
    exports2.getProxyAgentDispatcher = getProxyAgentDispatcher;
    function getProxyFetch(destinationUrl) {
      const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
      const proxyFetch = (url2, opts) => __awaiter(this, void 0, void 0, function* () {
        return (0, undici_1.fetch)(url2, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
      });
      return proxyFetch;
    }
    exports2.getProxyFetch = getProxyFetch;
    function getApiBaseUrl() {
      return process.env["GITHUB_API_URL"] || "https://api.github.com";
    }
    exports2.getApiBaseUrl = getApiBaseUrl;
  }
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS({
  "node_modules/universal-user-agent/dist-node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function getUserAgent() {
      if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
      }
      if (typeof process === "object" && process.version !== void 0) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
      }
      return "<environment undetectable>";
    }
    exports2.getUserAgent = getUserAgent;
  }
});

// node_modules/before-after-hook/lib/register.js
var require_register2 = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports2, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports2, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook) {
      var orig = hook;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name].push({
        hook,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports2, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports2, module2) {
    var register = require_register2();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(
        null,
        name ? [state, name] : [state]
      );
      hook.api = { remove: removeHookRef };
      hook.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook = register.bind(null, state);
      bindApi(hook, state);
      return hook;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn(
          '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
        );
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node2 = __commonJS({
  "node_modules/@octokit/endpoint/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      endpoint: () => endpoint
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_universal_user_agent = require_dist_node();
    var VERSION5 = "9.0.6";
    var userAgent = `octokit-endpoint.js/${VERSION5} ${(0, import_universal_user_agent.getUserAgent)()}`;
    var DEFAULTS = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
      },
      mediaType: {
        format: ""
      }
    };
    function lowercaseKeys(object) {
      if (!object) {
        return {};
      }
      return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
      }, {});
    }
    function isPlainObject2(value) {
      if (typeof value !== "object" || value === null)
        return false;
      if (Object.prototype.toString.call(value) !== "[object Object]")
        return false;
      const proto = Object.getPrototypeOf(value);
      if (proto === null)
        return true;
      const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
    }
    function mergeDeep(defaults, options) {
      const result = Object.assign({}, defaults);
      Object.keys(options).forEach((key) => {
        if (isPlainObject2(options[key])) {
          if (!(key in defaults))
            Object.assign(result, { [key]: options[key] });
          else
            result[key] = mergeDeep(defaults[key], options[key]);
        } else {
          Object.assign(result, { [key]: options[key] });
        }
      });
      return result;
    }
    function removeUndefinedProperties(obj) {
      for (const key in obj) {
        if (obj[key] === void 0) {
          delete obj[key];
        }
      }
      return obj;
    }
    function merge2(defaults, route, options) {
      if (typeof route === "string") {
        let [method, url2] = route.split(" ");
        options = Object.assign(url2 ? { method, url: url2 } : { url: method }, options);
      } else {
        options = Object.assign({}, route);
      }
      options.headers = lowercaseKeys(options.headers);
      removeUndefinedProperties(options);
      removeUndefinedProperties(options.headers);
      const mergedOptions = mergeDeep(defaults || {}, options);
      if (options.url === "/graphql") {
        if (defaults && defaults.mediaType.previews?.length) {
          mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
            (preview) => !mergedOptions.mediaType.previews.includes(preview)
          ).concat(mergedOptions.mediaType.previews);
        }
        mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
      }
      return mergedOptions;
    }
    function addQueryParameters(url2, parameters) {
      const separator = /\?/.test(url2) ? "&" : "?";
      const names = Object.keys(parameters);
      if (names.length === 0) {
        return url2;
      }
      return url2 + separator + names.map((name) => {
        if (name === "q") {
          return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
      }).join("&");
    }
    var urlVariableRegex = /\{[^{}}]+\}/g;
    function removeNonChars(variableName) {
      return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
    }
    function extractUrlVariableNames(url2) {
      const matches = url2.match(urlVariableRegex);
      if (!matches) {
        return [];
      }
      return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
    }
    function omit2(object, keysToOmit) {
      const result = { __proto__: null };
      for (const key of Object.keys(object)) {
        if (keysToOmit.indexOf(key) === -1) {
          result[key] = object[key];
        }
      }
      return result;
    }
    function encodeReserved(str) {
      return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
          part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
      }).join("");
    }
    function encodeUnreserved(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeValue(operator, value, key) {
      value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
      if (key) {
        return encodeUnreserved(key) + "=" + value;
      } else {
        return value;
      }
    }
    function isDefined(value) {
      return value !== void 0 && value !== null;
    }
    function isKeyOperator(operator) {
      return operator === ";" || operator === "&" || operator === "?";
    }
    function getValues(context3, operator, key, modifier) {
      var value = context3[key], result = [];
      if (isDefined(value) && value !== "") {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          value = value.toString();
          if (modifier && modifier !== "*") {
            value = value.substring(0, parseInt(modifier, 10));
          }
          result.push(
            encodeValue(operator, value, isKeyOperator(operator) ? key : "")
          );
        } else {
          if (modifier === "*") {
            if (Array.isArray(value)) {
              value.filter(isDefined).forEach(function(value2) {
                result.push(
                  encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
                );
              });
            } else {
              Object.keys(value).forEach(function(k) {
                if (isDefined(value[k])) {
                  result.push(encodeValue(operator, value[k], k));
                }
              });
            }
          } else {
            const tmp = [];
            if (Array.isArray(value)) {
              value.filter(isDefined).forEach(function(value2) {
                tmp.push(encodeValue(operator, value2));
              });
            } else {
              Object.keys(value).forEach(function(k) {
                if (isDefined(value[k])) {
                  tmp.push(encodeUnreserved(k));
                  tmp.push(encodeValue(operator, value[k].toString()));
                }
              });
            }
            if (isKeyOperator(operator)) {
              result.push(encodeUnreserved(key) + "=" + tmp.join(","));
            } else if (tmp.length !== 0) {
              result.push(tmp.join(","));
            }
          }
        }
      } else {
        if (operator === ";") {
          if (isDefined(value)) {
            result.push(encodeUnreserved(key));
          }
        } else if (value === "" && (operator === "&" || operator === "?")) {
          result.push(encodeUnreserved(key) + "=");
        } else if (value === "") {
          result.push("");
        }
      }
      return result;
    }
    function parseUrl2(template) {
      return {
        expand: expand.bind(null, template)
      };
    }
    function expand(template, context3) {
      var operators = ["+", "#", ".", "/", ";", "?", "&"];
      template = template.replace(
        /\{([^\{\}]+)\}|([^\{\}]+)/g,
        function(_, expression, literal) {
          if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
              operator = expression.charAt(0);
              expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function(variable) {
              var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
              values.push(getValues(context3, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
              var separator = ",";
              if (operator === "?") {
                separator = "&";
              } else if (operator !== "#") {
                separator = operator;
              }
              return (values.length !== 0 ? operator : "") + values.join(separator);
            } else {
              return values.join(",");
            }
          } else {
            return encodeReserved(literal);
          }
        }
      );
      if (template === "/") {
        return template;
      } else {
        return template.replace(/\/$/, "");
      }
    }
    function parse(options) {
      let method = options.method.toUpperCase();
      let url2 = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
      let headers = Object.assign({}, options.headers);
      let body;
      let parameters = omit2(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType"
      ]);
      const urlVariableNames = extractUrlVariableNames(url2);
      url2 = parseUrl2(url2).expand(parameters);
      if (!/^http/.test(url2)) {
        url2 = options.baseUrl + url2;
      }
      const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
      const remainingParameters = omit2(parameters, omittedParameters);
      const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
      if (!isBinaryRequest) {
        if (options.mediaType.format) {
          headers.accept = headers.accept.split(/,/).map(
            (format2) => format2.replace(
              /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
              `application/vnd$1$2.${options.mediaType.format}`
            )
          ).join(",");
        }
        if (url2.endsWith("/graphql")) {
          if (options.mediaType.previews?.length) {
            const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
            headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
              const format2 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
              return `application/vnd.github.${preview}-preview${format2}`;
            }).join(",");
          }
        }
      }
      if (["GET", "HEAD"].includes(method)) {
        url2 = addQueryParameters(url2, remainingParameters);
      } else {
        if ("data" in remainingParameters) {
          body = remainingParameters.data;
        } else {
          if (Object.keys(remainingParameters).length) {
            body = remainingParameters;
          }
        }
      }
      if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
      }
      if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
      }
      return Object.assign(
        { method, url: url2, headers },
        typeof body !== "undefined" ? { body } : null,
        options.request ? { request: options.request } : null
      );
    }
    function endpointWithDefaults(defaults, route, options) {
      return parse(merge2(defaults, route, options));
    }
    function withDefaults(oldDefaults, newDefaults) {
      const DEFAULTS2 = merge2(oldDefaults, newDefaults);
      const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
      return Object.assign(endpoint2, {
        DEFAULTS: DEFAULTS2,
        defaults: withDefaults.bind(null, DEFAULTS2),
        merge: merge2.bind(null, DEFAULTS2),
        parse
      });
    }
    var endpoint = withDefaults(null, DEFAULTS);
  }
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node3 = __commonJS({
  "node_modules/deprecation/dist-node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Deprecation = class extends Error {
      constructor(message) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "Deprecation";
      }
    };
    exports2.Deprecation = Deprecation;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node4 = __commonJS({
  "node_modules/@octokit/request-error/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      RequestError: () => RequestError
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_deprecation = require_dist_node3();
    var import_once = __toESM2(require_once());
    var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
    var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
    var RequestError = class extends Error {
      constructor(message, statusCode, options) {
        super(message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
          headers = options.headers;
        }
        if ("response" in options) {
          this.response = options.response;
          headers = options.response.headers;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(
              /(?<! ) .*$/,
              " [REDACTED]"
            )
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        Object.defineProperty(this, "code", {
          get() {
            logOnceCode(
              new import_deprecation.Deprecation(
                "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
              )
            );
            return statusCode;
          }
        });
        Object.defineProperty(this, "headers", {
          get() {
            logOnceHeaders(
              new import_deprecation.Deprecation(
                "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
              )
            );
            return headers || {};
          }
        });
      }
    };
  }
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node5 = __commonJS({
  "node_modules/@octokit/request/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      request: () => request
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_endpoint = require_dist_node2();
    var import_universal_user_agent = require_dist_node();
    var VERSION5 = "8.4.1";
    function isPlainObject2(value) {
      if (typeof value !== "object" || value === null)
        return false;
      if (Object.prototype.toString.call(value) !== "[object Object]")
        return false;
      const proto = Object.getPrototypeOf(value);
      if (proto === null)
        return true;
      const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
    }
    var import_request_error = require_dist_node4();
    function getBufferResponse(response) {
      return response.arrayBuffer();
    }
    function fetchWrapper(requestOptions) {
      var _a, _b, _c, _d;
      const log2 = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
      const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
      if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
      }
      let headers = {};
      let status;
      let url2;
      let { fetch } = globalThis;
      if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
        fetch = requestOptions.request.fetch;
      }
      if (!fetch) {
        throw new Error(
          "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
        );
      }
      return fetch(requestOptions.url, {
        method: requestOptions.method,
        body: requestOptions.body,
        redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
        headers: requestOptions.headers,
        signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
        // duplex must be set if request.body is ReadableStream or Async Iterables.
        // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
        ...requestOptions.body && { duplex: "half" }
      }).then(async (response) => {
        url2 = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
          headers[keyAndValue[0]] = keyAndValue[1];
        }
        if ("deprecation" in headers) {
          const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
          const deprecationLink = matches && matches.pop();
          log2.warn(
            `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
          );
        }
        if (status === 204 || status === 205) {
          return;
        }
        if (requestOptions.method === "HEAD") {
          if (status < 400) {
            return;
          }
          throw new import_request_error.RequestError(response.statusText, status, {
            response: {
              url: url2,
              status,
              headers,
              data: void 0
            },
            request: requestOptions
          });
        }
        if (status === 304) {
          throw new import_request_error.RequestError("Not modified", status, {
            response: {
              url: url2,
              status,
              headers,
              data: await getResponseData(response)
            },
            request: requestOptions
          });
        }
        if (status >= 400) {
          const data = await getResponseData(response);
          const error = new import_request_error.RequestError(toErrorMessage(data), status, {
            response: {
              url: url2,
              status,
              headers,
              data
            },
            request: requestOptions
          });
          throw error;
        }
        return parseSuccessResponseBody ? await getResponseData(response) : response.body;
      }).then((data) => {
        return {
          status,
          url: url2,
          headers,
          data
        };
      }).catch((error) => {
        if (error instanceof import_request_error.RequestError)
          throw error;
        else if (error.name === "AbortError")
          throw error;
        let message = error.message;
        if (error.name === "TypeError" && "cause" in error) {
          if (error.cause instanceof Error) {
            message = error.cause.message;
          } else if (typeof error.cause === "string") {
            message = error.cause;
          }
        }
        throw new import_request_error.RequestError(message, 500, {
          request: requestOptions
        });
      });
    }
    async function getResponseData(response) {
      const contentType = response.headers.get("content-type");
      if (/application\/json/.test(contentType)) {
        return response.json().catch(() => response.text()).catch(() => "");
      }
      if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
      }
      return getBufferResponse(response);
    }
    function toErrorMessage(data) {
      if (typeof data === "string")
        return data;
      let suffix;
      if ("documentation_url" in data) {
        suffix = ` - ${data.documentation_url}`;
      } else {
        suffix = "";
      }
      if ("message" in data) {
        if (Array.isArray(data.errors)) {
          return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
        }
        return `${data.message}${suffix}`;
      }
      return `Unknown error: ${JSON.stringify(data)}`;
    }
    function withDefaults(oldEndpoint, newDefaults) {
      const endpoint2 = oldEndpoint.defaults(newDefaults);
      const newApi = function(route, parameters) {
        const endpointOptions = endpoint2.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
          return fetchWrapper(endpoint2.parse(endpointOptions));
        }
        const request2 = (route2, parameters2) => {
          return fetchWrapper(
            endpoint2.parse(endpoint2.merge(route2, parameters2))
          );
        };
        Object.assign(request2, {
          endpoint: endpoint2,
          defaults: withDefaults.bind(null, endpoint2)
        });
        return endpointOptions.request.hook(request2, endpointOptions);
      };
      return Object.assign(newApi, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
    }
    var request = withDefaults(import_endpoint.endpoint, {
      headers: {
        "user-agent": `octokit-request.js/${VERSION5} ${(0, import_universal_user_agent.getUserAgent)()}`
      }
    });
  }
});

// node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node6 = __commonJS({
  "node_modules/@octokit/graphql/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      GraphqlResponseError: () => GraphqlResponseError,
      graphql: () => graphql2,
      withCustomRequest: () => withCustomRequest
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_request3 = require_dist_node5();
    var import_universal_user_agent = require_dist_node();
    var VERSION5 = "7.1.0";
    var import_request2 = require_dist_node5();
    var import_request4 = require_dist_node5();
    function _buildMessageForResponseErrors(data) {
      return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
    }
    var GraphqlResponseError = class extends Error {
      constructor(request2, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    var NON_VARIABLE_OPTIONS = [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "query",
      "mediaType"
    ];
    var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
    var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
    function graphql(request2, query, options) {
      if (options) {
        if (typeof query === "string" && "query" in options) {
          return Promise.reject(
            new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
          );
        }
        for (const key in options) {
          if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
            continue;
          return Promise.reject(
            new Error(
              `[@octokit/graphql] "${key}" cannot be used as variable name`
            )
          );
        }
      }
      const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
      const requestOptions = Object.keys(
        parsedOptions
      ).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS.includes(key)) {
          result[key] = parsedOptions[key];
          return result;
        }
        if (!result.variables) {
          result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
      }, {});
      const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
      if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
      }
      return request2(requestOptions).then((response) => {
        if (response.data.errors) {
          const headers = {};
          for (const key of Object.keys(response.headers)) {
            headers[key] = response.headers[key];
          }
          throw new GraphqlResponseError(
            requestOptions,
            headers,
            response.data
          );
        }
        return response.data.data;
      });
    }
    function withDefaults(request2, newDefaults) {
      const newRequest = request2.defaults(newDefaults);
      const newApi = (query, options) => {
        return graphql(newRequest, query, options);
      };
      return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: newRequest.endpoint
      });
    }
    var graphql2 = withDefaults(import_request3.request, {
      headers: {
        "user-agent": `octokit-graphql.js/${VERSION5} ${(0, import_universal_user_agent.getUserAgent)()}`
      },
      method: "POST",
      url: "/graphql"
    });
    function withCustomRequest(customRequest) {
      return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql"
      });
    }
  }
});

// node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node7 = __commonJS({
  "node_modules/@octokit/auth-token/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      createTokenAuth: () => createTokenAuth
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
    var REGEX_IS_INSTALLATION = /^ghs_/;
    var REGEX_IS_USER_TO_SERVER = /^ghu_/;
    async function auth(token) {
      const isApp = token.split(/\./).length === 3;
      const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
      const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
      const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
      return {
        type: "token",
        token,
        tokenType
      };
    }
    function withAuthorizationPrefix(token) {
      if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
      }
      return `token ${token}`;
    }
    async function hook(token, request, route, parameters) {
      const endpoint = request.endpoint.merge(
        route,
        parameters
      );
      endpoint.headers.authorization = withAuthorizationPrefix(token);
      return request(endpoint);
    }
    var createTokenAuth = function createTokenAuth2(token) {
      if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof token !== "string") {
        throw new Error(
          "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
        );
      }
      token = token.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token)
      });
    };
  }
});

// node_modules/@octokit/core/dist-node/index.js
var require_dist_node8 = __commonJS({
  "node_modules/@octokit/core/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      Octokit: () => Octokit
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var import_universal_user_agent = require_dist_node();
    var import_before_after_hook = require_before_after_hook();
    var import_request2 = require_dist_node5();
    var import_graphql2 = require_dist_node6();
    var import_auth_token = require_dist_node7();
    var VERSION5 = "5.2.0";
    var noop = () => {
    };
    var consoleWarn = console.warn.bind(console);
    var consoleError = console.error.bind(console);
    var userAgentTrail = `octokit-core.js/${VERSION5} ${(0, import_universal_user_agent.getUserAgent)()}`;
    var _a;
    var Octokit = (_a = class {
      static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
          constructor(...args) {
            const options = args[0] || {};
            if (typeof defaults === "function") {
              super(defaults(options));
              return;
            }
            super(
              Object.assign(
                {},
                defaults,
                options,
                options.userAgent && defaults.userAgent ? {
                  userAgent: `${options.userAgent} ${defaults.userAgent}`
                } : null
              )
            );
          }
        };
        return OctokitWithDefaults;
      }
      /**
       * Attach a plugin (or many) to your Octokit instance.
       *
       * @example
       * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
       */
      static plugin(...newPlugins) {
        var _a2;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a2 = class extends this {
        }, _a2.plugins = currentPlugins.concat(
          newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
        ), _a2);
        return NewOctokit;
      }
      constructor(options = {}) {
        const hook = new import_before_after_hook.Collection();
        const requestDefaults = {
          baseUrl: import_request2.request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, options.request, {
            // @ts-ignore internal usage only, no need to type
            hook: hook.bind(null, "request")
          }),
          mediaType: {
            previews: [],
            format: ""
          }
        };
        requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
        if (options.baseUrl) {
          requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
          requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
          requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = import_request2.request.defaults(requestDefaults);
        this.graphql = (0, import_graphql2.withCustomRequest)(this.request).defaults(requestDefaults);
        this.log = Object.assign(
          {
            debug: noop,
            info: noop,
            warn: consoleWarn,
            error: consoleError
          },
          options.log
        );
        this.hook = hook;
        if (!options.authStrategy) {
          if (!options.auth) {
            this.auth = async () => ({
              type: "unauthenticated"
            });
          } else {
            const auth = (0, import_auth_token.createTokenAuth)(options.auth);
            hook.wrap("request", auth.hook);
            this.auth = auth;
          }
        } else {
          const { authStrategy, ...otherOptions } = options;
          const auth = authStrategy(
            Object.assign(
              {
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions
              },
              options.auth
            )
          );
          hook.wrap("request", auth.hook);
          this.auth = auth;
        }
        const classConstructor = this.constructor;
        for (let i = 0; i < classConstructor.plugins.length; ++i) {
          Object.assign(this, classConstructor.plugins[i](this, options));
        }
      }
    }, _a.VERSION = VERSION5, _a.plugins = [], _a);
  }
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node9 = __commonJS({
  "node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      legacyRestEndpointMethods: () => legacyRestEndpointMethods,
      restEndpointMethods: () => restEndpointMethods
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var VERSION5 = "10.4.1";
    var Endpoints = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
          "POST /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        approveWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
        ],
        cancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
        ],
        createEnvironmentVariable: [
          "POST /repositories/{repository_id}/environments/{environment_name}/variables"
        ],
        createOrUpdateEnvironmentSecret: [
          "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        createOrgVariable: ["POST /orgs/{org}/actions/variables"],
        createRegistrationTokenForOrg: [
          "POST /orgs/{org}/actions/runners/registration-token"
        ],
        createRegistrationTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/registration-token"
        ],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/remove-token"
        ],
        createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
        createWorkflowDispatch: [
          "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        ],
        deleteActionsCacheById: [
          "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
        ],
        deleteActionsCacheByKey: [
          "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
        ],
        deleteArtifact: [
          "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        deleteEnvironmentSecret: [
          "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        deleteEnvironmentVariable: [
          "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        deleteRepoVariable: [
          "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        deleteSelfHostedRunnerFromOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}"
        ],
        deleteSelfHostedRunnerFromRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: [
          "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
          "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        disableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
        ],
        downloadArtifact: [
          "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
        ],
        downloadJobLogsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
        ],
        downloadWorkflowRunAttemptLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
        ],
        downloadWorkflowRunLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        enableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
        ],
        forceCancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
        ],
        generateRunnerJitconfigForOrg: [
          "POST /orgs/{org}/actions/runners/generate-jitconfig"
        ],
        generateRunnerJitconfigForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
        ],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: [
          "GET /orgs/{org}/actions/cache/usage-by-repository"
        ],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/selected-actions"
        ],
        getAllowedActionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getCustomOidcSubClaimForRepo: [
          "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        getEnvironmentPublicKey: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
        ],
        getEnvironmentSecret: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
        ],
        getEnvironmentVariable: [
          "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions/workflow"
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        getGithubActionsPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions"
        ],
        getGithubActionsPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions"
        ],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
        getPendingDeploymentsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        getRepoPermissions: [
          "GET /repos/{owner}/{repo}/actions/permissions",
          {},
          { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
        ],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
        getReviewsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
        ],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/access"
        ],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
        ],
        getWorkflowRunUsage: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
        ],
        getWorkflowUsage: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
        ],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: [
          "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
        ],
        listEnvironmentVariables: [
          "GET /repositories/{repository_id}/environments/{environment_name}/variables"
        ],
        listJobsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        ],
        listJobsForWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
        ],
        listLabelsForSelfHostedRunnerForOrg: [
          "GET /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        listLabelsForSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listOrgVariables: ["GET /orgs/{org}/actions/variables"],
        listRepoOrganizationSecrets: [
          "GET /repos/{owner}/{repo}/actions/organization-secrets"
        ],
        listRepoOrganizationVariables: [
          "GET /repos/{owner}/{repo}/actions/organization-variables"
        ],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/downloads"
        ],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        listSelectedReposForOrgVariable: [
          "GET /orgs/{org}/actions/variables/{name}/repositories"
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/repositories"
        ],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
        ],
        listWorkflowRuns: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
        ],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
        ],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgVariable: [
          "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        reviewCustomGatesForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
        ],
        reviewPendingDeploymentsForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        setAllowedActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/selected-actions"
        ],
        setAllowedActionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
          "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
          "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        setCustomOidcSubClaimForRepo: [
          "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/workflow"
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        setGithubActionsPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions"
        ],
        setGithubActionsPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories"
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories"
        ],
        setWorkflowAccessToRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/access"
        ],
        updateEnvironmentVariable: [
          "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
        ],
        updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
        updateRepoVariable: [
          "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
        ]
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: [
          "DELETE /notifications/threads/{thread_id}/subscription"
        ],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: [
          "GET /notifications/threads/{thread_id}/subscription"
        ],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: [
          "GET /users/{username}/events/orgs/{org}"
        ],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: [
          "GET /users/{username}/received_events/public"
        ],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/notifications"
        ],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: [
          "PUT /notifications/threads/{thread_id}/subscription"
        ],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
      },
      apps: {
        addRepoToInstallation: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
        ],
        addRepoToInstallationForAuthenticatedUser: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: [
          "POST /app/installations/{installation_id}/access_tokens"
        ],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: [
          "GET /marketplace_listing/accounts/{account_id}"
        ],
        getSubscriptionPlanForAccountStubbed: [
          "GET /marketplace_listing/stubbed/accounts/{account_id}"
        ],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: [
          "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
        ],
        listInstallationReposForAuthenticatedUser: [
          "GET /user/installations/{installation_id}/repositories"
        ],
        listInstallationRequestsForAuthenticatedApp: [
          "GET /app/installation-requests"
        ],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: [
          "GET /user/marketplace_purchases/stubbed"
        ],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: [
          "POST /app/hook/deliveries/{delivery_id}/attempts"
        ],
        removeRepoFromInstallation: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: [
          "DELETE /app/installations/{installation_id}/suspended"
        ],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"]
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: [
          "GET /users/{username}/settings/billing/actions"
        ],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: [
          "GET /users/{username}/settings/billing/packages"
        ],
        getSharedStorageBillingOrg: [
          "GET /orgs/{org}/settings/billing/shared-storage"
        ],
        getSharedStorageBillingUser: [
          "GET /users/{username}/settings/billing/shared-storage"
        ]
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: [
          "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
        ],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: [
          "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
        ],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: [
          "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
        ],
        rerequestSuite: [
          "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
        ],
        setSuitesPreferences: [
          "PATCH /repos/{owner}/{repo}/check-suites/preferences"
        ],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
      },
      codeScanning: {
        deleteAnalysis: [
          "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
        ],
        getAlert: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
          {},
          { renamedParameters: { alert_id: "alert_number" } }
        ],
        getAnalysis: [
          "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        ],
        getCodeqlDatabase: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          {},
          { renamed: ["codeScanning", "listAlertInstances"] }
        ],
        listCodeqlDatabases: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
        ],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        ],
        updateDefaultSetup: [
          "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
      },
      codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"]
      },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        checkPermissionsForDevcontainer: [
          "GET /repos/{owner}/{repo}/codespaces/permissions_check"
        ],
        codespaceMachinesForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/machines"
        ],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}"
        ],
        createWithPrForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
        ],
        createWithRepoForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/codespaces"
        ],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: [
          "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        deleteSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}"
        ],
        exportForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/exports"
        ],
        getCodespacesForUserInOrg: [
          "GET /orgs/{org}/members/{username}/codespaces"
        ],
        getExportDetailsForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/exports/{export_id}"
        ],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
        getPublicKeyForAuthenticatedUser: [
          "GET /user/codespaces/secrets/public-key"
        ],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        getSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}"
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/devcontainers"
        ],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: [
          "GET /orgs/{org}/codespaces",
          {},
          { renamedParameters: { org_id: "org" } }
        ],
        listInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces"
        ],
        listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}/repositories"
        ],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        preFlightWithRepoForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/new"
        ],
        publishForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/publish"
        ],
        removeRepositoryForSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        repoMachinesForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/machines"
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: [
          "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
        ],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
      },
      copilot: {
        addCopilotSeatsForTeams: [
          "POST /orgs/{org}/copilot/billing/selected_teams"
        ],
        addCopilotSeatsForUsers: [
          "POST /orgs/{org}/copilot/billing/selected_users"
        ],
        cancelCopilotSeatAssignmentForTeams: [
          "DELETE /orgs/{org}/copilot/billing/selected_teams"
        ],
        cancelCopilotSeatAssignmentForUsers: [
          "DELETE /orgs/{org}/copilot/billing/selected_users"
        ],
        getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
        getCopilotSeatDetailsForUser: [
          "GET /orgs/{org}/members/{username}/copilot"
        ],
        listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
      },
      dependabot: {
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/dependabot/alerts"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ]
      },
      dependencyGraph: {
        createRepositorySnapshot: [
          "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
        ],
        diffRange: [
          "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
        ],
        exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
      },
      emojis: { get: ["GET /emojis"] },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
      },
      gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"]
      },
      interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: [
          "GET /user/interaction-limits",
          {},
          { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
        ],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: [
          "DELETE /repos/{owner}/{repo}/interaction-limits"
        ],
        removeRestrictionsForYourPublicRepos: [
          "DELETE /user/interaction-limits",
          {},
          { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
        ],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: [
          "PUT /user/interaction-limits",
          {},
          { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
        ]
      },
      issues: {
        addAssignees: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        checkUserCanBeAssignedToIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
        ],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: [
          "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
        ],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: [
          "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
        ],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        removeAssignees: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        removeLabel: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
        ],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: [
          "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
        ]
      },
      licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"]
      },
      markdown: {
        render: ["POST /markdown"],
        renderRaw: [
          "POST /markdown/raw",
          { headers: { "content-type": "text/plain; charset=utf-8" } }
        ]
      },
      meta: {
        get: ["GET /meta"],
        getAllVersions: ["GET /versions"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"]
      },
      migrations: {
        cancelImport: [
          "DELETE /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
          }
        ],
        deleteArchiveForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/archive"
        ],
        deleteArchiveForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/archive"
        ],
        downloadArchiveForOrg: [
          "GET /orgs/{org}/migrations/{migration_id}/archive"
        ],
        getArchiveForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/archive"
        ],
        getCommitAuthors: [
          "GET /repos/{owner}/{repo}/import/authors",
          {},
          {
            deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
          }
        ],
        getImportStatus: [
          "GET /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
          }
        ],
        getLargeFiles: [
          "GET /repos/{owner}/{repo}/import/large_files",
          {},
          {
            deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
          }
        ],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/repositories"
        ],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: [
          "GET /user/migrations/{migration_id}/repositories",
          {},
          { renamed: ["migrations", "listReposForAuthenticatedUser"] }
        ],
        mapCommitAuthor: [
          "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
          {},
          {
            deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
          }
        ],
        setLfsPreference: [
          "PATCH /repos/{owner}/{repo}/import/lfs",
          {},
          {
            deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
          }
        ],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: [
          "PUT /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
          }
        ],
        unlockRepoForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        unlockRepoForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        updateImport: [
          "PATCH /repos/{owner}/{repo}/import",
          {},
          {
            deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
          }
        ]
      },
      oidc: {
        getOidcCustomSubTemplateForOrg: [
          "GET /orgs/{org}/actions/oidc/customization/sub"
        ],
        updateOidcCustomSubTemplateForOrg: [
          "PUT /orgs/{org}/actions/oidc/customization/sub"
        ]
      },
      orgs: {
        addSecurityManagerTeam: [
          "PUT /orgs/{org}/security-managers/teams/{team_slug}"
        ],
        assignTeamToOrgRole: [
          "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        assignUserToOrgRole: [
          "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: [
          "PUT /orgs/{org}/outside_collaborators/{username}"
        ],
        createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
        createOrUpdateCustomPropertiesValuesForRepos: [
          "PATCH /orgs/{org}/properties/values"
        ],
        createOrUpdateCustomProperty: [
          "PUT /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        createWebhook: ["POST /orgs/{org}/hooks"],
        delete: ["DELETE /orgs/{org}"],
        deleteCustomOrganizationRole: [
          "DELETE /orgs/{org}/organization-roles/{role_id}"
        ],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        enableOrDisableSecurityProductOnAllOrgRepos: [
          "POST /orgs/{org}/{security_product}/{enablement}"
        ],
        get: ["GET /orgs/{org}"],
        getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
        getCustomProperty: [
          "GET /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: [
          "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
        listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
        listOrgRoles: ["GET /orgs/{org}/organization-roles"],
        listOrganizationFineGrainedPermissions: [
          "GET /orgs/{org}/organization-fine-grained-permissions"
        ],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPatGrantRepositories: [
          "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
        ],
        listPatGrantRequestRepositories: [
          "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
        ],
        listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
        listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        patchCustomOrganizationRole: [
          "PATCH /orgs/{org}/organization-roles/{role_id}"
        ],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
          "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeCustomProperty: [
          "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: [
          "DELETE /orgs/{org}/outside_collaborators/{username}"
        ],
        removePublicMembershipForAuthenticatedUser: [
          "DELETE /orgs/{org}/public_members/{username}"
        ],
        removeSecurityManagerTeam: [
          "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
        ],
        reviewPatGrantRequest: [
          "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
        ],
        reviewPatGrantRequestsInBulk: [
          "POST /orgs/{org}/personal-access-token-requests"
        ],
        revokeAllOrgRolesTeam: [
          "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
        ],
        revokeAllOrgRolesUser: [
          "DELETE /orgs/{org}/organization-roles/users/{username}"
        ],
        revokeOrgRoleTeam: [
          "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        revokeOrgRoleUser: [
          "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: [
          "PUT /orgs/{org}/public_members/{username}"
        ],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: [
          "PATCH /user/memberships/orgs/{org}"
        ],
        updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
        updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
      },
      packages: {
        deletePackageForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}"
        ],
        deletePackageForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        deletePackageForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}"
        ],
        deletePackageVersionForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions",
          {},
          {
            renamed: [
              "packages",
              "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
            ]
          }
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions"
        ],
        getPackageForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}"
        ],
        getPackageForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        getPackageForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}"
        ],
        getPackageVersionForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: [
          "GET /user/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForOrganization: [
          "GET /orgs/{org}/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForUser: [
          "GET /users/{username}/docker/conflicts"
        ],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageVersionForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ]
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: [
          "GET /projects/{project_id}/collaborators/{username}/permission"
        ],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: [
          "DELETE /projects/{project_id}/collaborators/{username}"
        ],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"]
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
        ],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        deletePendingReview: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        deleteReviewComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        dismissReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
        ],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
        ],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        listReviewComments: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        requestReviewers: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        submitReview: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
        ],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
        ],
        updateReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        updateReviewComment: [
          "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ]
      },
      rateLimit: { get: ["GET /rate_limit"] },
      reactions: {
        createForCommitComment: [
          "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        createForIssue: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        createForIssueComment: [
          "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        createForPullRequestReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        createForRelease: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        createForTeamDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        createForTeamDiscussionInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ],
        deleteForCommitComment: [
          "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForIssue: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
        ],
        deleteForIssueComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForPullRequestComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForRelease: [
          "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussion: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussionComment: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
        ],
        listForCommitComment: [
          "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: [
          "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        listForPullRequestReviewComment: [
          "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        listForRelease: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        listForTeamDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        listForTeamDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ]
      },
      repos: {
        acceptInvitation: [
          "PATCH /user/repository_invitations/{invitation_id}",
          {},
          { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
        ],
        acceptInvitationForAuthenticatedUser: [
          "PATCH /user/repository_invitations/{invitation_id}"
        ],
        addAppAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        addTeamAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        addUserAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        cancelPagesDeployment: [
          "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
        ],
        checkAutomatedSecurityFixes: [
          "GET /repos/{owner}/{repo}/automated-security-fixes"
        ],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: [
          "GET /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: [
          "GET /repos/{owner}/{repo}/compare/{basehead}"
        ],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: [
          "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        createCommitSignatureProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentBranchPolicy: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        createDeploymentProtectionRule: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        createDeploymentStatus: [
          "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateCustomPropertiesValues: [
          "PATCH /repos/{owner}/{repo}/properties/values"
        ],
        createOrUpdateEnvironment: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createOrgRuleset: ["POST /orgs/{org}/rulesets"],
        createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: [
          "POST /repos/{template_owner}/{template_repo}/generate"
        ],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: [
          "DELETE /user/repository_invitations/{invitation_id}",
          {},
          { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
        ],
        declineInvitationForAuthenticatedUser: [
          "DELETE /user/repository_invitations/{invitation_id}"
        ],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        deleteAdminBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        deleteAnEnvironment: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: [
          "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        deleteDeploymentBranchPolicy: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: [
          "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: [
          "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        deleteTagProtection: [
          "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
        ],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: [
          "DELETE /repos/{owner}/{repo}/automated-security-fixes"
        ],
        disableDeploymentProtectionRule: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        disablePrivateVulnerabilityReporting: [
          "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        disableVulnerabilityAlerts: [
          "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        downloadArchive: [
          "GET /repos/{owner}/{repo}/zipball/{ref}",
          {},
          { renamed: ["repos", "downloadZipballArchive"] }
        ],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: [
          "PUT /repos/{owner}/{repo}/automated-security-fixes"
        ],
        enablePrivateVulnerabilityReporting: [
          "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        enableVulnerabilityAlerts: [
          "PUT /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        generateReleaseNotes: [
          "POST /repos/{owner}/{repo}/releases/generate-notes"
        ],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        getAdminBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        getAllDeploymentProtectionRules: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        ],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        ],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: [
          "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
        ],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getCustomDeploymentProtectionRule: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentBranchPolicy: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        getDeploymentStatus: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
        ],
        getEnvironment: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
        getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
        getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
        getOrgRulesets: ["GET /orgs/{org}/rulesets"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesDeployment: [
          "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
        ],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getRepoRuleSuite: [
          "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
        ],
        getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
        getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
        getStatusChecksProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        getTeamsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        ],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        ],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        listActivities: ["GET /repos/{owner}/{repo}/activity"],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
        ],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
        ],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listCustomDeploymentRuleIntegrations: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
        ],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentBranchPolicies: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        listDeploymentStatuses: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
        ],
        listReleaseAssets: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
        ],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
          "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeAppAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        removeCollaborator: [
          "DELETE /repos/{owner}/{repo}/collaborators/{username}"
        ],
        removeStatusCheckContexts: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        removeStatusCheckProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        removeTeamAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        removeUserAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        setAppAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          { mapToData: "apps" }
        ],
        setStatusCheckContexts: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          { mapToData: "contexts" }
        ],
        setTeamAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          { mapToData: "teams" }
        ],
        setUserAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          { mapToData: "users" }
        ],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateDeploymentBranchPolicy: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: [
          "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
        updatePullRequestReviewProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: [
          "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        updateStatusCheckPotection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          {},
          { renamed: ["repos", "updateStatusCheckProtection"] }
        ],
        updateStatusCheckProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: [
          "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        uploadReleaseAsset: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
          { baseUrl: "https://uploads.github.com" }
        ]
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"]
      },
      secretScanning: {
        getAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/secret-scanning/alerts"
        ],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ]
      },
      securityAdvisories: {
        createFork: [
          "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
        ],
        createPrivateVulnerabilityReport: [
          "POST /repos/{owner}/{repo}/security-advisories/reports"
        ],
        createRepositoryAdvisory: [
          "POST /repos/{owner}/{repo}/security-advisories"
        ],
        createRepositoryAdvisoryCveRequest: [
          "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
        ],
        getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
        getRepositoryAdvisory: [
          "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ],
        listGlobalAdvisories: ["GET /advisories"],
        listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
        listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
        updateRepositoryAdvisory: [
          "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ]
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        addOrUpdateProjectPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        addOrUpdateRepoPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        checkPermissionsForProjectInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        checkPermissionsForRepoInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        deleteDiscussionInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        getDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        getMembershipForUserInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/invitations"
        ],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        removeProjectInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
        ],
        removeRepoInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        updateDiscussionCommentInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        updateDiscussionInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
      },
      users: {
        addEmailForAuthenticated: [
          "POST /user/emails",
          {},
          { renamed: ["users", "addEmailForAuthenticatedUser"] }
        ],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: [
          "POST /user/gpg_keys",
          {},
          { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
        ],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: [
          "POST /user/keys",
          {},
          { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
        ],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
        deleteEmailForAuthenticated: [
          "DELETE /user/emails",
          {},
          { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
        ],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: [
          "DELETE /user/gpg_keys/{gpg_key_id}",
          {},
          { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
        ],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: [
          "DELETE /user/keys/{key_id}",
          {},
          { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
        ],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
        deleteSshSigningKeyForAuthenticatedUser: [
          "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: [
          "GET /user/gpg_keys/{gpg_key_id}",
          {},
          { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
        ],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: [
          "GET /user/keys/{key_id}",
          {},
          { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
        ],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        getSshSigningKeyForAuthenticatedUser: [
          "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        list: ["GET /users"],
        listBlockedByAuthenticated: [
          "GET /user/blocks",
          {},
          { renamed: ["users", "listBlockedByAuthenticatedUser"] }
        ],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: [
          "GET /user/emails",
          {},
          { renamed: ["users", "listEmailsForAuthenticatedUser"] }
        ],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: [
          "GET /user/following",
          {},
          { renamed: ["users", "listFollowedByAuthenticatedUser"] }
        ],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: [
          "GET /user/gpg_keys",
          {},
          { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
        ],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: [
          "GET /user/public_emails",
          {},
          { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
        ],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: [
          "GET /user/keys",
          {},
          { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
        ],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
        listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
        listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
        listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
          "PATCH /user/email/visibility",
          {},
          { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
          "PATCH /user/email/visibility"
        ],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"]
      }
    };
    var endpoints_default = Endpoints;
    var endpointMethodsMap = /* @__PURE__ */ new Map();
    for (const [scope, endpoints] of Object.entries(endpoints_default)) {
      for (const [methodName, endpoint] of Object.entries(endpoints)) {
        const [route, defaults, decorations] = endpoint;
        const [method, url2] = route.split(/ /);
        const endpointDefaults = Object.assign(
          {
            method,
            url: url2
          },
          defaults
        );
        if (!endpointMethodsMap.has(scope)) {
          endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
        }
        endpointMethodsMap.get(scope).set(methodName, {
          scope,
          methodName,
          endpointDefaults,
          decorations
        });
      }
    }
    var handler = {
      has({ scope }, methodName) {
        return endpointMethodsMap.get(scope).has(methodName);
      },
      getOwnPropertyDescriptor(target, methodName) {
        return {
          value: this.get(target, methodName),
          // ensures method is in the cache
          configurable: true,
          writable: true,
          enumerable: true
        };
      },
      defineProperty(target, methodName, descriptor) {
        Object.defineProperty(target.cache, methodName, descriptor);
        return true;
      },
      deleteProperty(target, methodName) {
        delete target.cache[methodName];
        return true;
      },
      ownKeys({ scope }) {
        return [...endpointMethodsMap.get(scope).keys()];
      },
      set(target, methodName, value) {
        return target.cache[methodName] = value;
      },
      get({ octokit, scope, cache }, methodName) {
        if (cache[methodName]) {
          return cache[methodName];
        }
        const method = endpointMethodsMap.get(scope).get(methodName);
        if (!method) {
          return void 0;
        }
        const { endpointDefaults, decorations } = method;
        if (decorations) {
          cache[methodName] = decorate(
            octokit,
            scope,
            methodName,
            endpointDefaults,
            decorations
          );
        } else {
          cache[methodName] = octokit.request.defaults(endpointDefaults);
        }
        return cache[methodName];
      }
    };
    function endpointsToMethods(octokit) {
      const newMethods = {};
      for (const scope of endpointMethodsMap.keys()) {
        newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
      }
      return newMethods;
    }
    function decorate(octokit, scope, methodName, defaults, decorations) {
      const requestWithDefaults = octokit.request.defaults(defaults);
      function withDecorations(...args) {
        let options = requestWithDefaults.endpoint.merge(...args);
        if (decorations.mapToData) {
          options = Object.assign({}, options, {
            data: options[decorations.mapToData],
            [decorations.mapToData]: void 0
          });
          return requestWithDefaults(options);
        }
        if (decorations.renamed) {
          const [newScope, newMethodName] = decorations.renamed;
          octokit.log.warn(
            `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
          );
        }
        if (decorations.deprecated) {
          octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
          const options2 = requestWithDefaults.endpoint.merge(...args);
          for (const [name, alias] of Object.entries(
            decorations.renamedParameters
          )) {
            if (name in options2) {
              octokit.log.warn(
                `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
              );
              if (!(alias in options2)) {
                options2[alias] = options2[name];
              }
              delete options2[name];
            }
          }
          return requestWithDefaults(options2);
        }
        return requestWithDefaults(...args);
      }
      return Object.assign(withDecorations, requestWithDefaults);
    }
    function restEndpointMethods(octokit) {
      const api = endpointsToMethods(octokit);
      return {
        rest: api
      };
    }
    restEndpointMethods.VERSION = VERSION5;
    function legacyRestEndpointMethods(octokit) {
      const api = endpointsToMethods(octokit);
      return {
        ...api,
        rest: api
      };
    }
    legacyRestEndpointMethods.VERSION = VERSION5;
  }
});

// node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node10 = __commonJS({
  "node_modules/@octokit/plugin-paginate-rest/dist-node/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var dist_src_exports = {};
    __export2(dist_src_exports, {
      composePaginateRest: () => composePaginateRest,
      isPaginatingEndpoint: () => isPaginatingEndpoint,
      paginateRest: () => paginateRest,
      paginatingEndpoints: () => paginatingEndpoints
    });
    module2.exports = __toCommonJS2(dist_src_exports);
    var VERSION5 = "9.2.2";
    function normalizePaginatedListResponse(response) {
      if (!response.data) {
        return {
          ...response,
          data: []
        };
      }
      const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
      if (!responseNeedsNormalization)
        return response;
      const incompleteResults = response.data.incomplete_results;
      const repositorySelection = response.data.repository_selection;
      const totalCount = response.data.total_count;
      delete response.data.incomplete_results;
      delete response.data.repository_selection;
      delete response.data.total_count;
      const namespaceKey = Object.keys(response.data)[0];
      const data = response.data[namespaceKey];
      response.data = data;
      if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
      }
      if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
      }
      response.data.total_count = totalCount;
      return response;
    }
    function iterator(octokit, route, parameters) {
      const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
      const requestMethod = typeof route === "function" ? route : octokit.request;
      const method = options.method;
      const headers = options.headers;
      let url2 = options.url;
      return {
        [Symbol.asyncIterator]: () => ({
          async next() {
            if (!url2)
              return { done: true };
            try {
              const response = await requestMethod({ method, url: url2, headers });
              const normalizedResponse = normalizePaginatedListResponse(response);
              url2 = ((normalizedResponse.headers.link || "").match(
                /<([^<>]+)>;\s*rel="next"/
              ) || [])[1];
              return { value: normalizedResponse };
            } catch (error) {
              if (error.status !== 409)
                throw error;
              url2 = "";
              return {
                value: {
                  status: 200,
                  headers: {},
                  data: []
                }
              };
            }
          }
        })
      };
    }
    function paginate(octokit, route, parameters, mapFn) {
      if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = void 0;
      }
      return gather(
        octokit,
        [],
        iterator(octokit, route, parameters)[Symbol.asyncIterator](),
        mapFn
      );
    }
    function gather(octokit, results, iterator2, mapFn) {
      return iterator2.next().then((result) => {
        if (result.done) {
          return results;
        }
        let earlyExit = false;
        function done() {
          earlyExit = true;
        }
        results = results.concat(
          mapFn ? mapFn(result.value, done) : result.value.data
        );
        if (earlyExit) {
          return results;
        }
        return gather(octokit, results, iterator2, mapFn);
      });
    }
    var composePaginateRest = Object.assign(paginate, {
      iterator
    });
    var paginatingEndpoints = [
      "GET /advisories",
      "GET /app/hook/deliveries",
      "GET /app/installation-requests",
      "GET /app/installations",
      "GET /assignments/{assignment_id}/accepted_assignments",
      "GET /classrooms",
      "GET /classrooms/{classroom_id}/assignments",
      "GET /enterprises/{enterprise}/dependabot/alerts",
      "GET /enterprises/{enterprise}/secret-scanning/alerts",
      "GET /events",
      "GET /gists",
      "GET /gists/public",
      "GET /gists/starred",
      "GET /gists/{gist_id}/comments",
      "GET /gists/{gist_id}/commits",
      "GET /gists/{gist_id}/forks",
      "GET /installation/repositories",
      "GET /issues",
      "GET /licenses",
      "GET /marketplace_listing/plans",
      "GET /marketplace_listing/plans/{plan_id}/accounts",
      "GET /marketplace_listing/stubbed/plans",
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
      "GET /networks/{owner}/{repo}/events",
      "GET /notifications",
      "GET /organizations",
      "GET /orgs/{org}/actions/cache/usage-by-repository",
      "GET /orgs/{org}/actions/permissions/repositories",
      "GET /orgs/{org}/actions/runners",
      "GET /orgs/{org}/actions/secrets",
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/actions/variables",
      "GET /orgs/{org}/actions/variables/{name}/repositories",
      "GET /orgs/{org}/blocks",
      "GET /orgs/{org}/code-scanning/alerts",
      "GET /orgs/{org}/codespaces",
      "GET /orgs/{org}/codespaces/secrets",
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/copilot/billing/seats",
      "GET /orgs/{org}/dependabot/alerts",
      "GET /orgs/{org}/dependabot/secrets",
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/events",
      "GET /orgs/{org}/failed_invitations",
      "GET /orgs/{org}/hooks",
      "GET /orgs/{org}/hooks/{hook_id}/deliveries",
      "GET /orgs/{org}/installations",
      "GET /orgs/{org}/invitations",
      "GET /orgs/{org}/invitations/{invitation_id}/teams",
      "GET /orgs/{org}/issues",
      "GET /orgs/{org}/members",
      "GET /orgs/{org}/members/{username}/codespaces",
      "GET /orgs/{org}/migrations",
      "GET /orgs/{org}/migrations/{migration_id}/repositories",
      "GET /orgs/{org}/organization-roles/{role_id}/teams",
      "GET /orgs/{org}/organization-roles/{role_id}/users",
      "GET /orgs/{org}/outside_collaborators",
      "GET /orgs/{org}/packages",
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      "GET /orgs/{org}/personal-access-token-requests",
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
      "GET /orgs/{org}/personal-access-tokens",
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
      "GET /orgs/{org}/projects",
      "GET /orgs/{org}/properties/values",
      "GET /orgs/{org}/public_members",
      "GET /orgs/{org}/repos",
      "GET /orgs/{org}/rulesets",
      "GET /orgs/{org}/rulesets/rule-suites",
      "GET /orgs/{org}/secret-scanning/alerts",
      "GET /orgs/{org}/security-advisories",
      "GET /orgs/{org}/teams",
      "GET /orgs/{org}/teams/{team_slug}/discussions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/invitations",
      "GET /orgs/{org}/teams/{team_slug}/members",
      "GET /orgs/{org}/teams/{team_slug}/projects",
      "GET /orgs/{org}/teams/{team_slug}/repos",
      "GET /orgs/{org}/teams/{team_slug}/teams",
      "GET /projects/columns/{column_id}/cards",
      "GET /projects/{project_id}/collaborators",
      "GET /projects/{project_id}/columns",
      "GET /repos/{owner}/{repo}/actions/artifacts",
      "GET /repos/{owner}/{repo}/actions/caches",
      "GET /repos/{owner}/{repo}/actions/organization-secrets",
      "GET /repos/{owner}/{repo}/actions/organization-variables",
      "GET /repos/{owner}/{repo}/actions/runners",
      "GET /repos/{owner}/{repo}/actions/runs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
      "GET /repos/{owner}/{repo}/actions/secrets",
      "GET /repos/{owner}/{repo}/actions/variables",
      "GET /repos/{owner}/{repo}/actions/workflows",
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
      "GET /repos/{owner}/{repo}/activity",
      "GET /repos/{owner}/{repo}/assignees",
      "GET /repos/{owner}/{repo}/branches",
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
      "GET /repos/{owner}/{repo}/code-scanning/alerts",
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      "GET /repos/{owner}/{repo}/code-scanning/analyses",
      "GET /repos/{owner}/{repo}/codespaces",
      "GET /repos/{owner}/{repo}/codespaces/devcontainers",
      "GET /repos/{owner}/{repo}/codespaces/secrets",
      "GET /repos/{owner}/{repo}/collaborators",
      "GET /repos/{owner}/{repo}/comments",
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/commits",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
      "GET /repos/{owner}/{repo}/commits/{ref}/status",
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
      "GET /repos/{owner}/{repo}/contributors",
      "GET /repos/{owner}/{repo}/dependabot/alerts",
      "GET /repos/{owner}/{repo}/dependabot/secrets",
      "GET /repos/{owner}/{repo}/deployments",
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
      "GET /repos/{owner}/{repo}/environments",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
      "GET /repos/{owner}/{repo}/events",
      "GET /repos/{owner}/{repo}/forks",
      "GET /repos/{owner}/{repo}/hooks",
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
      "GET /repos/{owner}/{repo}/invitations",
      "GET /repos/{owner}/{repo}/issues",
      "GET /repos/{owner}/{repo}/issues/comments",
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/issues/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
      "GET /repos/{owner}/{repo}/keys",
      "GET /repos/{owner}/{repo}/labels",
      "GET /repos/{owner}/{repo}/milestones",
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
      "GET /repos/{owner}/{repo}/notifications",
      "GET /repos/{owner}/{repo}/pages/builds",
      "GET /repos/{owner}/{repo}/projects",
      "GET /repos/{owner}/{repo}/pulls",
      "GET /repos/{owner}/{repo}/pulls/comments",
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
      "GET /repos/{owner}/{repo}/releases",
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
      "GET /repos/{owner}/{repo}/rules/branches/{branch}",
      "GET /repos/{owner}/{repo}/rulesets",
      "GET /repos/{owner}/{repo}/rulesets/rule-suites",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
      "GET /repos/{owner}/{repo}/security-advisories",
      "GET /repos/{owner}/{repo}/stargazers",
      "GET /repos/{owner}/{repo}/subscribers",
      "GET /repos/{owner}/{repo}/tags",
      "GET /repos/{owner}/{repo}/teams",
      "GET /repos/{owner}/{repo}/topics",
      "GET /repositories",
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
      "GET /repositories/{repository_id}/environments/{environment_name}/variables",
      "GET /search/code",
      "GET /search/commits",
      "GET /search/issues",
      "GET /search/labels",
      "GET /search/repositories",
      "GET /search/topics",
      "GET /search/users",
      "GET /teams/{team_id}/discussions",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
      "GET /teams/{team_id}/invitations",
      "GET /teams/{team_id}/members",
      "GET /teams/{team_id}/projects",
      "GET /teams/{team_id}/repos",
      "GET /teams/{team_id}/teams",
      "GET /user/blocks",
      "GET /user/codespaces",
      "GET /user/codespaces/secrets",
      "GET /user/emails",
      "GET /user/followers",
      "GET /user/following",
      "GET /user/gpg_keys",
      "GET /user/installations",
      "GET /user/installations/{installation_id}/repositories",
      "GET /user/issues",
      "GET /user/keys",
      "GET /user/marketplace_purchases",
      "GET /user/marketplace_purchases/stubbed",
      "GET /user/memberships/orgs",
      "GET /user/migrations",
      "GET /user/migrations/{migration_id}/repositories",
      "GET /user/orgs",
      "GET /user/packages",
      "GET /user/packages/{package_type}/{package_name}/versions",
      "GET /user/public_emails",
      "GET /user/repos",
      "GET /user/repository_invitations",
      "GET /user/social_accounts",
      "GET /user/ssh_signing_keys",
      "GET /user/starred",
      "GET /user/subscriptions",
      "GET /user/teams",
      "GET /users",
      "GET /users/{username}/events",
      "GET /users/{username}/events/orgs/{org}",
      "GET /users/{username}/events/public",
      "GET /users/{username}/followers",
      "GET /users/{username}/following",
      "GET /users/{username}/gists",
      "GET /users/{username}/gpg_keys",
      "GET /users/{username}/keys",
      "GET /users/{username}/orgs",
      "GET /users/{username}/packages",
      "GET /users/{username}/projects",
      "GET /users/{username}/received_events",
      "GET /users/{username}/received_events/public",
      "GET /users/{username}/repos",
      "GET /users/{username}/social_accounts",
      "GET /users/{username}/ssh_signing_keys",
      "GET /users/{username}/starred",
      "GET /users/{username}/subscriptions"
    ];
    function isPaginatingEndpoint(arg) {
      if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
      } else {
        return false;
      }
    }
    function paginateRest(octokit) {
      return {
        paginate: Object.assign(paginate.bind(null, octokit), {
          iterator: iterator.bind(null, octokit)
        })
      };
    }
    paginateRest.VERSION = VERSION5;
  }
});

// node_modules/@actions/github/lib/utils.js
var require_utils23 = __commonJS({
  "node_modules/@actions/github/lib/utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOctokitOptions = exports2.GitHub = exports2.defaults = exports2.context = void 0;
    var Context = __importStar(require_context());
    var Utils = __importStar(require_utils22());
    var core_1 = require_dist_node8();
    var plugin_rest_endpoint_methods_1 = require_dist_node9();
    var plugin_paginate_rest_1 = require_dist_node10();
    exports2.context = new Context.Context();
    var baseUrl = Utils.getApiBaseUrl();
    exports2.defaults = {
      baseUrl,
      request: {
        agent: Utils.getProxyAgent(baseUrl),
        fetch: Utils.getProxyFetch(baseUrl)
      }
    };
    exports2.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports2.defaults);
    function getOctokitOptions(token, options) {
      const opts = Object.assign({}, options || {});
      const auth = Utils.getAuthString(token, opts);
      if (auth) {
        opts.auth = auth;
      }
      return opts;
    }
    exports2.getOctokitOptions = getOctokitOptions;
  }
});

// node_modules/@actions/github/lib/github.js
var require_github = __commonJS({
  "node_modules/@actions/github/lib/github.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOctokit = exports2.context = void 0;
    var Context = __importStar(require_context());
    var utils_1 = require_utils23();
    exports2.context = new Context.Context();
    function getOctokit(token, options, ...additionalPlugins) {
      const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
      return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
    }
    exports2.getOctokit = getOctokit;
  }
});

// node_modules/@sentry/node/build/esm/integrations/http/index.js
init_esm();
var import_instrumentation_http = __toESM(require_src5(), 1);

// node_modules/@sentry/core/build/esm/debug-build.js
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js
var GLOBAL_OBJ = globalThis;

// node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js
var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// node_modules/@sentry/core/build/esm/utils-hoist/version.js
var SDK_VERSION = "9.12.0";

// node_modules/@sentry/core/build/esm/carrier.js
function getMainCarrier() {
  getSentryCarrier(GLOBAL_OBJ);
  return GLOBAL_OBJ;
}
function getSentryCarrier(carrier) {
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
  return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
}
function getGlobalSingleton(name, creator, obj = GLOBAL_OBJ) {
  const __SENTRY__ = obj.__SENTRY__ = obj.__SENTRY__ || {};
  const carrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  return carrier[name] || (carrier[name] = creator());
}

// node_modules/@sentry/core/build/esm/utils-hoist/logger.js
var PREFIX = "Sentry Logger ";
var CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
var originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function makeLogger() {
  let enabled = false;
  const logger2 = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
    isEnabled: () => enabled
  };
  if (DEBUG_BUILD2) {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = () => void 0;
    });
  }
  return logger2;
}
var logger = getGlobalSingleton("logger", makeLogger);

// node_modules/@sentry/core/build/esm/utils-hoist/stacktrace.js
var STACKTRACE_FRAME_LIMIT = 50;
var UNKNOWN_FUNCTION = "?";
var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);
  return (stack, skipFirstLines = 0, framesToPop = 0) => {
    const frames = [];
    const lines = stack.split("\n");
    for (let i = skipFirstLines; i < lines.length; i++) {
      const line = lines[i];
      if (line.length > 1024) {
        continue;
      }
      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
      if (cleanedLine.match(/\S*Error: /)) {
        continue;
      }
      for (const parser of sortedParsers) {
        const frame = parser(cleanedLine);
        if (frame) {
          frames.push(frame);
          break;
        }
      }
      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {
        break;
      }
    }
    return stripSentryFramesAndReverse(frames.slice(framesToPop));
  };
}
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  const localStack = Array.from(stack);
  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
  }
  localStack.reverse();
  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
      localStack.pop();
    }
  }
  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
    ...frame,
    filename: frame.filename || getLastStackFrame(localStack).filename,
    function: frame.function || UNKNOWN_FUNCTION
  }));
}
function getLastStackFrame(arr) {
  return arr[arr.length - 1] || {};
}
var defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e) {
    return defaultFunctionName;
  }
}

// node_modules/@sentry/core/build/esm/utils-hoist/instrument/handlers.js
var handlers = {};
var instrumented = {};
function addHandler(type, handler) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(handler);
}
function maybeInstrument(type, instrumentFn) {
  if (!instrumented[type]) {
    instrumented[type] = true;
    try {
      instrumentFn();
    } catch (e) {
      DEBUG_BUILD2 && logger.error(`Error while instrumenting ${type}`, e);
    }
  }
}
function triggerHandlers(type, data) {
  const typeHandlers = type && handlers[type];
  if (!typeHandlers) {
    return;
  }
  for (const handler of typeHandlers) {
    try {
      handler(data);
    } catch (e) {
      DEBUG_BUILD2 && logger.error(
        `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
        e
      );
    }
  }
}

// node_modules/@sentry/core/build/esm/utils-hoist/instrument/globalError.js
var _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(handler) {
  const type = "error";
  addHandler(type, handler);
  maybeInstrument(type, instrumentError);
}
function instrumentError() {
  _oldOnErrorHandler = GLOBAL_OBJ.onerror;
  GLOBAL_OBJ.onerror = function(msg, url2, line, column, error) {
    const handlerData = {
      column,
      error,
      line,
      msg,
      url: url2
    };
    triggerHandlers("error", handlerData);
    if (_oldOnErrorHandler) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
}

// node_modules/@sentry/core/build/esm/utils-hoist/instrument/globalUnhandledRejection.js
var _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
  const type = "unhandledrejection";
  addHandler(type, handler);
  maybeInstrument(type, instrumentUnhandledRejection);
}
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
  GLOBAL_OBJ.onunhandledrejection = function(e) {
    const handlerData = e;
    triggerHandlers("unhandledrejection", handlerData);
    if (_oldOnUnhandledRejectionHandler) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}

// node_modules/@sentry/core/build/esm/utils-hoist/time.js
var ONE_SECOND_IN_MS = 1e3;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2?.now) {
    return dateTimestampInSeconds;
  }
  const approxStartingTimeOrigin = Date.now() - performance2.now();
  const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
  return () => {
    return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
  };
}
var timestampInSeconds = createUnixTimestampInSecondsFunc();

// node_modules/@sentry/core/build/esm/utils-hoist/is.js
var objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isErrorEvent(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isString(wat) {
  return isBuiltin(wat, "String");
}
function isParameterizedString(wat) {
  return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
}
function isPrimitive(wat) {
  return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat?.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e) {
    return false;
  }
}
function isVueViewModel(wat) {
  return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
}

// node_modules/@sentry/core/build/esm/utils-hoist/browser.js
var WINDOW = GLOBAL_OBJ;
var DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(elem, options = {}) {
  if (!elem) {
    return "<unknown>";
  }
  try {
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = " > ";
    const sepLength = separator.length;
    let nextStr;
    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
    const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el, keyAttrs) {
  const elem = el;
  const out = [];
  if (!elem?.tagName) {
    return "";
  }
  if (WINDOW.HTMLElement) {
    if (elem instanceof HTMLElement && elem.dataset) {
      if (elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
      if (elem.dataset["sentryElement"]) {
        return elem.dataset["sentryElement"];
      }
    }
  }
  out.push(elem.tagName.toLowerCase());
  const keyAttrPairs = keyAttrs?.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
  if (keyAttrPairs?.length) {
    keyAttrPairs.forEach((keyAttrPair) => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }
    const className = elem.className;
    if (className && isString(className)) {
      const classes = className.split(/\s+/);
      for (const c of classes) {
        out.push(`.${c}`);
      }
    }
  }
  const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
  for (const k of allowedAttrs) {
    const attr = elem.getAttribute(k);
    if (attr) {
      out.push(`[${k}="${attr}"]`);
    }
  }
  return out.join("");
}

// node_modules/@sentry/core/build/esm/utils-hoist/string.js
function truncate(str, max = 0) {
  if (typeof str !== "string" || max === 0) {
    return str;
  }
  return str.length <= max ? str : `${str.slice(0, max)}...`;
}
function snipLine(line, colno) {
  let newLine = line;
  const lineLength = newLine.length;
  if (lineLength <= 150) {
    return newLine;
  }
  if (colno > lineLength) {
    colno = lineLength;
  }
  let start = Math.max(colno - 60, 0);
  if (start < 5) {
    start = 0;
  }
  let end = Math.min(start + 140, lineLength);
  if (end > lineLength - 5) {
    end = lineLength;
  }
  if (end === lineLength) {
    start = Math.max(end - 140, 0);
  }
  newLine = newLine.slice(start, end);
  if (start > 0) {
    newLine = `'{snip} ${newLine}`;
  }
  if (end < lineLength) {
    newLine += " {snip}";
  }
  return newLine;
}
function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
  if (!isString(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }
  return false;
}
function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
  return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
}

// node_modules/@sentry/core/build/esm/utils-hoist/object.js
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  const original = source[name];
  if (typeof original !== "function") {
    return;
  }
  const wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    markFunctionWrapped(wrapped, original);
  }
  try {
    source[name] = wrapped;
  } catch {
    DEBUG_BUILD2 && logger.log(`Failed to replace method "${name}" in object`, source);
  }
}
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value,
      writable: true,
      configurable: true
    });
  } catch (o_O) {
    DEBUG_BUILD2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function markFunctionWrapped(wrapped, original) {
  try {
    const proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  } catch (o_O) {
  }
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function convertToPlainObject(value) {
  if (isError(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value)
    };
  } else if (isEvent(value)) {
    const newObj = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value)
    };
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }
    return newObj;
  } else {
    return value;
  }
}
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  if (typeof obj === "object" && obj !== null) {
    const extractedProps = {};
    for (const property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys = Object.keys(convertToPlainObject(exception));
  keys.sort();
  const firstKey = keys[0];
  if (!firstKey) {
    return "[object has no keys]";
  }
  if (firstKey.length >= maxLength) {
    return truncate(firstKey, maxLength);
  }
  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
    const serialized = keys.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}

// node_modules/@sentry/core/build/esm/utils-hoist/misc.js
function getCrypto() {
  const gbl = GLOBAL_OBJ;
  return gbl.crypto || gbl.msCrypto;
}
function uuid4(crypto = getCrypto()) {
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto?.randomUUID) {
      return crypto.randomUUID().replace(/-/g, "");
    }
    if (crypto?.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch (_) {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (c) => (
      // eslint-disable-next-line no-bitwise
      (c ^ (getRandomByte() & 15) >> c / 4).toString(16)
    )
  );
}
function getFirstException(event) {
  return event.exception?.values?.[0];
}
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }
  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  const exception = event.exception = event.exception || {};
  const values = exception.values = exception.values || [];
  const firstException = values[0] = values[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = type || "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism?.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}
var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
function _parseInt(input) {
  return parseInt(input || "", 10);
}
function parseSemver(input) {
  const match = input.match(SEMVER_REGEXP) || [];
  const major2 = _parseInt(match[1]);
  const minor = _parseInt(match[2]);
  const patch = _parseInt(match[3]);
  return {
    buildmetadata: match[5],
    major: isNaN(major2) ? void 0 : major2,
    minor: isNaN(minor) ? void 0 : minor,
    patch: isNaN(patch) ? void 0 : patch,
    prerelease: match[4]
  };
}
function checkOrSetAlreadyCaught(exception) {
  if (isAlreadyCaptured(exception)) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch (err) {
  }
  return false;
}
function isAlreadyCaptured(exception) {
  try {
    return exception.__sentry_captured__;
  } catch {
  }
}

// node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js
var States;
(function(States2) {
  const PENDING = 0;
  States2[States2["PENDING"] = PENDING] = "PENDING";
  const RESOLVED = 1;
  States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
  const REJECTED = 2;
  States2[States2["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));
function resolvedSyncPromise(value) {
  return new SyncPromise((resolve2) => {
    resolve2(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise((_, reject) => {
    reject(reason);
  });
}
var SyncPromise = class _SyncPromise {
  constructor(executor) {
    this._state = States.PENDING;
    this._handlers = [];
    this._runExecutor(executor);
  }
  /** @inheritdoc */
  then(onfulfilled, onrejected) {
    return new _SyncPromise((resolve2, reject) => {
      this._handlers.push([
        false,
        (result) => {
          if (!onfulfilled) {
            resolve2(result);
          } else {
            try {
              resolve2(onfulfilled(result));
            } catch (e) {
              reject(e);
            }
          }
        },
        (reason) => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve2(onrejected(reason));
            } catch (e) {
              reject(e);
            }
          }
        }
      ]);
      this._executeHandlers();
    });
  }
  /** @inheritdoc */
  catch(onrejected) {
    return this.then((val) => val, onrejected);
  }
  /** @inheritdoc */
  finally(onfinally) {
    return new _SyncPromise((resolve2, reject) => {
      let val;
      let isRejected;
      return this.then(
        (value) => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        },
        (reason) => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }
      ).then(() => {
        if (isRejected) {
          reject(val);
          return;
        }
        resolve2(val);
      });
    });
  }
  /** Excute the resolve/reject handlers. */
  _executeHandlers() {
    if (this._state === States.PENDING) {
      return;
    }
    const cachedHandlers = this._handlers.slice();
    this._handlers = [];
    cachedHandlers.forEach((handler) => {
      if (handler[0]) {
        return;
      }
      if (this._state === States.RESOLVED) {
        handler[1](this._value);
      }
      if (this._state === States.REJECTED) {
        handler[2](this._value);
      }
      handler[0] = true;
    });
  }
  /** Run the executor for the SyncPromise. */
  _runExecutor(executor) {
    const setResult = (state, value) => {
      if (this._state !== States.PENDING) {
        return;
      }
      if (isThenable(value)) {
        void value.then(resolve2, reject);
        return;
      }
      this._state = state;
      this._value = value;
      this._executeHandlers();
    };
    const resolve2 = (value) => {
      setResult(States.RESOLVED, value);
    };
    const reject = (reason) => {
      setResult(States.REJECTED, reason);
    };
    try {
      executor(resolve2, reject);
    } catch (e) {
      reject(e);
    }
  }
};

// node_modules/@sentry/core/build/esm/session.js
function makeSession(context3) {
  const startingTime = timestampInSeconds();
  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session)
  };
  if (context3) {
    updateSession(session, context3);
  }
  return session;
}
function updateSession(session, context3 = {}) {
  if (context3.user) {
    if (!session.ipAddress && context3.user.ip_address) {
      session.ipAddress = context3.user.ip_address;
    }
    if (!session.did && !context3.did) {
      session.did = context3.user.id || context3.user.email || context3.user.username;
    }
  }
  session.timestamp = context3.timestamp || timestampInSeconds();
  if (context3.abnormal_mechanism) {
    session.abnormal_mechanism = context3.abnormal_mechanism;
  }
  if (context3.ignoreDuration) {
    session.ignoreDuration = context3.ignoreDuration;
  }
  if (context3.sid) {
    session.sid = context3.sid.length === 32 ? context3.sid : uuid4();
  }
  if (context3.init !== void 0) {
    session.init = context3.init;
  }
  if (!session.did && context3.did) {
    session.did = `${context3.did}`;
  }
  if (typeof context3.started === "number") {
    session.started = context3.started;
  }
  if (session.ignoreDuration) {
    session.duration = void 0;
  } else if (typeof context3.duration === "number") {
    session.duration = context3.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context3.release) {
    session.release = context3.release;
  }
  if (context3.environment) {
    session.environment = context3.environment;
  }
  if (!session.ipAddress && context3.ipAddress) {
    session.ipAddress = context3.ipAddress;
  }
  if (!session.userAgent && context3.userAgent) {
    session.userAgent = context3.userAgent;
  }
  if (typeof context3.errors === "number") {
    session.errors = context3.errors;
  }
  if (context3.status) {
    session.status = context3.status;
  }
}
function closeSession(session, status) {
  let context3 = {};
  if (status) {
    context3 = { status };
  } else if (session.status === "ok") {
    context3 = { status: "exited" };
  }
  updateSession(session, context3);
}
function sessionToJSON(session) {
  return {
    sid: `${session.sid}`,
    init: session.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(session.started * 1e3).toISOString(),
    timestamp: new Date(session.timestamp * 1e3).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
    duration: session.duration,
    abnormal_mechanism: session.abnormal_mechanism,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent
    }
  };
}

// node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js
function generateTraceId() {
  return uuid4();
}
function generateSpanId() {
  return uuid4().substring(16);
}

// node_modules/@sentry/core/build/esm/utils/merge.js
function merge(initialObj, mergeObj, levels = 2) {
  if (!mergeObj || typeof mergeObj !== "object" || levels <= 0) {
    return mergeObj;
  }
  if (initialObj && Object.keys(mergeObj).length === 0) {
    return initialObj;
  }
  const output = { ...initialObj };
  for (const key in mergeObj) {
    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
      output[key] = merge(output[key], mergeObj[key], levels - 1);
    }
  }
  return output;
}

// node_modules/@sentry/core/build/esm/utils/spanOnScope.js
var SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(scope, span) {
  if (span) {
    addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
  } else {
    delete scope[SCOPE_SPAN_FIELD];
  }
}
function _getSpanForScope(scope) {
  return scope[SCOPE_SPAN_FIELD];
}

// node_modules/@sentry/core/build/esm/scope.js
var DEFAULT_MAX_BREADCRUMBS = 100;
var Scope = class _Scope {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = {
      traceId: generateTraceId(),
      sampleRand: Math.random()
    };
  }
  /**
   * Clone all data from this scope into a new scope.
   */
  clone() {
    const newScope = new _Scope();
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    if (this._contexts.flags) {
      newScope._contexts.flags = {
        values: [...this._contexts.flags.values]
      };
    }
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    newScope._lastEventId = this._lastEventId;
    _setSpanForScope(newScope, _getSpanForScope(this));
    return newScope;
  }
  /**
   * Update the client assigned to this scope.
   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,
   * as well as manually created scopes.
   */
  setClient(client) {
    this._client = client;
  }
  /**
   * Set the ID of the last captured error event.
   * This is generally only captured on the isolation scope.
   */
  setLastEventId(lastEventId2) {
    this._lastEventId = lastEventId2;
  }
  /**
   * Get the client assigned to this scope.
   */
  getClient() {
    return this._client;
  }
  /**
   * Get the ID of the last captured error event.
   * This is generally only available on the isolation scope.
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  /**
   * Add an event processor that will be called before an event is sent.
   */
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  /**
   * Set the user for this scope.
   * Set to `null` to unset the user.
   */
  setUser(user) {
    this._user = user || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Get the user from this scope.
   */
  getUser() {
    return this._user;
  }
  /**
   * Set an object that will be merged into existing tags on the scope,
   * and will be sent as tags data with the event.
   */
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set a single tag that will be sent as tags data with the event.
   */
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set an object that will be merged into existing extra on the scope,
   * and will be sent as extra data with the event.
   */
  setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set a single key:value extra entry that will be sent as extra data with the event.
   */
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the fingerprint on the scope to send with the events.
   * @param {string[]} fingerprint Fingerprint to group events in Sentry.
   */
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the level on the scope for future events.
   */
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the transaction name on the scope so that the name of e.g. taken server route or
   * the page location is attached to future events.
   *
   * IMPORTANT: Calling this function does NOT change the name of the currently active
   * root span. If you want to change the name of the active root span, use
   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.
   *
   * By default, the SDK updates the scope's transaction name automatically on sensible
   * occasions, such as a page navigation or when handling a new request on the server.
   */
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets context data with the given name.
   * Data passed as context will be normalized. You can also pass `null` to unset the context.
   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.
   */
  setContext(key, context3) {
    if (context3 === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context3;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Set the session for the scope.
   */
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Get the session from the scope.
   */
  getSession() {
    return this._session;
  }
  /**
   * Updates the scope with provided data. Can work in three variations:
   * - plain object containing updatable attributes
   * - Scope instance that'll extract the attributes from
   * - callback function that'll receive the current scope as an argument and allow for modifications
   */
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    const scopeInstance = scopeToMerge instanceof _Scope ? scopeToMerge.getScopeData() : isPlainObject(scopeToMerge) ? captureContext : void 0;
    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
    this._tags = { ...this._tags, ...tags };
    this._extra = { ...this._extra, ...extra };
    this._contexts = { ...this._contexts, ...contexts };
    if (user && Object.keys(user).length) {
      this._user = user;
    }
    if (level) {
      this._level = level;
    }
    if (fingerprint.length) {
      this._fingerprint = fingerprint;
    }
    if (propagationContext) {
      this._propagationContext = propagationContext;
    }
    return this;
  }
  /**
   * Clears the current scope and resets its properties.
   * Note: The client will not be cleared.
   */
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = void 0;
    this._transactionName = void 0;
    this._fingerprint = void 0;
    this._session = void 0;
    _setSpanForScope(this, void 0);
    this._attachments = [];
    this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Adds a breadcrumb to the scope.
   * By default, the last 100 breadcrumbs are kept.
   */
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb,
      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory
      message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message
    };
    this._breadcrumbs.push(mergedBreadcrumb);
    if (this._breadcrumbs.length > maxCrumbs) {
      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);
      this._client?.recordDroppedEvent("buffer_overflow", "log_item");
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Get the last breadcrumb of the scope.
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * Clear all breadcrumbs from the scope.
   */
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Add an attachment to the scope.
   */
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  /**
   * Clear all attachments from the scope.
   */
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  /**
   * Get the data of this scope, which should be applied to an event during processing.
   */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: _getSpanForScope(this)
    };
  }
  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry.
   */
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
    return this;
  }
  /**
   * Add propagation context to the scope, used for distributed tracing
   */
  setPropagationContext(context3) {
    this._propagationContext = context3;
    return this;
  }
  /**
   * Get propagation context from the scope, used for distributed tracing
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * Capture an exception for this scope.
   *
   * @returns {string} The id of the captured Sentry event.
   */
  captureException(exception, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(
      exception,
      {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * Capture a message for this scope.
   *
   * @returns {string} The id of the captured message.
   */
  captureMessage(message, level, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(
      message,
      level,
      {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * Capture a Sentry event for this scope.
   *
   * @returns {string} The id of the captured event.
   */
  captureEvent(event, hint) {
    const eventId = hint?.event_id || uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
};

// node_modules/@sentry/core/build/esm/defaultScopes.js
function getDefaultCurrentScope() {
  return getGlobalSingleton("defaultCurrentScope", () => new Scope());
}
function getDefaultIsolationScope() {
  return getGlobalSingleton("defaultIsolationScope", () => new Scope());
}

// node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js
var AsyncContextStack = class {
  constructor(scope, isolationScope) {
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope();
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope();
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    this._isolationScope = assignedIsolationScope;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(callback) {
    const scope = this._pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e) {
      this._popScope();
      throw e;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then(
        (res) => {
          this._popScope();
          return res;
        },
        (e) => {
          this._popScope();
          throw e;
        }
      );
    }
    this._popScope();
    return maybePromiseResult;
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const scope = this.getScope().clone();
    this._stack.push({
      client: this.getClient(),
      scope
    });
    return scope;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    if (this._stack.length <= 1) return false;
    return !!this._stack.pop();
  }
};
function getAsyncContextStack() {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
}
function withScope(callback) {
  return getAsyncContextStack().withScope(callback);
}
function withSetScope(scope, callback) {
  const stack = getAsyncContextStack();
  return stack.withScope(() => {
    stack.getStackTop().scope = scope;
    return callback(scope);
  });
}
function withIsolationScope(callback) {
  return getAsyncContextStack().withScope(() => {
    return callback(getAsyncContextStack().getIsolationScope());
  });
}
function getStackAsyncContextStrategy() {
  return {
    withIsolationScope,
    withScope,
    withSetScope,
    withSetIsolationScope: (_isolationScope, callback) => {
      return withIsolationScope(callback);
    },
    getCurrentScope: () => getAsyncContextStack().getScope(),
    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
  };
}

// node_modules/@sentry/core/build/esm/asyncContext/index.js
function setAsyncContextStrategy(strategy) {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  sentry.acs = strategy;
}
function getAsyncContextStrategy(carrier) {
  const sentry = getSentryCarrier(carrier);
  if (sentry.acs) {
    return sentry.acs;
  }
  return getStackAsyncContextStrategy();
}

// node_modules/@sentry/core/build/esm/currentScopes.js
function getCurrentScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getCurrentScope();
}
function getIsolationScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getIsolationScope();
}
function getGlobalScope() {
  return getGlobalSingleton("globalScope", () => new Scope());
}
function withScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [scope, callback] = rest;
    if (!scope) {
      return acs.withScope(callback);
    }
    return acs.withSetScope(scope, callback);
  }
  return acs.withScope(rest[0]);
}
function withIsolationScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [isolationScope, callback] = rest;
    if (!isolationScope) {
      return acs.withIsolationScope(callback);
    }
    return acs.withSetIsolationScope(isolationScope, callback);
  }
  return acs.withIsolationScope(rest[0]);
}
function getClient() {
  return getCurrentScope().getClient();
}
function getTraceContextFromScope(scope) {
  const propagationContext = scope.getPropagationContext();
  const { traceId, parentSpanId, propagationSpanId } = propagationContext;
  const traceContext = {
    trace_id: traceId,
    span_id: propagationSpanId || generateSpanId()
  };
  if (parentSpanId) {
    traceContext.parent_span_id = parentSpanId;
  }
  return traceContext;
}

// node_modules/@sentry/core/build/esm/semanticAttributes.js
var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = "sentry.measurement_unit";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = "sentry.measurement_value";
var SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = "sentry.custom_span_name";
var SEMANTIC_ATTRIBUTE_PROFILE_ID = "sentry.profile_id";
var SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = "sentry.exclusive_time";
var SEMANTIC_ATTRIBUTE_CACHE_HIT = "cache.hit";
var SEMANTIC_ATTRIBUTE_CACHE_KEY = "cache.key";
var SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = "cache.item_size";

// node_modules/@sentry/core/build/esm/tracing/spanstatus.js
var SPAN_STATUS_UNSET = 0;
var SPAN_STATUS_OK = 1;
var SPAN_STATUS_ERROR = 2;
function getSpanStatusFromHttpCode(httpStatus) {
  if (httpStatus < 400 && httpStatus >= 100) {
    return { code: SPAN_STATUS_OK };
  }
  if (httpStatus >= 400 && httpStatus < 500) {
    switch (httpStatus) {
      case 401:
        return { code: SPAN_STATUS_ERROR, message: "unauthenticated" };
      case 403:
        return { code: SPAN_STATUS_ERROR, message: "permission_denied" };
      case 404:
        return { code: SPAN_STATUS_ERROR, message: "not_found" };
      case 409:
        return { code: SPAN_STATUS_ERROR, message: "already_exists" };
      case 413:
        return { code: SPAN_STATUS_ERROR, message: "failed_precondition" };
      case 429:
        return { code: SPAN_STATUS_ERROR, message: "resource_exhausted" };
      case 499:
        return { code: SPAN_STATUS_ERROR, message: "cancelled" };
      default:
        return { code: SPAN_STATUS_ERROR, message: "invalid_argument" };
    }
  }
  if (httpStatus >= 500 && httpStatus < 600) {
    switch (httpStatus) {
      case 501:
        return { code: SPAN_STATUS_ERROR, message: "unimplemented" };
      case 503:
        return { code: SPAN_STATUS_ERROR, message: "unavailable" };
      case 504:
        return { code: SPAN_STATUS_ERROR, message: "deadline_exceeded" };
      default:
        return { code: SPAN_STATUS_ERROR, message: "internal_error" };
    }
  }
  return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
}

// node_modules/@sentry/core/build/esm/tracing/utils.js
var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
function setCapturedScopesOnSpan(span, scope, isolationScope) {
  if (span) {
    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
  }
}
function getCapturedScopesOnSpan(span) {
  return {
    scope: span[SCOPE_ON_START_SPAN_FIELD],
    isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
  };
}

// node_modules/@sentry/core/build/esm/utils/parseSampleRate.js
function parseSampleRate(sampleRate) {
  if (typeof sampleRate === "boolean") {
    return Number(sampleRate);
  }
  const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
  if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
    return void 0;
  }
  return rate;
}

// node_modules/@sentry/core/build/esm/utils-hoist/baggage.js
var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
var MAX_BAGGAGE_STRING_LENGTH = 8192;
function baggageHeaderToDynamicSamplingContext(baggageHeader) {
  const baggageObject = parseBaggageHeader(baggageHeader);
  if (!baggageObject) {
    return void 0;
  }
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext;
  } else {
    return void 0;
  }
}
function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {
  if (!dynamicSamplingContext) {
    return void 0;
  }
  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(
    (acc, [dscKey, dscValue]) => {
      if (dscValue) {
        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
      }
      return acc;
    },
    {}
  );
  return objectToBaggageHeader(sentryPrefixedDSC);
}
function parseBaggageHeader(baggageHeader) {
  if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {
    return void 0;
  }
  if (Array.isArray(baggageHeader)) {
    return baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      Object.entries(currBaggageObject).forEach(([key, value]) => {
        acc[key] = value;
      });
      return acc;
    }, {});
  }
  return baggageHeaderToObject(baggageHeader);
}
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
function objectToBaggageHeader(object) {
  if (Object.keys(object).length === 0) {
    return void 0;
  }
  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
      DEBUG_BUILD2 && logger.warn(
        `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`
      );
      return baggageHeader;
    } else {
      return newBaggageHeader;
    }
  }, "");
}

// node_modules/@sentry/core/build/esm/utils-hoist/tracing.js
var TRACEPARENT_REGEXP = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function extractTraceparentData(traceparent) {
  if (!traceparent) {
    return void 0;
  }
  const matches = traceparent.match(TRACEPARENT_REGEXP);
  if (!matches) {
    return void 0;
  }
  let parentSampled;
  if (matches[3] === "1") {
    parentSampled = true;
  } else if (matches[3] === "0") {
    parentSampled = false;
  }
  return {
    traceId: matches[1],
    parentSampled,
    parentSpanId: matches[2]
  };
}
function propagationContextFromHeaders(sentryTrace, baggage) {
  const traceparentData = extractTraceparentData(sentryTrace);
  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);
  if (!traceparentData?.traceId) {
    return {
      traceId: generateTraceId(),
      sampleRand: Math.random()
    };
  }
  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);
  if (dynamicSamplingContext) {
    dynamicSamplingContext.sample_rand = sampleRand.toString();
  }
  const { traceId, parentSpanId, parentSampled } = traceparentData;
  return {
    traceId,
    parentSpanId,
    sampled: parentSampled,
    dsc: dynamicSamplingContext || {},
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
    sampleRand
  };
}
function generateSentryTraceHeader(traceId = generateTraceId(), spanId = generateSpanId(), sampled) {
  let sampledString = "";
  if (sampled !== void 0) {
    sampledString = sampled ? "-1" : "-0";
  }
  return `${traceId}-${spanId}${sampledString}`;
}
function getSampleRandFromTraceparentAndDsc(traceparentData, dsc) {
  const parsedSampleRand = parseSampleRate(dsc?.sample_rand);
  if (parsedSampleRand !== void 0) {
    return parsedSampleRand;
  }
  const parsedSampleRate = parseSampleRate(dsc?.sample_rate);
  if (parsedSampleRate && traceparentData?.parentSampled !== void 0) {
    return traceparentData.parentSampled ? (
      // Returns a sample rand with positive sampling decision [0, sampleRate)
      Math.random() * parsedSampleRate
    ) : (
      // Returns a sample rand with negative sampling decision [sampleRate, 1)
      parsedSampleRate + Math.random() * (1 - parsedSampleRate)
    );
  } else {
    return Math.random();
  }
}

// node_modules/@sentry/core/build/esm/utils/spanUtils.js
var TRACE_FLAG_NONE = 0;
var TRACE_FLAG_SAMPLED = 1;
var hasShownSpanDropWarning = false;
function spanToTransactionTraceContext(span) {
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  const { data, op, parent_span_id, status, origin, links } = spanToJSON(span);
  return {
    parent_span_id,
    span_id,
    trace_id,
    data,
    op,
    status,
    origin,
    links
  };
}
function spanToTraceContext(span) {
  const { spanId, traceId: trace_id, isRemote } = span.spanContext();
  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;
  const scope = getCapturedScopesOnSpan(span).scope;
  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;
  return {
    parent_span_id,
    span_id,
    trace_id
  };
}
function spanToTraceHeader(span) {
  const { traceId, spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  return generateSentryTraceHeader(traceId, spanId, sampled);
}
function convertSpanLinksForEnvelope(links) {
  if (links && links.length > 0) {
    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({
      span_id: spanId,
      trace_id: traceId,
      sampled: traceFlags === TRACE_FLAG_SAMPLED,
      attributes,
      ...restContext
    }));
  } else {
    return void 0;
  }
}
function spanTimeInputToSeconds(input) {
  if (typeof input === "number") {
    return ensureTimestampInSeconds(input);
  }
  if (Array.isArray(input)) {
    return input[0] + input[1] / 1e9;
  }
  if (input instanceof Date) {
    return ensureTimestampInSeconds(input.getTime());
  }
  return timestampInSeconds();
}
function ensureTimestampInSeconds(timestamp) {
  const isMs = timestamp > 9999999999;
  return isMs ? timestamp / 1e3 : timestamp;
}
function spanToJSON(span) {
  if (spanIsSentrySpan(span)) {
    return span.getSpanJSON();
  }
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
    const { attributes, startTime, name, endTime, parentSpanId, status, links } = span;
    return {
      span_id,
      trace_id,
      data: attributes,
      description: name,
      parent_span_id: parentSpanId,
      start_timestamp: spanTimeInputToSeconds(startTime),
      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
      timestamp: spanTimeInputToSeconds(endTime) || void 0,
      status: getStatusMessage(status),
      op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      links: convertSpanLinksForEnvelope(links)
    };
  }
  return {
    span_id,
    trace_id,
    start_timestamp: 0,
    data: {}
  };
}
function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
  const castSpan = span;
  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
}
function spanIsSentrySpan(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return traceFlags === TRACE_FLAG_SAMPLED;
}
function getStatusMessage(status) {
  if (!status || status.code === SPAN_STATUS_UNSET) {
    return void 0;
  }
  if (status.code === SPAN_STATUS_OK) {
    return "ok";
  }
  return status.message || "unknown_error";
}
var CHILD_SPANS_FIELD = "_sentryChildSpans";
var ROOT_SPAN_FIELD = "_sentryRootSpan";
function addChildSpanToSpan(span, childSpan) {
  const rootSpan = span[ROOT_SPAN_FIELD] || span;
  addNonEnumerableProperty(childSpan, ROOT_SPAN_FIELD, rootSpan);
  if (span[CHILD_SPANS_FIELD]) {
    span[CHILD_SPANS_FIELD].add(childSpan);
  } else {
    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, /* @__PURE__ */ new Set([childSpan]));
  }
}
function getSpanDescendants(span) {
  const resultSet = /* @__PURE__ */ new Set();
  function addSpanChildren(span2) {
    if (resultSet.has(span2)) {
      return;
    } else if (spanIsSampled(span2)) {
      resultSet.add(span2);
      const childSpans = span2[CHILD_SPANS_FIELD] ? Array.from(span2[CHILD_SPANS_FIELD]) : [];
      for (const childSpan of childSpans) {
        addSpanChildren(childSpan);
      }
    }
  }
  addSpanChildren(span);
  return Array.from(resultSet);
}
function getRootSpan(span) {
  return span[ROOT_SPAN_FIELD] || span;
}
function getActiveSpan2() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (acs.getActiveSpan) {
    return acs.getActiveSpan();
  }
  return _getSpanForScope(getCurrentScope());
}
function showSpanDropWarning() {
  if (!hasShownSpanDropWarning) {
    consoleSandbox(() => {
      console.warn(
        "[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly."
      );
    });
    hasShownSpanDropWarning = true;
  }
}

// node_modules/@sentry/core/build/esm/tracing/errors.js
var errorsInstrumented = false;
function registerSpanErrorInstrumentation() {
  if (errorsInstrumented) {
    return;
  }
  errorsInstrumented = true;
  addGlobalErrorInstrumentationHandler(errorCallback);
  addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
}
function errorCallback() {
  const activeSpan = getActiveSpan2();
  const rootSpan = activeSpan && getRootSpan(activeSpan);
  if (rootSpan) {
    const message = "internal_error";
    DEBUG_BUILD && logger.log(`[Tracing] Root span: ${message} -> Global error occurred`);
    rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message });
  }
}
errorCallback.tag = "sentry_tracingErrorCallback";

// node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js
function hasSpansEnabled(maybeOptions) {
  if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
    return false;
  }
  const options = maybeOptions || getClient()?.getOptions();
  return !!options && // Note: This check is `!= null`, meaning "nullish". `0` is not "nullish", `undefined` and `null` are. (This comment was brought to you by 15 minutes of questioning life)
  (options.tracesSampleRate != null || !!options.tracesSampler);
}

// node_modules/@sentry/core/build/esm/constants.js
var DEFAULT_ENVIRONMENT = "production";

// node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js
var FROZEN_DSC_FIELD = "_frozenDsc";
function freezeDscOnSpan(span, dsc) {
  const spanWithMaybeDsc = span;
  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);
}
function getDynamicSamplingContextFromClient(trace_id, client) {
  const options = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const dsc = {
    environment: options.environment || DEFAULT_ENVIRONMENT,
    release: options.release,
    public_key,
    trace_id
  };
  client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromScope(client, scope) {
  const propagationContext = scope.getPropagationContext();
  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const rootSpan = getRootSpan(span);
  const rootSpanJson = spanToJSON(rootSpan);
  const rootSpanAttributes = rootSpanJson.data;
  const traceState = rootSpan.spanContext().traceState;
  const rootSpanSampleRate = traceState?.get("sentry.sample_rate") ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  function applyLocalSampleRateToDsc(dsc2) {
    if (typeof rootSpanSampleRate === "number" || typeof rootSpanSampleRate === "string") {
      dsc2.sample_rate = `${rootSpanSampleRate}`;
    }
    return dsc2;
  }
  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
  if (frozenDsc) {
    return applyLocalSampleRateToDsc(frozenDsc);
  }
  const traceStateDsc = traceState?.get("sentry.dsc");
  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);
  if (dscOnTraceState) {
    return applyLocalSampleRateToDsc(dscOnTraceState);
  }
  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);
  const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  const name = rootSpanJson.description;
  if (source !== "url" && name) {
    dsc.transaction = name;
  }
  if (hasSpansEnabled()) {
    dsc.sampled = String(spanIsSampled(rootSpan));
    dsc.sample_rand = // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans
    // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span
    traceState?.get("sentry.sample_rand") ?? // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)
    getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();
  }
  applyLocalSampleRateToDsc(dsc);
  client.emit("createDsc", dsc, rootSpan);
  return dsc;
}

// node_modules/@sentry/core/build/esm/tracing/sentryNonRecordingSpan.js
var SentryNonRecordingSpan = class {
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || generateTraceId();
    this._spanId = spanContext.spanId || generateSpanId();
  }
  /** @inheritdoc */
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: TRACE_FLAG_NONE
    };
  }
  /** @inheritdoc */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  end(_timestamp) {
  }
  /** @inheritdoc */
  setAttribute(_key, _value) {
    return this;
  }
  /** @inheritdoc */
  setAttributes(_values) {
    return this;
  }
  /** @inheritdoc */
  setStatus(_status) {
    return this;
  }
  /** @inheritdoc */
  updateName(_name) {
    return this;
  }
  /** @inheritdoc */
  isRecording() {
    return false;
  }
  /** @inheritdoc */
  addEvent(_name, _attributesOrStartTime, _startTime) {
    return this;
  }
  /** @inheritDoc */
  addLink(_link) {
    return this;
  }
  /** @inheritDoc */
  addLinks(_links) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  recordException(_exception, _time) {
  }
};

// node_modules/@sentry/core/build/esm/utils/handleCallbackErrors.js
function handleCallbackErrors(fn, onError, onFinally = () => {
}) {
  let maybePromiseResult;
  try {
    maybePromiseResult = fn();
  } catch (e) {
    onError(e);
    onFinally();
    throw e;
  }
  return maybeHandlePromiseRejection(maybePromiseResult, onError, onFinally);
}
function maybeHandlePromiseRejection(value, onError, onFinally) {
  if (isThenable(value)) {
    return value.then(
      (res) => {
        onFinally();
        return res;
      },
      (e) => {
        onError(e);
        onFinally();
        throw e;
      }
    );
  }
  onFinally();
  return value;
}

// node_modules/@sentry/core/build/esm/tracing/logSpans.js
function logSpanStart(span) {
  if (!DEBUG_BUILD) return;
  const { description = "< unknown name >", op = "< unknown op >", parent_span_id: parentSpanId } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const header = `[Tracing] Starting ${sampled ? "sampled" : "unsampled"} ${isRootSpan ? "root " : ""}span`;
  const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];
  if (parentSpanId) {
    infoParts.push(`parent ID: ${parentSpanId}`);
  }
  if (!isRootSpan) {
    const { op: op2, description: description2 } = spanToJSON(rootSpan);
    infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);
    if (op2) {
      infoParts.push(`root op: ${op2}`);
    }
    if (description2) {
      infoParts.push(`root description: ${description2}`);
    }
  }
  logger.log(`${header}
  ${infoParts.join("\n  ")}`);
}
function logSpanEnd(span) {
  if (!DEBUG_BUILD) return;
  const { description = "< unknown name >", op = "< unknown op >" } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const msg = `[Tracing] Finishing "${op}" ${isRootSpan ? "root " : ""}span "${description}" with ID ${spanId}`;
  logger.log(msg);
}

// node_modules/@sentry/core/build/esm/tracing/sampling.js
function sampleSpan(options, samplingContext, sampleRand) {
  if (!hasSpansEnabled(options)) {
    return [false];
  }
  let localSampleRateWasApplied = void 0;
  let sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler({
      ...samplingContext,
      inheritOrSampleWith: (fallbackSampleRate) => {
        if (typeof samplingContext.parentSampleRate === "number") {
          return samplingContext.parentSampleRate;
        }
        if (typeof samplingContext.parentSampled === "boolean") {
          return Number(samplingContext.parentSampled);
        }
        return fallbackSampleRate;
      }
    });
    localSampleRateWasApplied = true;
  } else if (samplingContext.parentSampled !== void 0) {
    sampleRate = samplingContext.parentSampled;
  } else if (typeof options.tracesSampleRate !== "undefined") {
    sampleRate = options.tracesSampleRate;
    localSampleRateWasApplied = true;
  }
  const parsedSampleRate = parseSampleRate(sampleRate);
  if (parsedSampleRate === void 0) {
    DEBUG_BUILD && logger.warn(
      `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        sampleRate
      )} of type ${JSON.stringify(typeof sampleRate)}.`
    );
    return [false];
  }
  if (!parsedSampleRate) {
    DEBUG_BUILD && logger.log(
      `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
    );
    return [false, parsedSampleRate, localSampleRateWasApplied];
  }
  const shouldSample = sampleRand < parsedSampleRate;
  if (!shouldSample) {
    DEBUG_BUILD && logger.log(
      `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
        sampleRate
      )})`
    );
  }
  return [shouldSample, parsedSampleRate, localSampleRateWasApplied];
}

// node_modules/@sentry/core/build/esm/utils-hoist/dsn.js
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword = false) {
  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
}
function dsnFromString(str) {
  const match = DSN_REGEX.exec(str);
  if (!match) {
    consoleSandbox(() => {
      console.error(`Invalid Sentry Dsn: ${str}`);
    });
    return void 0;
  }
  const [protocol, publicKey, pass = "", host = "", port = "", lastPath = ""] = match.slice(1);
  let path = "";
  let projectId = lastPath;
  const split = projectId.split("/");
  if (split.length > 1) {
    path = split.slice(0, -1).join("/");
    projectId = split.pop();
  }
  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!DEBUG_BUILD2) {
    return true;
  }
  const { port, projectId, protocol } = dsn;
  const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  const hasMissingRequiredComponent = requiredComponents.find((component) => {
    if (!dsn[component]) {
      logger.error(`Invalid Sentry Dsn: ${component} missing`);
      return true;
    }
    return false;
  });
  if (hasMissingRequiredComponent) {
    return false;
  }
  if (!projectId.match(/^\d+$/)) {
    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
    return false;
  }
  if (!isValidProtocol(protocol)) {
    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
    return false;
  }
  if (port && isNaN(parseInt(port, 10))) {
    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
    return false;
  }
  return true;
}
function makeDsn(from) {
  const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
  if (!components || !validateDsn(components)) {
    return void 0;
  }
  return components;
}

// node_modules/@sentry/core/build/esm/utils-hoist/normalize.js
function normalize(input, depth = 100, maxProperties = Infinity) {
  try {
    return visit("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}
function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
  const normalized = normalize(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
  const [memoize, unmemoize] = memo;
  if (value == null || // this matches null and undefined -> eqeq not eqeqeq
  ["boolean", "string"].includes(typeof value) || typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  const stringified = stringifyValue(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (value["__sentry_skip_normalization__"]) {
    return value;
  }
  const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
  if (remainingDepth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize(value)) {
    return "[Circular ~]";
  }
  const valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
    } catch (err) {
    }
  }
  const normalized = Array.isArray(value) ? [] : {};
  let numAdded = 0;
  const visitable = convertToPlainObject(value);
  for (const visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
    numAdded++;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isVueViewModel(value)) {
      return "[VueViewModel]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && !Number.isFinite(value)) {
      return `[${value}]`;
    }
    if (typeof value === "function") {
      return `[Function: ${getFunctionName(value)}]`;
    }
    if (typeof value === "symbol") {
      return `[${String(value)}]`;
    }
    if (typeof value === "bigint") {
      return `[BigInt: ${String(value)}]`;
    }
    const objName = getConstructorName(value);
    if (/^HTML(\w*)Element$/.test(objName)) {
      return `[HTMLElement: ${objName}]`;
    }
    return `[object ${objName}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}
function getConstructorName(value) {
  const prototype = Object.getPrototypeOf(value);
  return prototype?.constructor ? prototype.constructor.name : "null prototype";
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
function memoBuilder() {
  const inner = /* @__PURE__ */ new WeakSet();
  function memoize(obj) {
    if (inner.has(obj)) {
      return true;
    }
    inner.add(obj);
    return false;
  }
  function unmemoize(obj) {
    inner.delete(obj);
  }
  return [memoize, unmemoize];
}

// node_modules/@sentry/core/build/esm/utils-hoist/envelope.js
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]];
}
function forEachEnvelopeItem(envelope, callback) {
  const envelopeItems = envelope[1];
  for (const envelopeItem of envelopeItems) {
    const envelopeItemType = envelopeItem[0].type;
    const result = callback(envelopeItem, envelopeItemType);
    if (result) {
      return true;
    }
  }
  return false;
}
function encodeUTF8(input) {
  const carrier = getSentryCarrier(GLOBAL_OBJ);
  return carrier.encodePolyfill ? carrier.encodePolyfill(input) : new TextEncoder().encode(input);
}
function serializeEnvelope(envelope) {
  const [envHeaders, items] = envelope;
  let parts = JSON.stringify(envHeaders);
  function append(next) {
    if (typeof parts === "string") {
      parts = typeof next === "string" ? parts + next : [encodeUTF8(parts), next];
    } else {
      parts.push(typeof next === "string" ? encodeUTF8(next) : next);
    }
  }
  for (const item of items) {
    const [itemHeaders, payload] = item;
    append(`
${JSON.stringify(itemHeaders)}
`);
    if (typeof payload === "string" || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch (e) {
        stringifiedPayload = JSON.stringify(normalize(payload));
      }
      append(stringifiedPayload);
    }
  }
  return typeof parts === "string" ? parts : concatBuffers(parts);
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
  const merged = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }
  return merged;
}
function createSpanEnvelopeItem(spanJson) {
  const spanHeaders = {
    type: "span"
  };
  return [spanHeaders, spanJson];
}
function createAttachmentEnvelopeItem(attachment) {
  const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data) : attachment.data;
  return [
    {
      type: "attachment",
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType
    },
    buffer
  ];
}
var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  otel_log: "log_item"
};
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}
function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
  if (!metadataOrEvent?.sdk) {
    return;
  }
  const { name, version } = metadataOrEvent.sdk;
  return { name, version };
}
function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
  const dynamicSamplingContext = event.sdkProcessingMetadata?.dynamicSamplingContext;
  return {
    event_id: event.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
    ...dynamicSamplingContext && {
      trace: dynamicSamplingContext
    }
  };
}

// node_modules/@sentry/core/build/esm/envelope.js
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
  event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
  return event;
}
function createSessionEnvelope(session, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
  return createEnvelope(envelopeHeaders, [envelopeItem]);
}
function createEventEnvelope(event, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
  enhanceEventWithSdkInfo(event, metadata?.sdk);
  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
  delete event.sdkProcessingMetadata;
  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}
function createSpanEnvelope(spans, client) {
  function dscHasRequiredProps(dsc2) {
    return !!dsc2.trace_id && !!dsc2.public_key;
  }
  const dsc = getDynamicSamplingContextFromSpan(spans[0]);
  const dsn = client?.getDsn();
  const tunnel = client?.getOptions().tunnel;
  const headers = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...dscHasRequiredProps(dsc) && { trace: dsc },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const beforeSendSpan = client?.getOptions().beforeSendSpan;
  const convertToSpanJSON = beforeSendSpan ? (span) => {
    const spanJson = spanToJSON(span);
    const processedSpan = beforeSendSpan(spanJson);
    if (!processedSpan) {
      showSpanDropWarning();
      return spanJson;
    }
    return processedSpan;
  } : spanToJSON;
  const items = [];
  for (const span of spans) {
    const spanJson = convertToSpanJSON(span);
    if (spanJson) {
      items.push(createSpanEnvelopeItem(spanJson));
    }
  }
  return createEnvelope(headers, items);
}

// node_modules/@sentry/core/build/esm/tracing/measurement.js
function timedEventsToMeasurements(events) {
  if (!events || events.length === 0) {
    return void 0;
  }
  const measurements = {};
  events.forEach((event) => {
    const attributes = event.attributes || {};
    const unit = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT];
    const value = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE];
    if (typeof unit === "string" && typeof value === "number") {
      measurements[event.name] = { value, unit };
    }
  });
  return measurements;
}

// node_modules/@sentry/core/build/esm/tracing/sentrySpan.js
var MAX_SPAN_COUNT = 1e3;
var SentrySpan = class {
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /** The timed events added to this span. */
  /** if true, treat span as a standalone span (not part of a transaction) */
  /**
   * You should never call the constructor manually, always use `Sentry.startSpan()`
   * or other span methods.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || generateTraceId();
    this._spanId = spanContext.spanId || generateSpanId();
    this._startTime = spanContext.startTimestamp || timestampInSeconds();
    this._links = spanContext.links;
    this._attributes = {};
    this.setAttributes({
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "manual",
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
      ...spanContext.attributes
    });
    this._name = spanContext.name;
    if (spanContext.parentSpanId) {
      this._parentSpanId = spanContext.parentSpanId;
    }
    if ("sampled" in spanContext) {
      this._sampled = spanContext.sampled;
    }
    if (spanContext.endTimestamp) {
      this._endTime = spanContext.endTimestamp;
    }
    this._events = [];
    this._isStandaloneSpan = spanContext.isStandalone;
    if (this._endTime) {
      this._onSpanEnded();
    }
  }
  /** @inheritDoc */
  addLink(link) {
    if (this._links) {
      this._links.push(link);
    } else {
      this._links = [link];
    }
    return this;
  }
  /** @inheritDoc */
  addLinks(links) {
    if (this._links) {
      this._links.push(...links);
    } else {
      this._links = links;
    }
    return this;
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  recordException(_exception, _time) {
  }
  /** @inheritdoc */
  spanContext() {
    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
    return {
      spanId,
      traceId,
      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE
    };
  }
  /** @inheritdoc */
  setAttribute(key, value) {
    if (value === void 0) {
      delete this._attributes[key];
    } else {
      this._attributes[key] = value;
    }
    return this;
  }
  /** @inheritdoc */
  setAttributes(attributes) {
    Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for browser tracing where we want to adjust the start time afterwards.
   * USE THIS WITH CAUTION!
   *
   * @hidden
   * @internal
   */
  updateStartTime(timeInput) {
    this._startTime = spanTimeInputToSeconds(timeInput);
  }
  /**
   * @inheritDoc
   */
  setStatus(value) {
    this._status = value;
    return this;
  }
  /**
   * @inheritDoc
   */
  updateName(name) {
    this._name = name;
    this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, "custom");
    return this;
  }
  /** @inheritdoc */
  end(endTimestamp) {
    if (this._endTime) {
      return;
    }
    this._endTime = spanTimeInputToSeconds(endTimestamp);
    logSpanEnd(this);
    this._onSpanEnded();
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: getStatusMessage(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],
      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
      measurements: timedEventsToMeasurements(this._events),
      is_segment: this._isStandaloneSpan && getRootSpan(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : void 0,
      links: convertSpanLinksForEnvelope(this._links)
    };
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * @inheritdoc
   */
  addEvent(name, attributesOrStartTime, startTime) {
    DEBUG_BUILD && logger.log("[Tracing] Adding an event to span:", name);
    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();
    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};
    const event = {
      name,
      time: spanTimeInputToSeconds(time),
      attributes
    };
    this._events.push(event);
    return this;
  }
  /**
   * This method should generally not be used,
   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.
   * USE THIS WITH CAUTION!
   * @internal
   * @hidden
   * @experimental
   */
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  /** Emit `spanEnd` when the span is ended. */
  _onSpanEnded() {
    const client = getClient();
    if (client) {
      client.emit("spanEnd", this);
    }
    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);
    if (!isSegmentSpan) {
      return;
    }
    if (this._isStandaloneSpan) {
      if (this._sampled) {
        sendSpanEnvelope(createSpanEnvelope([this], client));
      } else {
        DEBUG_BUILD && logger.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled.");
        if (client) {
          client.recordDroppedEvent("sample_rate", "span");
        }
      }
      return;
    }
    const transactionEvent = this._convertSpanToTransaction();
    if (transactionEvent) {
      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();
      scope.captureEvent(transactionEvent);
    }
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _convertSpanToTransaction() {
    if (!isFullFinishedSpan(spanToJSON(this))) {
      return void 0;
    }
    if (!this._name) {
      DEBUG_BUILD && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
      this._name = "<unlabeled transaction>";
    }
    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);
    if (this._sampled !== true) {
      return void 0;
    }
    const finishedSpans = getSpanDescendants(this).filter((span) => span !== this && !isStandaloneSpan(span));
    const spans = finishedSpans.map((span) => spanToJSON(span)).filter(isFullFinishedSpan);
    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    delete this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
    spans.forEach((span) => {
      delete span.data[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
    });
    const transaction = {
      contexts: {
        trace: spanToTransactionTraceContext(this)
      },
      spans: (
        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here
        // we do not use spans anymore after this point
        spans.length > MAX_SPAN_COUNT ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT) : spans
      ),
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope,
        capturedSpanIsolationScope,
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)
      },
      ...source && {
        transaction_info: {
          source
        }
      }
    };
    const measurements = timedEventsToMeasurements(this._events);
    const hasMeasurements = measurements && Object.keys(measurements).length;
    if (hasMeasurements) {
      DEBUG_BUILD && logger.log(
        "[Measurements] Adding measurements to transaction event",
        JSON.stringify(measurements, void 0, 2)
      );
      transaction.measurements = measurements;
    }
    return transaction;
  }
};
function isSpanTimeInput(value) {
  return value && typeof value === "number" || value instanceof Date || Array.isArray(value);
}
function isFullFinishedSpan(input) {
  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;
}
function isStandaloneSpan(span) {
  return span instanceof SentrySpan && span.isStandaloneSpan();
}
function sendSpanEnvelope(envelope) {
  const client = getClient();
  if (!client) {
    return;
  }
  const spanItems = envelope[1];
  if (!spanItems || spanItems.length === 0) {
    client.recordDroppedEvent("before_send", "span");
    return;
  }
  client.sendEnvelope(envelope);
}

// node_modules/@sentry/core/build/esm/tracing/trace.js
var SUPPRESS_TRACING_KEY = "__SENTRY_SUPPRESS_TRACING__";
function startSpan(options, callback) {
  const acs = getAcs();
  if (acs.startSpan) {
    return acs.startSpan(options, callback);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan, scope: customScope } = options;
  const customForkedScope = customScope?.clone();
  return withScope2(customForkedScope, () => {
    const wrapper = getActiveSpanWrapper(customParentSpan);
    return wrapper(() => {
      const scope = getCurrentScope();
      const parentSpan = getParentSpan(scope);
      const shouldSkipSpan = options.onlyIfParent && !parentSpan;
      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan() : createChildOrRootSpan({
        parentSpan,
        spanArguments,
        forceTransaction,
        scope
      });
      _setSpanForScope(scope, activeSpan);
      return handleCallbackErrors(
        () => callback(activeSpan),
        () => {
          const { status } = spanToJSON(activeSpan);
          if (activeSpan.isRecording() && (!status || status === "ok")) {
            activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
          }
        },
        () => {
          activeSpan.end();
        }
      );
    });
  });
}
function withActiveSpan(span, callback) {
  const acs = getAcs();
  if (acs.withActiveSpan) {
    return acs.withActiveSpan(span, callback);
  }
  return withScope2((scope) => {
    _setSpanForScope(scope, span || void 0);
    return callback(scope);
  });
}
function suppressTracing(callback) {
  const acs = getAcs();
  if (acs.suppressTracing) {
    return acs.suppressTracing(callback);
  }
  return withScope2((scope) => {
    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });
    return callback();
  });
}
function createChildOrRootSpan({
  parentSpan,
  spanArguments,
  forceTransaction,
  scope
}) {
  if (!hasSpansEnabled()) {
    const span2 = new SentryNonRecordingSpan();
    if (forceTransaction || !parentSpan) {
      const dsc = {
        sampled: "false",
        sample_rate: "0",
        transaction: spanArguments.name,
        ...getDynamicSamplingContextFromSpan(span2)
      };
      freezeDscOnSpan(span2, dsc);
    }
    return span2;
  }
  const isolationScope = getIsolationScope();
  let span;
  if (parentSpan && !forceTransaction) {
    span = _startChildSpan(parentSpan, scope, spanArguments);
    addChildSpanToSpan(parentSpan, span);
  } else if (parentSpan) {
    const dsc = getDynamicSamplingContextFromSpan(parentSpan);
    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();
    const parentSampled = spanIsSampled(parentSpan);
    span = _startRootSpan(
      {
        traceId,
        parentSpanId,
        ...spanArguments
      },
      scope,
      parentSampled
    );
    freezeDscOnSpan(span, dsc);
  } else {
    const {
      traceId,
      dsc,
      parentSpanId,
      sampled: parentSampled
    } = {
      ...isolationScope.getPropagationContext(),
      ...scope.getPropagationContext()
    };
    span = _startRootSpan(
      {
        traceId,
        parentSpanId,
        ...spanArguments
      },
      scope,
      parentSampled
    );
    if (dsc) {
      freezeDscOnSpan(span, dsc);
    }
  }
  logSpanStart(span);
  setCapturedScopesOnSpan(span, scope, isolationScope);
  return span;
}
function parseSentrySpanArguments(options) {
  const exp = options.experimental || {};
  const initialCtx = {
    isStandalone: exp.standalone,
    ...options
  };
  if (options.startTime) {
    const ctx = { ...initialCtx };
    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);
    delete ctx.startTime;
    return ctx;
  }
  return initialCtx;
}
function getAcs() {
  const carrier = getMainCarrier();
  return getAsyncContextStrategy(carrier);
}
function _startRootSpan(spanArguments, scope, parentSampled) {
  const client = getClient();
  const options = client?.getOptions() || {};
  const { name = "", attributes } = spanArguments;
  const currentPropagationContext = scope.getPropagationContext();
  const [sampled, sampleRate, localSampleRateWasApplied] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? [false] : sampleSpan(
    options,
    {
      name,
      parentSampled,
      attributes,
      parentSampleRate: parseSampleRate(currentPropagationContext.dsc?.sample_rate)
    },
    currentPropagationContext.sampleRand
  );
  const rootSpan = new SentrySpan({
    ...spanArguments,
    attributes: {
      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "custom",
      [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate !== void 0 && localSampleRateWasApplied ? sampleRate : void 0,
      ...spanArguments.attributes
    },
    sampled
  });
  if (!sampled && client) {
    DEBUG_BUILD && logger.log("[Tracing] Discarding root span because its trace was not chosen to be sampled.");
    client.recordDroppedEvent("sample_rate", "transaction");
  }
  if (client) {
    client.emit("spanStart", rootSpan);
  }
  return rootSpan;
}
function _startChildSpan(parentSpan, scope, spanArguments) {
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);
  const childSpan = sampled ? new SentrySpan({
    ...spanArguments,
    parentSpanId: spanId,
    traceId,
    sampled
  }) : new SentryNonRecordingSpan({ traceId });
  addChildSpanToSpan(parentSpan, childSpan);
  const client = getClient();
  if (client) {
    client.emit("spanStart", childSpan);
    if (spanArguments.endTimestamp) {
      client.emit("spanEnd", childSpan);
    }
  }
  return childSpan;
}
function getParentSpan(scope) {
  const span = _getSpanForScope(scope);
  if (!span) {
    return void 0;
  }
  const client = getClient();
  const options = client ? client.getOptions() : {};
  if (options.parentSpanIsAlwaysRootSpan) {
    return getRootSpan(span);
  }
  return span;
}
function getActiveSpanWrapper(parentSpan) {
  return parentSpan !== void 0 ? (callback) => {
    return withActiveSpan(parentSpan, callback);
  } : (callback) => callback();
}

// node_modules/@sentry/core/build/esm/eventProcessors.js
function notifyEventProcessors(processors, event, hint, index = 0) {
  return new SyncPromise((resolve2, reject) => {
    const processor = processors[index];
    if (event === null || typeof processor !== "function") {
      resolve2(event);
    } else {
      const result = processor({ ...event }, hint);
      DEBUG_BUILD && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);
      if (isThenable(result)) {
        void result.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve2)).then(null, reject);
      } else {
        void notifyEventProcessors(processors, result, hint, index + 1).then(resolve2).then(null, reject);
      }
    }
  });
}

// node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js
var parsedStackResults;
var lastKeysCount;
var cachedFilenameDebugIds;
function getFilenameToDebugIdMap(stackParser) {
  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
  if (!debugIdMap) {
    return {};
  }
  const debugIdKeys = Object.keys(debugIdMap);
  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {
    return cachedFilenameDebugIds;
  }
  lastKeysCount = debugIdKeys.length;
  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {
    if (!parsedStackResults) {
      parsedStackResults = {};
    }
    const result = parsedStackResults[stackKey];
    if (result) {
      acc[result[0]] = result[1];
    } else {
      const parsedStack = stackParser(stackKey);
      for (let i = parsedStack.length - 1; i >= 0; i--) {
        const stackFrame = parsedStack[i];
        const filename = stackFrame?.filename;
        const debugId = debugIdMap[stackKey];
        if (filename && debugId) {
          acc[filename] = debugId;
          parsedStackResults[stackKey] = [filename, debugId];
          break;
        }
      }
    }
    return acc;
  }, {});
  return cachedFilenameDebugIds;
}

// node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js
function applyScopeDataToEvent(event, data) {
  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
  applyDataToEvent(event, data);
  if (span) {
    applySpanToEvent(event, span);
  }
  applyFingerprintToEvent(event, fingerprint);
  applyBreadcrumbsToEvent(event, breadcrumbs);
  applySdkMetadataToEvent(event, sdkProcessingMetadata);
}
function mergeScopeData(data, mergeData) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    sdkProcessingMetadata,
    breadcrumbs,
    fingerprint,
    eventProcessors,
    attachments,
    propagationContext,
    transactionName,
    span
  } = mergeData;
  mergeAndOverwriteScopeData(data, "extra", extra);
  mergeAndOverwriteScopeData(data, "tags", tags);
  mergeAndOverwriteScopeData(data, "user", user);
  mergeAndOverwriteScopeData(data, "contexts", contexts);
  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);
  if (level) {
    data.level = level;
  }
  if (transactionName) {
    data.transactionName = transactionName;
  }
  if (span) {
    data.span = span;
  }
  if (breadcrumbs.length) {
    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
  }
  if (fingerprint.length) {
    data.fingerprint = [...data.fingerprint, ...fingerprint];
  }
  if (eventProcessors.length) {
    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
  }
  if (attachments.length) {
    data.attachments = [...data.attachments, ...attachments];
  }
  data.propagationContext = { ...data.propagationContext, ...propagationContext };
}
function mergeAndOverwriteScopeData(data, prop, mergeVal) {
  data[prop] = merge(data[prop], mergeVal, 1);
}
function applyDataToEvent(event, data) {
  const { extra, tags, user, contexts, level, transactionName } = data;
  if (Object.keys(extra).length) {
    event.extra = { ...extra, ...event.extra };
  }
  if (Object.keys(tags).length) {
    event.tags = { ...tags, ...event.tags };
  }
  if (Object.keys(user).length) {
    event.user = { ...user, ...event.user };
  }
  if (Object.keys(contexts).length) {
    event.contexts = { ...contexts, ...event.contexts };
  }
  if (level) {
    event.level = level;
  }
  if (transactionName && event.type !== "transaction") {
    event.transaction = transactionName;
  }
}
function applyBreadcrumbsToEvent(event, breadcrumbs) {
  const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
}
function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
  event.sdkProcessingMetadata = {
    ...event.sdkProcessingMetadata,
    ...sdkProcessingMetadata
  };
}
function applySpanToEvent(event, span) {
  event.contexts = {
    trace: spanToTraceContext(span),
    ...event.contexts
  };
  event.sdkProcessingMetadata = {
    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
    ...event.sdkProcessingMetadata
  };
  const rootSpan = getRootSpan(span);
  const transactionName = spanToJSON(rootSpan).description;
  if (transactionName && !event.transaction && event.type === "transaction") {
    event.transaction = transactionName;
  }
}
function applyFingerprintToEvent(event, fingerprint) {
  event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
  if (fingerprint) {
    event.fingerprint = event.fingerprint.concat(fingerprint);
  }
  if (!event.fingerprint.length) {
    delete event.fingerprint;
  }
}

// node_modules/@sentry/core/build/esm/utils/prepareEvent.js
function prepareEvent(options, event, hint, scope, client, isolationScope) {
  const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
  const prepared = {
    ...event,
    event_id: event.event_id || hint.event_id || uuid4(),
    timestamp: event.timestamp || dateTimestampInSeconds()
  };
  const integrations = hint.integrations || options.integrations.map((i) => i.name);
  applyClientOptions(prepared, options);
  applyIntegrationsMetadata(prepared, integrations);
  if (client) {
    client.emit("applyFrameMetadata", event);
  }
  if (event.type === void 0) {
    applyDebugIds(prepared, options.stackParser);
  }
  const finalScope = getFinalScope(scope, hint.captureContext);
  if (hint.mechanism) {
    addExceptionMechanism(prepared, hint.mechanism);
  }
  const clientEventProcessors = client ? client.getEventProcessors() : [];
  const data = getGlobalScope().getScopeData();
  if (isolationScope) {
    const isolationData = isolationScope.getScopeData();
    mergeScopeData(data, isolationData);
  }
  if (finalScope) {
    const finalScopeData = finalScope.getScopeData();
    mergeScopeData(data, finalScopeData);
  }
  const attachments = [...hint.attachments || [], ...data.attachments];
  if (attachments.length) {
    hint.attachments = attachments;
  }
  applyScopeDataToEvent(prepared, data);
  const eventProcessors = [
    ...clientEventProcessors,
    // Run scope event processors _after_ all other processors
    ...data.eventProcessors
  ];
  const result = notifyEventProcessors(eventProcessors, prepared, hint);
  return result.then((evt) => {
    if (evt) {
      applyDebugMeta(evt);
    }
    if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
    }
    return evt;
  });
}
function applyClientOptions(event, options) {
  const { environment, release: release2, dist, maxValueLength = 250 } = options;
  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;
  if (!event.release && release2) {
    event.release = release2;
  }
  if (!event.dist && dist) {
    event.dist = dist;
  }
  const request = event.request;
  if (request?.url) {
    request.url = truncate(request.url, maxValueLength);
  }
}
function applyDebugIds(event, stackParser) {
  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);
  event.exception?.values?.forEach((exception) => {
    exception.stacktrace?.frames?.forEach((frame) => {
      if (frame.filename) {
        frame.debug_id = filenameDebugIdMap[frame.filename];
      }
    });
  });
}
function applyDebugMeta(event) {
  const filenameDebugIdMap = {};
  event.exception?.values?.forEach((exception) => {
    exception.stacktrace?.frames?.forEach((frame) => {
      if (frame.debug_id) {
        if (frame.abs_path) {
          filenameDebugIdMap[frame.abs_path] = frame.debug_id;
        } else if (frame.filename) {
          filenameDebugIdMap[frame.filename] = frame.debug_id;
        }
        delete frame.debug_id;
      }
    });
  });
  if (Object.keys(filenameDebugIdMap).length === 0) {
    return;
  }
  event.debug_meta = event.debug_meta || {};
  event.debug_meta.images = event.debug_meta.images || [];
  const images = event.debug_meta.images;
  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {
    images.push({
      type: "sourcemap",
      code_file: filename,
      debug_id
    });
  });
}
function applyIntegrationsMetadata(event, integrationNames) {
  if (integrationNames.length > 0) {
    event.sdk = event.sdk || {};
    event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
  }
}
function normalizeEvent(event, depth, maxBreadth) {
  if (!event) {
    return null;
  }
  const normalized = {
    ...event,
    ...event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map((b) => ({
        ...b,
        ...b.data && {
          data: normalize(b.data, depth, maxBreadth)
        }
      }))
    },
    ...event.user && {
      user: normalize(event.user, depth, maxBreadth)
    },
    ...event.contexts && {
      contexts: normalize(event.contexts, depth, maxBreadth)
    },
    ...event.extra && {
      extra: normalize(event.extra, depth, maxBreadth)
    }
  };
  if (event.contexts?.trace && normalized.contexts) {
    normalized.contexts.trace = event.contexts.trace;
    if (event.contexts.trace.data) {
      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
    }
  }
  if (event.spans) {
    normalized.spans = event.spans.map((span) => {
      return {
        ...span,
        ...span.data && {
          data: normalize(span.data, depth, maxBreadth)
        }
      };
    });
  }
  if (event.contexts?.flags && normalized.contexts) {
    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);
  }
  return normalized;
}
function getFinalScope(scope, captureContext) {
  if (!captureContext) {
    return scope;
  }
  const finalScope = scope ? scope.clone() : new Scope();
  finalScope.update(captureContext);
  return finalScope;
}
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return void 0;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
var captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}

// node_modules/@sentry/core/build/esm/exports.js
function captureException(exception, hint) {
  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureEvent(event, hint) {
  return getCurrentScope().captureEvent(event, hint);
}
function setContext(name, context3) {
  getIsolationScope().setContext(name, context3);
}
function setTag(key, value) {
  getIsolationScope().setTag(key, value);
}
async function flush(timeout) {
  const client = getClient();
  if (client) {
    return client.flush(timeout);
  }
  DEBUG_BUILD && logger.warn("Cannot flush events. No client defined.");
  return Promise.resolve(false);
}
async function close(timeout) {
  const client = getClient();
  if (client) {
    return client.close(timeout);
  }
  DEBUG_BUILD && logger.warn("Cannot flush events and disable SDK. No client defined.");
  return Promise.resolve(false);
}
function isEnabled() {
  const client = getClient();
  return client?.getOptions().enabled !== false && !!client?.getTransport();
}
function startSession(context3) {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const { userAgent } = GLOBAL_OBJ.navigator || {};
  const session = makeSession({
    user: currentScope.getUser() || isolationScope.getUser(),
    ...userAgent && { userAgent },
    ...context3
  });
  const currentSession = isolationScope.getSession();
  if (currentSession?.status === "ok") {
    updateSession(currentSession, { status: "exited" });
  }
  endSession();
  isolationScope.setSession(session);
  return session;
}
function endSession() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session) {
    closeSession(session);
  }
  _sendSessionUpdate();
  isolationScope.setSession();
}
function _sendSessionUpdate() {
  const isolationScope = getIsolationScope();
  const client = getClient();
  const session = isolationScope.getSession();
  if (session && client) {
    client.captureSession(session);
  }
}

// node_modules/@sentry/core/build/esm/api.js
var SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
  const port = dsn.port ? `:${dsn.port}` : "";
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
}
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}
function _encodedAuth(dsn, sdkInfo) {
  const params = {
    sentry_version: SENTRY_API_VERSION
  };
  if (dsn.publicKey) {
    params.sentry_key = dsn.publicKey;
  }
  if (sdkInfo) {
    params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;
  }
  return new URLSearchParams(params).toString();
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}

// node_modules/@sentry/core/build/esm/integration.js
var installedIntegrations = [];
function filterDuplicates(integrations) {
  const integrationsByName = {};
  integrations.forEach((currentInstance) => {
    const { name } = currentInstance;
    const existingInstance = integrationsByName[name];
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }
    integrationsByName[name] = currentInstance;
  });
  return Object.values(integrationsByName);
}
function getIntegrationsToSetup(options) {
  const defaultIntegrations = options.defaultIntegrations || [];
  const userIntegrations = options.integrations;
  defaultIntegrations.forEach((integration) => {
    integration.isDefaultInstance = true;
  });
  let integrations;
  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations, ...userIntegrations];
  } else if (typeof userIntegrations === "function") {
    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);
    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];
  } else {
    integrations = defaultIntegrations;
  }
  return filterDuplicates(integrations);
}
function setupIntegrations(client, integrations) {
  const integrationIndex = {};
  integrations.forEach((integration) => {
    if (integration) {
      setupIntegration(client, integration, integrationIndex);
    }
  });
  return integrationIndex;
}
function afterSetupIntegrations(client, integrations) {
  for (const integration of integrations) {
    if (integration?.afterAllSetup) {
      integration.afterAllSetup(client);
    }
  }
}
function setupIntegration(client, integration, integrationIndex) {
  if (integrationIndex[integration.name]) {
    DEBUG_BUILD && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
    return;
  }
  integrationIndex[integration.name] = integration;
  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === "function") {
    integration.setupOnce();
    installedIntegrations.push(integration.name);
  }
  if (integration.setup && typeof integration.setup === "function") {
    integration.setup(client);
  }
  if (typeof integration.preprocessEvent === "function") {
    const callback = integration.preprocessEvent.bind(integration);
    client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
  }
  if (typeof integration.processEvent === "function") {
    const callback = integration.processEvent.bind(integration);
    const processor = Object.assign((event, hint) => callback(event, hint, client), {
      id: integration.name
    });
    client.addEventProcessor(processor);
  }
  DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);
}
function defineIntegration(fn) {
  return fn;
}

// node_modules/@sentry/core/build/esm/utils-hoist/clientreport.js
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  const clientReportItem = [
    { type: "client_report" },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}

// node_modules/@sentry/core/build/esm/utils/eventUtils.js
function getPossibleEventMessages(event) {
  const possibleMessages = [];
  if (event.message) {
    possibleMessages.push(event.message);
  }
  try {
    const lastException = event.exception.values[event.exception.values.length - 1];
    if (lastException?.value) {
      possibleMessages.push(lastException.value);
      if (lastException.type) {
        possibleMessages.push(`${lastException.type}: ${lastException.value}`);
      }
    }
  } catch (e) {
  }
  return possibleMessages;
}

// node_modules/@sentry/core/build/esm/utils/transactionEvent.js
function convertTransactionEventToSpanJson(event) {
  const { trace_id, parent_span_id, span_id, status, origin, data, op } = event.contexts?.trace ?? {};
  return {
    data: data ?? {},
    description: event.transaction,
    op,
    parent_span_id,
    span_id: span_id ?? "",
    start_timestamp: event.start_timestamp ?? 0,
    status,
    timestamp: event.timestamp,
    trace_id: trace_id ?? "",
    origin,
    profile_id: data?.[SEMANTIC_ATTRIBUTE_PROFILE_ID],
    exclusive_time: data?.[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
    measurements: event.measurements,
    is_segment: true
  };
}
function convertSpanJsonToTransactionEvent(span) {
  return {
    type: "transaction",
    timestamp: span.timestamp,
    start_timestamp: span.start_timestamp,
    transaction: span.description,
    contexts: {
      trace: {
        trace_id: span.trace_id,
        span_id: span.span_id,
        parent_span_id: span.parent_span_id,
        op: span.op,
        status: span.status,
        origin: span.origin,
        data: {
          ...span.data,
          ...span.profile_id && { [SEMANTIC_ATTRIBUTE_PROFILE_ID]: span.profile_id },
          ...span.exclusive_time && { [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: span.exclusive_time }
        }
      }
    },
    measurements: span.measurements
  };
}

// node_modules/@sentry/core/build/esm/client.js
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
var MISSING_RELEASE_FOR_SESSION_ERROR = "Discarded session because of missing or non-string release";
var INTERNAL_ERROR_SYMBOL = Symbol.for("SentryInternalError");
var DO_NOT_SEND_EVENT_SYMBOL = Symbol.for("SentryDoNotSendEventError");
function _makeInternalError(message) {
  return {
    message,
    [INTERNAL_ERROR_SYMBOL]: true
  };
}
function _makeDoNotSendEventError(message) {
  return {
    message,
    [DO_NOT_SEND_EVENT_SYMBOL]: true
  };
}
function _isInternalError(error) {
  return !!error && typeof error === "object" && INTERNAL_ERROR_SYMBOL in error;
}
function _isDoNotSendEventError(error) {
  return !!error && typeof error === "object" && DO_NOT_SEND_EVENT_SYMBOL in error;
}
var Client = class {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(options) {
    this._options = options;
    this._integrations = {};
    this._numProcessing = 0;
    this._outcomes = {};
    this._hooks = {};
    this._eventProcessors = [];
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
    } else {
      DEBUG_BUILD && logger.warn("No DSN provided, client will not send events.");
    }
    if (this._dsn) {
      const url2 = getEnvelopeEndpointWithUrlEncodedAuth(
        this._dsn,
        options.tunnel,
        options._metadata ? options._metadata.sdk : void 0
      );
      this._transport = options.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url: url2
      });
    }
  }
  /**
   * Captures an exception event and sends it to Sentry.
   *
   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureException(exception, hint, scope) {
    const eventId = uuid4();
    if (checkOrSetAlreadyCaught(exception)) {
      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    this._process(
      this.eventFromException(exception, hintWithEventId).then(
        (event) => this._captureEvent(event, hintWithEventId, scope)
      )
    );
    return hintWithEventId.event_id;
  }
  /**
   * Captures a message event and sends it to Sentry.
   *
   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureMessage(message, level, hint, currentScope) {
    const hintWithEventId = {
      event_id: uuid4(),
      ...hint
    };
    const eventMessage = isParameterizedString(message) ? message : String(message);
    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);
    this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope)));
    return hintWithEventId.event_id;
  }
  /**
   * Captures a manually created event and sends it to Sentry.
   *
   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureEvent(event, hint, currentScope) {
    const eventId = uuid4();
    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
    this._process(
      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope)
    );
    return hintWithEventId.event_id;
  }
  /**
   * Captures a session.
   */
  captureSession(session) {
    this.sendSession(session);
    updateSession(session, { init: false });
  }
  /**
   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.
   *
   * @param checkIn An object that describes a check in.
   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
   * to create a monitor automatically when sending a check in.
   * @param scope An optional scope containing event metadata.
   * @returns A string representing the id of the check in.
   */
  /**
   * Get the current Dsn.
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * Get the current options.
   */
  getOptions() {
    return this._options;
  }
  /**
   * Get the SDK metadata.
   * @see SdkMetadata
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * Returns the transport that is used by the client.
   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
   */
  getTransport() {
    return this._transport;
  }
  /**
   * Wait for all events to be sent or the timeout to expire, whichever comes first.
   *
   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
   *   cause the client to wait until all events are sent before resolving the promise.
   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
   * still events in the queue when the timeout is reached.
   */
  flush(timeout) {
    const transport = this._transport;
    if (transport) {
      this.emit("flush");
      return this._isClientDoneProcessing(timeout).then((clientFinished) => {
        return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }
  /**
   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
   *
   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
   *   the client to wait until all events are sent before disabling itself.
   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
   * it doesn't.
   */
  close(timeout) {
    return this.flush(timeout).then((result) => {
      this.getOptions().enabled = false;
      this.emit("close");
      return result;
    });
  }
  /**
   * Get all installed event processors.
   */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /**
   * Adds an event processor that applies to any event processed by this client.
   */
  addEventProcessor(eventProcessor) {
    this._eventProcessors.push(eventProcessor);
  }
  /**
   * Initialize this client.
   * Call this after the client was set on a scope.
   */
  init() {
    if (this._isEnabled() || // Force integrations to be setup even if no DSN was set when we have
    // Spotlight enabled. This is particularly important for browser as we
    // don't support the `spotlight` option there and rely on the users
    // adding the `spotlightBrowserIntegration()` to their integrations which
    // wouldn't get initialized with the check below when there's no DSN set.
    this._options.integrations.some(({ name }) => name.startsWith("Spotlight"))) {
      this._setupIntegrations();
    }
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(integrationName) {
    return this._integrations[integrationName];
  }
  /**
   * Add an integration to the client.
   * This can be used to e.g. lazy load integrations.
   * In most cases, this should not be necessary,
   * and you're better off just passing the integrations via `integrations: []` at initialization time.
   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.
   */
  addIntegration(integration) {
    const isAlreadyInstalled = this._integrations[integration.name];
    setupIntegration(this, integration, this._integrations);
    if (!isAlreadyInstalled) {
      afterSetupIntegrations(this, [integration]);
    }
  }
  /**
   * Send a fully prepared event to Sentry.
   */
  sendEvent(event, hint = {}) {
    this.emit("beforeSendEvent", event, hint);
    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
    for (const attachment of hint.attachments || []) {
      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));
    }
    const promise = this.sendEnvelope(env);
    if (promise) {
      promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
    }
  }
  /**
   * Send a session or session aggregrates to Sentry.
   */
  sendSession(session) {
    const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;
    if ("aggregates" in session) {
      const sessionAttrs = session.attrs || {};
      if (!sessionAttrs.release && !clientReleaseOption) {
        DEBUG_BUILD && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
        return;
      }
      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;
      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;
      session.attrs = sessionAttrs;
    } else {
      if (!session.release && !clientReleaseOption) {
        DEBUG_BUILD && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
        return;
      }
      session.release = session.release || clientReleaseOption;
      session.environment = session.environment || clientEnvironmentOption;
    }
    this.emit("beforeSendSession", session);
    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(env);
  }
  /**
   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).
   */
  recordDroppedEvent(reason, category, count = 1) {
    if (this._options.sendClientReports) {
      const key = `${reason}:${category}`;
      DEBUG_BUILD && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
      this._outcomes[key] = (this._outcomes[key] || 0) + count;
    }
  }
  /* eslint-disable @typescript-eslint/unified-signatures */
  /**
   * Register a callback for whenever a span is started.
   * Receives the span as argument.
   * @returns {() => void} A function that, when executed, removes the registered callback.
   */
  /**
   * Register a hook on this client.
   */
  on(hook, callback) {
    const hooks = this._hooks[hook] = this._hooks[hook] || [];
    hooks.push(callback);
    return () => {
      const cbIndex = hooks.indexOf(callback);
      if (cbIndex > -1) {
        hooks.splice(cbIndex, 1);
      }
    };
  }
  /** Fire a hook whenever a span starts. */
  /**
   * Emit a hook that was previously registered via `on()`.
   */
  emit(hook, ...rest) {
    const callbacks = this._hooks[hook];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...rest));
    }
  }
  /**
   * Send an envelope to Sentry.
   */
  sendEnvelope(envelope) {
    this.emit("beforeEnvelope", envelope);
    if (this._isEnabled() && this._transport) {
      return this._transport.send(envelope).then(null, (reason) => {
        DEBUG_BUILD && logger.error("Error while sending envelope:", reason);
        return reason;
      });
    }
    DEBUG_BUILD && logger.error("Transport disabled");
    return resolvedSyncPromise({});
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations } = this._options;
    this._integrations = setupIntegrations(this, integrations);
    afterSetupIntegrations(this, integrations);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(session, event) {
    let crashed = event.level === "fatal";
    let errored = false;
    const exceptions = event.exception?.values;
    if (exceptions) {
      errored = true;
      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism?.handled === false) {
          crashed = true;
          break;
        }
      }
    }
    const sessionNonTerminal = session.status === "ok";
    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...crashed && { status: "crashed" },
        errors: session.errors || Number(errored || crashed)
      });
      this.captureSession(session);
    }
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(timeout) {
    return new SyncPromise((resolve2) => {
      let ticked = 0;
      const tick = 1;
      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve2(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve2(false);
          }
        }
      }, tick);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== false && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(event, hint, currentScope, isolationScope) {
    const options = this.getOptions();
    const integrations = Object.keys(this._integrations);
    if (!hint.integrations && integrations?.length) {
      hint.integrations = integrations;
    }
    this.emit("preprocessEvent", event, hint);
    if (!event.type) {
      isolationScope.setLastEventId(event.event_id || hint.event_id);
    }
    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then((evt) => {
      if (evt === null) {
        return evt;
      }
      this.emit("postprocessEvent", evt, hint);
      evt.contexts = {
        trace: getTraceContextFromScope(currentScope),
        ...evt.contexts
      };
      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);
      evt.sdkProcessingMetadata = {
        dynamicSamplingContext,
        ...evt.sdkProcessingMetadata
      };
      return evt;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(event, hint = {}, currentScope = getCurrentScope(), isolationScope = getIsolationScope()) {
    if (DEBUG_BUILD && isErrorEvent2(event)) {
      logger.log(`Captured error event \`${getPossibleEventMessages(event)[0] || "<unknown>"}\``);
    }
    return this._processEvent(event, hint, currentScope, isolationScope).then(
      (finalEvent) => {
        return finalEvent.event_id;
      },
      (reason) => {
        if (DEBUG_BUILD) {
          if (_isDoNotSendEventError(reason)) {
            logger.log(reason.message);
          } else if (_isInternalError(reason)) {
            logger.warn(reason.message);
          } else {
            logger.warn(reason);
          }
        }
        return void 0;
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(event, hint, currentScope, isolationScope) {
    const options = this.getOptions();
    const { sampleRate } = options;
    const isTransaction = isTransactionEvent(event);
    const isError2 = isErrorEvent2(event);
    const eventType = event.type || "error";
    const beforeSendLabel = `before send for type \`${eventType}\``;
    const parsedSampleRate = typeof sampleRate === "undefined" ? void 0 : parseSampleRate(sampleRate);
    if (isError2 && typeof parsedSampleRate === "number" && Math.random() > parsedSampleRate) {
      this.recordDroppedEvent("sample_rate", "error");
      return rejectedSyncPromise(
        _makeDoNotSendEventError(
          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`
        )
      );
    }
    const dataCategory = eventType === "replay_event" ? "replay" : eventType;
    return this._prepareEvent(event, hint, currentScope, isolationScope).then((prepared) => {
      if (prepared === null) {
        this.recordDroppedEvent("event_processor", dataCategory);
        throw _makeDoNotSendEventError("An event processor returned `null`, will not send event.");
      }
      const isInternalException = hint.data && hint.data.__sentry__ === true;
      if (isInternalException) {
        return prepared;
      }
      const result = processBeforeSend(this, options, prepared, hint);
      return _validateBeforeSendResult(result, beforeSendLabel);
    }).then((processedEvent) => {
      if (processedEvent === null) {
        this.recordDroppedEvent("before_send", dataCategory);
        if (isTransaction) {
          const spans = event.spans || [];
          const spanCount = 1 + spans.length;
          this.recordDroppedEvent("before_send", "span", spanCount);
        }
        throw _makeDoNotSendEventError(`${beforeSendLabel} returned \`null\`, will not send event.`);
      }
      const session = currentScope.getSession() || isolationScope.getSession();
      if (isError2 && session) {
        this._updateSessionFromEvent(session, processedEvent);
      }
      if (isTransaction) {
        const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;
        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
        const droppedSpanCount = spanCountBefore - spanCountAfter;
        if (droppedSpanCount > 0) {
          this.recordDroppedEvent("before_send", "span", droppedSpanCount);
        }
      }
      const transactionInfo = processedEvent.transaction_info;
      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
        const source = "custom";
        processedEvent.transaction_info = {
          ...transactionInfo,
          source
        };
      }
      this.sendEvent(processedEvent, hint);
      return processedEvent;
    }).then(null, (reason) => {
      if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {
        throw reason;
      }
      this.captureException(reason, {
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw _makeInternalError(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
      );
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(promise) {
    this._numProcessing++;
    void promise.then(
      (value) => {
        this._numProcessing--;
        return value;
      },
      (reason) => {
        this._numProcessing--;
        return reason;
      }
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.entries(outcomes).map(([key, quantity]) => {
      const [reason, category] = key.split(":");
      return {
        reason,
        category,
        quantity
      };
    });
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    DEBUG_BUILD && logger.log("Flushing outcomes...");
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      DEBUG_BUILD && logger.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      DEBUG_BUILD && logger.log("No dsn provided, will not send outcomes");
      return;
    }
    DEBUG_BUILD && logger.log("Sending outcomes:", outcomes);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    this.sendEnvelope(envelope);
  }
  /**
   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
   */
};
function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
  const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then(
      (event) => {
        if (!isPlainObject(event) && event !== null) {
          throw _makeInternalError(invalidValueError);
        }
        return event;
      },
      (e) => {
        throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);
      }
    );
  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
    throw _makeInternalError(invalidValueError);
  }
  return beforeSendResult;
}
function processBeforeSend(client, options, event, hint) {
  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;
  let processedEvent = event;
  if (isErrorEvent2(processedEvent) && beforeSend) {
    return beforeSend(processedEvent, hint);
  }
  if (isTransactionEvent(processedEvent)) {
    if (beforeSendSpan) {
      const processedRootSpanJson = beforeSendSpan(convertTransactionEventToSpanJson(processedEvent));
      if (!processedRootSpanJson) {
        showSpanDropWarning();
      } else {
        processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));
      }
      if (processedEvent.spans) {
        const processedSpans = [];
        for (const span of processedEvent.spans) {
          const processedSpan = beforeSendSpan(span);
          if (!processedSpan) {
            showSpanDropWarning();
            processedSpans.push(span);
          } else {
            processedSpans.push(processedSpan);
          }
        }
        processedEvent.spans = processedSpans;
      }
    }
    if (beforeSendTransaction) {
      if (processedEvent.spans) {
        const spanCountBefore = processedEvent.spans.length;
        processedEvent.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(processedEvent, hint);
    }
  }
  return processedEvent;
}
function isErrorEvent2(event) {
  return event.type === void 0;
}
function isTransactionEvent(event) {
  return event.type === "transaction";
}
function _getTraceInfoFromScope(client, scope) {
  if (!scope) {
    return [void 0, void 0];
  }
  const span = _getSpanForScope(scope);
  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);
  const dynamicSamplingContext = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);
  return [dynamicSamplingContext, traceContext];
}

// node_modules/@sentry/core/build/esm/checkin.js
function createCheckInEnvelope(checkIn, dynamicSamplingContext, metadata, tunnel, dsn) {
  const headers = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (metadata?.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && !!dsn) {
    headers.dsn = dsnToString(dsn);
  }
  if (dynamicSamplingContext) {
    headers.trace = dynamicSamplingContext;
  }
  const item = createCheckInEnvelopeItem(checkIn);
  return createEnvelope(headers, [item]);
}
function createCheckInEnvelopeItem(checkIn) {
  const checkInHeaders = {
    type: "check_in"
  };
  return [checkInHeaders, checkIn];
}

// node_modules/@sentry/core/build/esm/utils-hoist/eventbuilder.js
function parseStackFrames(stackParser, error) {
  return stackParser(error.stack || "", 1);
}
function exceptionFromError(stackParser, error) {
  const exception = {
    type: error.name || error.constructor.name,
    value: error.message
  };
  const frames = parseStackFrames(stackParser, error);
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  return exception;
}
function getErrorPropertyFromObject(obj) {
  for (const prop in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
      const value = obj[prop];
      if (value instanceof Error) {
        return value;
      }
    }
  }
  return void 0;
}
function getMessageForObject(exception) {
  if ("name" in exception && typeof exception.name === "string") {
    let message = `'${exception.name}' captured as exception`;
    if ("message" in exception && typeof exception.message === "string") {
      message += ` with message '${exception.message}'`;
    }
    return message;
  } else if ("message" in exception && typeof exception.message === "string") {
    return exception.message;
  }
  const keys = extractExceptionKeysForMessage(exception);
  if (isErrorEvent(exception)) {
    return `Event \`ErrorEvent\` captured as exception with message \`${exception.message}\``;
  }
  const className = getObjectClassName(exception);
  return `${className && className !== "Object" ? `'${className}'` : "Object"} captured as exception with keys: ${keys}`;
}
function getObjectClassName(obj) {
  try {
    const prototype = Object.getPrototypeOf(obj);
    return prototype ? prototype.constructor.name : void 0;
  } catch (e) {
  }
}
function getException(client, mechanism, exception, hint) {
  if (isError(exception)) {
    return [exception, void 0];
  }
  mechanism.synthetic = true;
  if (isPlainObject(exception)) {
    const normalizeDepth = client?.getOptions().normalizeDepth;
    const extras = { ["__serialized__"]: normalizeToSize(exception, normalizeDepth) };
    const errorFromProp = getErrorPropertyFromObject(exception);
    if (errorFromProp) {
      return [errorFromProp, extras];
    }
    const message = getMessageForObject(exception);
    const ex2 = hint?.syntheticException || new Error(message);
    ex2.message = message;
    return [ex2, extras];
  }
  const ex = hint?.syntheticException || new Error(exception);
  ex.message = `${exception}`;
  return [ex, void 0];
}
function eventFromUnknownInput(client, stackParser, exception, hint) {
  const providedMechanism = hint?.data && hint.data.mechanism;
  const mechanism = providedMechanism || {
    handled: true,
    type: "generic"
  };
  const [ex, extras] = getException(client, mechanism, exception, hint);
  const event = {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
  if (extras) {
    event.extra = extras;
  }
  addExceptionTypeValue(event, void 0, void 0);
  addExceptionMechanism(event, mechanism);
  return {
    ...event,
    event_id: hint?.event_id
  };
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const event = {
    event_id: hint?.event_id,
    level
  };
  if (attachStacktrace && hint?.syntheticException) {
    const frames = parseStackFrames(stackParser, hint.syntheticException);
    if (frames.length) {
      event.exception = {
        values: [
          {
            value: message,
            stacktrace: { frames }
          }
        ]
      };
      addExceptionMechanism(event, { synthetic: true });
    }
  }
  if (isParameterizedString(message)) {
    const { __sentry_template_string__, __sentry_template_values__ } = message;
    event.logentry = {
      message: __sentry_template_string__,
      params: __sentry_template_values__
    };
    return event;
  }
  event.message = message;
  return event;
}

// node_modules/@sentry/core/build/esm/logs/envelope.js
function createOtelLogEnvelopeItem(log2) {
  return [
    {
      type: "otel_log"
    },
    log2
  ];
}
function createOtelLogEnvelope(logs, metadata, tunnel, dsn) {
  const headers = {};
  if (metadata?.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && !!dsn) {
    headers.dsn = dsnToString(dsn);
  }
  return createEnvelope(headers, logs.map(createOtelLogEnvelopeItem));
}

// node_modules/@sentry/core/build/esm/logs/exports.js
var CLIENT_TO_LOG_BUFFER_MAP = /* @__PURE__ */ new WeakMap();
function _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {
  const logBuffer = maybeLogBuffer ?? CLIENT_TO_LOG_BUFFER_MAP.get(client) ?? [];
  if (logBuffer.length === 0) {
    return;
  }
  const clientOptions = client.getOptions();
  const envelope = createOtelLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());
  logBuffer.length = 0;
  client.emit("flushLogs");
  client.sendEnvelope(envelope);
}

// node_modules/@sentry/core/build/esm/server-runtime-client.js
var DEFAULT_LOG_FLUSH_INTERVAL = 5e3;
var ServerRuntimeClient = class extends Client {
  /**
   * Creates a new Edge SDK instance.
   * @param options Configuration options for this SDK.
   */
  constructor(options) {
    registerSpanErrorInstrumentation();
    super(options);
    this._logWeight = 0;
    if (this._options._experiments?.enableLogs) {
      const client = this;
      client.on("flushLogs", () => {
        client._logWeight = 0;
        clearTimeout(client._logFlushIdleTimeout);
      });
      client.on("afterCaptureLog", (log2) => {
        client._logWeight += estimateLogSizeInBytes(log2);
        if (client._logWeight >= 8e5) {
          _INTERNAL_flushLogsBuffer(client);
        } else {
          client._logFlushIdleTimeout = setTimeout(() => {
            _INTERNAL_flushLogsBuffer(client);
          }, DEFAULT_LOG_FLUSH_INTERVAL);
        }
      });
    }
  }
  /**
   * @inheritDoc
   */
  eventFromException(exception, hint) {
    const event = eventFromUnknownInput(this, this._options.stackParser, exception, hint);
    event.level = "error";
    return resolvedSyncPromise(event);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(message, level = "info", hint) {
    return resolvedSyncPromise(
      eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace)
    );
  }
  /**
   * @inheritDoc
   */
  captureException(exception, hint, scope) {
    setCurrentRequestSessionErroredOrCrashed(hint);
    return super.captureException(exception, hint, scope);
  }
  /**
   * @inheritDoc
   */
  captureEvent(event, hint, scope) {
    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;
    if (isException) {
      setCurrentRequestSessionErroredOrCrashed(hint);
    }
    return super.captureEvent(event, hint, scope);
  }
  /**
   * Create a cron monitor check in and send it to Sentry.
   *
   * @param checkIn An object that describes a check in.
   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
   * to create a monitor automatically when sending a check in.
   */
  captureCheckIn(checkIn, monitorConfig, scope) {
    const id = "checkInId" in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();
    if (!this._isEnabled()) {
      DEBUG_BUILD && logger.warn("SDK not enabled, will not capture check-in.");
      return id;
    }
    const options = this.getOptions();
    const { release: release2, environment, tunnel } = options;
    const serializedCheckIn = {
      check_in_id: id,
      monitor_slug: checkIn.monitorSlug,
      status: checkIn.status,
      release: release2,
      environment
    };
    if ("duration" in checkIn) {
      serializedCheckIn.duration = checkIn.duration;
    }
    if (monitorConfig) {
      serializedCheckIn.monitor_config = {
        schedule: monitorConfig.schedule,
        checkin_margin: monitorConfig.checkinMargin,
        max_runtime: monitorConfig.maxRuntime,
        timezone: monitorConfig.timezone,
        failure_issue_threshold: monitorConfig.failureIssueThreshold,
        recovery_threshold: monitorConfig.recoveryThreshold
      };
    }
    const [dynamicSamplingContext, traceContext] = _getTraceInfoFromScope(this, scope);
    if (traceContext) {
      serializedCheckIn.contexts = {
        trace: traceContext
      };
    }
    const envelope = createCheckInEnvelope(
      serializedCheckIn,
      dynamicSamplingContext,
      this.getSdkMetadata(),
      tunnel,
      this.getDsn()
    );
    DEBUG_BUILD && logger.info("Sending checkin:", checkIn.monitorSlug, checkIn.status);
    this.sendEnvelope(envelope);
    return id;
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(event, hint, currentScope, isolationScope) {
    if (this._options.platform) {
      event.platform = event.platform || this._options.platform;
    }
    if (this._options.runtime) {
      event.contexts = {
        ...event.contexts,
        runtime: event.contexts?.runtime || this._options.runtime
      };
    }
    if (this._options.serverName) {
      event.server_name = event.server_name || this._options.serverName;
    }
    return super._prepareEvent(event, hint, currentScope, isolationScope);
  }
};
function setCurrentRequestSessionErroredOrCrashed(eventHint) {
  const requestSession = getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;
  if (requestSession) {
    const isHandledException = eventHint?.mechanism?.handled ?? true;
    if (isHandledException && requestSession.status !== "crashed") {
      requestSession.status = "errored";
    } else if (!isHandledException) {
      requestSession.status = "crashed";
    }
  }
}
function estimateLogSizeInBytes(log2) {
  let weight = 0;
  if (log2.message) {
    weight += log2.message.length * 2;
  }
  if (log2.attributes) {
    Object.values(log2.attributes).forEach((value) => {
      if (Array.isArray(value)) {
        weight += value.length * estimatePrimitiveSizeInBytes(value[0]);
      } else if (isPrimitive(value)) {
        weight += estimatePrimitiveSizeInBytes(value);
      } else {
        weight += 100;
      }
    });
  }
  return weight;
}
function estimatePrimitiveSizeInBytes(value) {
  if (typeof value === "string") {
    return value.length * 2;
  } else if (typeof value === "number") {
    return 8;
  } else if (typeof value === "boolean") {
    return 4;
  }
  return 0;
}

// node_modules/@sentry/core/build/esm/utils-hoist/promisebuffer.js
var SENTRY_BUFFER_FULL_ERROR = Symbol.for("SentryBufferFullError");
function makePromiseBuffer(limit) {
  const buffer = [];
  function isReady() {
    return limit === void 0 || buffer.length < limit;
  }
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(void 0);
  }
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(SENTRY_BUFFER_FULL_ERROR);
    }
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task.then(() => remove(task)).then(
      null,
      () => remove(task).then(null, () => {
      })
    );
    return task;
  }
  function drain(timeout) {
    return new SyncPromise((resolve2, reject) => {
      let counter = buffer.length;
      if (!counter) {
        return resolve2(true);
      }
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve2(false);
        }
      }, timeout);
      buffer.forEach((item) => {
        void resolvedSyncPromise(item).then(() => {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve2(true);
          }
        }, reject);
      });
    });
  }
  return {
    $: buffer,
    add,
    drain
  };
}

// node_modules/@sentry/core/build/esm/utils-hoist/ratelimit.js
var DEFAULT_RETRY_AFTER = 60 * 1e3;
function parseRetryAfterHeader(header, now = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1e3;
  }
  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, dataCategory) {
  return limits[dataCategory] || limits.all || 0;
}
function isRateLimited(limits, dataCategory, now = Date.now()) {
  return disabledUntil(limits, dataCategory) > now;
}
function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
  const updatedRateLimits = {
    ...limits
  };
  const rateLimitHeader = headers?.["x-sentry-rate-limits"];
  const retryAfterHeader = headers?.["retry-after"];
  if (rateLimitHeader) {
    for (const limit of rateLimitHeader.trim().split(",")) {
      const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
      const headerDelay = parseInt(retryAfter, 10);
      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (const category of categories.split(";")) {
          if (category === "metric_bucket") {
            if (!namespaces || namespaces.split(";").includes("custom")) {
              updatedRateLimits[category] = now + delay;
            }
          } else {
            updatedRateLimits[category] = now + delay;
          }
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1e3;
  }
  return updatedRateLimits;
}

// node_modules/@sentry/core/build/esm/transports/base.js
var DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
function createTransport(options, makeRequest, buffer = makePromiseBuffer(
  options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
)) {
  let rateLimits = {};
  const flush2 = (timeout) => buffer.drain(timeout);
  function send(envelope) {
    const filteredEnvelopeItems = [];
    forEachEnvelopeItem(envelope, (item, type) => {
      const dataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, dataCategory)) {
        options.recordDroppedEvent("ratelimit_backoff", dataCategory);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise({});
    }
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));
      });
    };
    const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(
      (response) => {
        if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
          DEBUG_BUILD && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
        }
        rateLimits = updateRateLimits(rateLimits, response);
        return response;
      },
      (error) => {
        recordEnvelopeLoss("network_error");
        DEBUG_BUILD && logger.error("Encountered error running transport request:", error);
        throw error;
      }
    );
    return buffer.add(requestTask).then(
      (result) => result,
      (error) => {
        if (error === SENTRY_BUFFER_FULL_ERROR) {
          DEBUG_BUILD && logger.error("Skipped sending event because buffer is full.");
          recordEnvelopeLoss("queue_overflow");
          return resolvedSyncPromise({});
        } else {
          throw error;
        }
      }
    );
  }
  return {
    send,
    flush: flush2
  };
}

// node_modules/@sentry/core/build/esm/utils/sdkMetadata.js
function applySdkMetadata(options, name, names = [name], source = "npm") {
  const metadata = options._metadata || {};
  if (!metadata.sdk) {
    metadata.sdk = {
      name: `sentry.javascript.${name}`,
      packages: names.map((name2) => ({
        name: `${source}:@sentry/${name2}`,
        version: SDK_VERSION
      })),
      version: SDK_VERSION
    };
  }
  options._metadata = metadata;
}

// node_modules/@sentry/core/build/esm/utils/traceData.js
function getTraceData(options = {}) {
  const client = getClient();
  if (!isEnabled() || !client) {
    return {};
  }
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (acs.getTraceData) {
    return acs.getTraceData(options);
  }
  const scope = getCurrentScope();
  const span = options.span || getActiveSpan2();
  const sentryTrace = span ? spanToTraceHeader(span) : scopeToTraceHeader(scope);
  const dsc = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);
  const baggage = dynamicSamplingContextToSentryBaggageHeader(dsc);
  const isValidSentryTraceHeader = TRACEPARENT_REGEXP.test(sentryTrace);
  if (!isValidSentryTraceHeader) {
    logger.warn("Invalid sentry-trace data. Cannot generate trace data");
    return {};
  }
  return {
    "sentry-trace": sentryTrace,
    baggage
  };
}
function scopeToTraceHeader(scope) {
  const { traceId, sampled, propagationSpanId } = scope.getPropagationContext();
  return generateSentryTraceHeader(traceId, propagationSpanId, sampled);
}

// node_modules/@sentry/core/build/esm/utils/request.js
function headersToDict(reqHeaders) {
  const headers = /* @__PURE__ */ Object.create(null);
  try {
    Object.entries(reqHeaders).forEach(([key, value]) => {
      if (typeof value === "string") {
        headers[key] = value;
      }
    });
  } catch {
  }
  return headers;
}
function httpRequestToRequestData(request) {
  const headers = request.headers || {};
  const host = typeof headers.host === "string" ? headers.host : void 0;
  const protocol = request.protocol || (request.socket?.encrypted ? "https" : "http");
  const url2 = request.url || "";
  const absoluteUrl = getAbsoluteUrl({
    url: url2,
    host,
    protocol
  });
  const data = request.body || void 0;
  const cookies = request.cookies;
  return {
    url: absoluteUrl,
    method: request.method,
    query_string: extractQueryParamsFromUrl(url2),
    headers: headersToDict(headers),
    cookies,
    data
  };
}
function getAbsoluteUrl({
  url: url2,
  protocol,
  host
}) {
  if (url2?.startsWith("http")) {
    return url2;
  }
  if (url2 && host) {
    return `${protocol}://${host}${url2}`;
  }
  return void 0;
}
function extractQueryParamsFromUrl(url2) {
  if (!url2) {
    return;
  }
  try {
    const queryParams = new URL(url2, "http://s.io").search.slice(1);
    return queryParams.length ? queryParams : void 0;
  } catch {
    return void 0;
  }
}

// node_modules/@sentry/core/build/esm/breadcrumbs.js
var DEFAULT_BREADCRUMBS = 100;
function addBreadcrumb(breadcrumb, hint) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  if (!client) return;
  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();
  if (maxBreadcrumbs <= 0) return;
  const timestamp = dateTimestampInSeconds();
  const mergedBreadcrumb = { timestamp, ...breadcrumb };
  const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
  if (finalBreadcrumb === null) return;
  if (client.emit) {
    client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
  }
  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
}

// node_modules/@sentry/core/build/esm/integrations/functiontostring.js
var originalFunctionToString;
var INTEGRATION_NAME = "FunctionToString";
var SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
var _functionToStringIntegration = () => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      originalFunctionToString = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...args) {
          const originalFunction = getOriginalFunction(this);
          const context3 = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
          return originalFunctionToString.apply(context3, args);
        };
      } catch {
      }
    },
    setup(client) {
      SETUP_CLIENTS.set(client, true);
    }
  };
};
var functionToStringIntegration = defineIntegration(_functionToStringIntegration);

// node_modules/@sentry/core/build/esm/integrations/eventFilters.js
var DEFAULT_IGNORE_ERRORS = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
  /^Cannot redefine property: googletag$/,
  // This is thrown when google tag manager is used in combination with an ad blocker
  /^Can't find variable: gmo$/,
  // Error from Google Search App https://issuetracker.google.com/issues/396043331
  /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
  // Random error that happens but not actionable or noticeable to end-users.
  `can't redefine non-configurable property "solana"`,
  // Probably a browser extension or custom browser (Brave) throwing this error
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  // Error thrown by GTM, seemingly not affecting end-users
  "Can't find variable: _AutofillCallbackHandler",
  // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
  /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
  // unactionable error from CEFSharp, a .NET library that embeds chromium in .NET apps
  /^Java exception was raised during method invocation$/
  // error from Facebook Mobile browser (https://github.com/getsentry/sentry-javascript/issues/15065)
];
var INTEGRATION_NAME2 = "EventFilters";
var eventFiltersIntegration = defineIntegration((options = {}) => {
  let mergedOptions;
  return {
    name: INTEGRATION_NAME2,
    setup(client) {
      const clientOptions = client.getOptions();
      mergedOptions = _mergeOptions(options, clientOptions);
    },
    processEvent(event, _hint, client) {
      if (!mergedOptions) {
        const clientOptions = client.getOptions();
        mergedOptions = _mergeOptions(options, clientOptions);
      }
      return _shouldDropEvent(event, mergedOptions) ? null : event;
    }
  };
});
var inboundFiltersIntegration = defineIntegration((options = {}) => {
  return {
    ...eventFiltersIntegration(options),
    name: "InboundFilters"
  };
});
function _mergeOptions(internalOptions = {}, clientOptions = {}) {
  return {
    allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
    denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
    ignoreErrors: [
      ...internalOptions.ignoreErrors || [],
      ...clientOptions.ignoreErrors || [],
      ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
    ],
    ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []]
  };
}
function _shouldDropEvent(event, options) {
  if (!event.type) {
    if (_isIgnoredError(event, options.ignoreErrors)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isUselessError(event)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(
          event
        )}`
      );
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
  } else if (event.type === "transaction") {
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      DEBUG_BUILD && logger.warn(
        `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (!ignoreErrors?.length) {
    return false;
  }
  return getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
}
function _isIgnoredTransaction(event, ignoreTransactions) {
  if (!ignoreTransactions?.length) {
    return false;
  }
  const name = event.transaction;
  return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls?.length) {
    return false;
  }
  const url2 = _getEventFilterUrl(event);
  return !url2 ? false : stringMatchesSomePattern(url2, denyUrls);
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls?.length) {
    return true;
  }
  const url2 = _getEventFilterUrl(event);
  return !url2 ? true : stringMatchesSomePattern(url2, allowUrls);
}
function _getLastValidUrl(frames = []) {
  for (let i = frames.length - 1; i >= 0; i--) {
    const frame = frames[i];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    const rootException = [...event.exception?.values ?? []].reverse().find((value) => value.mechanism?.parent_id === void 0 && value.stacktrace?.frames?.length);
    const frames = rootException?.stacktrace?.frames;
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    DEBUG_BUILD && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}
function _isUselessError(event) {
  if (!event.exception?.values?.length) {
    return false;
  }
  return (
    // No top-level message
    !event.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value
    !event.exception.values.some((value) => value.stacktrace || value.type && value.type !== "Error" || value.value)
  );
}

// node_modules/@sentry/core/build/esm/utils-hoist/aggregate-errors.js
function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, key, limit, event, hint) {
  if (!event.exception?.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return;
  }
  const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
  if (originalException) {
    event.exception.values = aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser,
      limit,
      hint.originalException,
      key,
      event.exception.values,
      originalException,
      0
    );
  }
}
function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {
  if (prevExceptions.length >= limit + 1) {
    return prevExceptions;
  }
  let newExceptions = [...prevExceptions];
  if (isInstanceOf(error[key], Error)) {
    applyExceptionGroupFieldsForParentException(exception, exceptionId);
    const newException = exceptionFromErrorImplementation(parser, error[key]);
    const newExceptionId = newExceptions.length;
    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
    newExceptions = aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser,
      limit,
      error[key],
      key,
      [newException, ...newExceptions],
      newException,
      newExceptionId
    );
  }
  if (Array.isArray(error.errors)) {
    error.errors.forEach((childError, i) => {
      if (isInstanceOf(childError, Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, childError);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          childError,
          key,
          [newException, ...newExceptions],
          newException,
          newExceptionId
        );
      }
    });
  }
  return newExceptions;
}
function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    ...exception.type === "AggregateError" && { is_exception_group: true },
    exception_id: exceptionId
  };
}
function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    type: "chained",
    source,
    exception_id: exceptionId,
    parent_id: parentId
  };
}

// node_modules/@sentry/core/build/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT = 5;
var INTEGRATION_NAME3 = "LinkedErrors";
var _linkedErrorsIntegration = (options = {}) => {
  const limit = options.limit || DEFAULT_LIMIT;
  const key = options.key || DEFAULT_KEY;
  return {
    name: INTEGRATION_NAME3,
    preprocessEvent(event, hint, client) {
      const options2 = client.getOptions();
      applyAggregateErrorsToEvent(exceptionFromError, options2.stackParser, key, limit, event, hint);
    }
  };
};
var linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);

// node_modules/@sentry/core/build/esm/utils/cookie.js
function parseCookie(str) {
  const obj = {};
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (void 0 === obj[key]) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      try {
        obj[key] = val.indexOf("%") !== -1 ? decodeURIComponent(val) : val;
      } catch (e) {
        obj[key] = val;
      }
    }
    index = endIdx + 1;
  }
  return obj;
}

// node_modules/@sentry/core/build/esm/vendor/getIpAddress.js
var ipHeaderNames = [
  "X-Client-IP",
  "X-Forwarded-For",
  "Fly-Client-IP",
  "CF-Connecting-IP",
  "Fastly-Client-Ip",
  "True-Client-Ip",
  "X-Real-IP",
  "X-Cluster-Client-IP",
  "X-Forwarded",
  "Forwarded-For",
  "Forwarded",
  "X-Vercel-Forwarded-For"
];
function getClientIPAddress(headers) {
  const headerValues = ipHeaderNames.map((headerName) => {
    const rawValue = headers[headerName];
    const value = Array.isArray(rawValue) ? rawValue.join(";") : rawValue;
    if (headerName === "Forwarded") {
      return parseForwardedHeader(value);
    }
    return value?.split(",").map((v) => v.trim());
  });
  const flattenedHeaderValues = headerValues.reduce((acc, val) => {
    if (!val) {
      return acc;
    }
    return acc.concat(val);
  }, []);
  const ipAddress = flattenedHeaderValues.find((ip) => ip !== null && isIP(ip));
  return ipAddress || null;
}
function parseForwardedHeader(value) {
  if (!value) {
    return null;
  }
  for (const part of value.split(";")) {
    if (part.startsWith("for=")) {
      return part.slice(4);
    }
  }
  return null;
}
function isIP(str) {
  const regex = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/;
  return regex.test(str);
}

// node_modules/@sentry/core/build/esm/integrations/requestdata.js
var DEFAULT_INCLUDE = {
  cookies: true,
  data: true,
  headers: true,
  query_string: true,
  url: true
};
var INTEGRATION_NAME4 = "RequestData";
var _requestDataIntegration = (options = {}) => {
  const include = {
    ...DEFAULT_INCLUDE,
    ...options.include
  };
  return {
    name: INTEGRATION_NAME4,
    processEvent(event, _hint, client) {
      const { sdkProcessingMetadata = {} } = event;
      const { normalizedRequest, ipAddress } = sdkProcessingMetadata;
      const includeWithDefaultPiiApplied = {
        ...include,
        ip: include.ip ?? client.getOptions().sendDefaultPii
      };
      if (normalizedRequest) {
        addNormalizedRequestDataToEvent(event, normalizedRequest, { ipAddress }, includeWithDefaultPiiApplied);
      }
      return event;
    }
  };
};
var requestDataIntegration = defineIntegration(_requestDataIntegration);
function addNormalizedRequestDataToEvent(event, req, additionalData, include) {
  event.request = {
    ...event.request,
    ...extractNormalizedRequestData(req, include)
  };
  if (include.ip) {
    const ip = req.headers && getClientIPAddress(req.headers) || additionalData.ipAddress;
    if (ip) {
      event.user = {
        ...event.user,
        ip_address: ip
      };
    }
  }
}
function extractNormalizedRequestData(normalizedRequest, include) {
  const requestData = {};
  const headers = { ...normalizedRequest.headers };
  if (include.headers) {
    requestData.headers = headers;
    if (!include.cookies) {
      delete headers.cookie;
    }
    if (!include.ip) {
      ipHeaderNames.forEach((ipHeaderName) => {
        delete headers[ipHeaderName];
      });
    }
  }
  requestData.method = normalizedRequest.method;
  if (include.url) {
    requestData.url = normalizedRequest.url;
  }
  if (include.cookies) {
    const cookies = normalizedRequest.cookies || (headers?.cookie ? parseCookie(headers.cookie) : void 0);
    requestData.cookies = cookies || {};
  }
  if (include.query_string) {
    requestData.query_string = normalizedRequest.query_string;
  }
  if (include.data) {
    requestData.data = normalizedRequest.data;
  }
  return requestData;
}

// node_modules/@sentry/core/build/esm/utils-hoist/instrument/console.js
function addConsoleInstrumentationHandler(handler) {
  const type = "console";
  addHandler(type, handler);
  maybeInstrument(type, instrumentConsole);
}
function instrumentConsole() {
  if (!("console" in GLOBAL_OBJ)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in GLOBAL_OBJ.console)) {
      return;
    }
    fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
      originalConsoleMethods[level] = originalConsoleMethod;
      return function(...args) {
        const handlerData = { args, level };
        triggerHandlers("console", handlerData);
        const log2 = originalConsoleMethods[level];
        log2?.apply(GLOBAL_OBJ.console, args);
      };
    });
  });
}

// node_modules/@sentry/core/build/esm/utils-hoist/severity.js
function severityLevelFromString(level) {
  return level === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(level) ? level : "log";
}

// node_modules/@sentry/core/build/esm/utils-hoist/path.js
var splitPathRe = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
function splitPath(filename) {
  const truncated = filename.length > 1024 ? `<truncated>${filename.slice(-1024)}` : filename;
  const parts = splitPathRe.exec(truncated);
  return parts ? parts.slice(1) : [];
}
function dirname(path) {
  const result = splitPath(path);
  const root = result[0] || "";
  let dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.slice(0, dir.length - 1);
  }
  return root + dir;
}

// node_modules/@sentry/core/build/esm/utils-hoist/url.js
function parseUrl(url2) {
  if (!url2) {
    return {};
  }
  const match = url2.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match) {
    return {};
  }
  const query = match[6] || "";
  const fragment = match[8] || "";
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    search: query,
    hash: fragment,
    relative: match[5] + query + fragment
    // everything minus origin
  };
}
function stripUrlQueryAndFragment(urlPath) {
  return urlPath.split(/[?#]/, 1)[0];
}
function getSanitizedUrlString(url2) {
  const { protocol, host, path } = url2;
  const filteredHost = host?.replace(/^.*@/, "[filtered]:[filtered]@").replace(/(:80)$/, "").replace(/(:443)$/, "") || "";
  return `${protocol ? `${protocol}://` : ""}${filteredHost}${path}`;
}

// node_modules/@sentry/core/build/esm/utils-hoist/breadcrumb-log-level.js
function getBreadcrumbLogLevelFromHttpStatusCode(statusCode) {
  if (statusCode === void 0) {
    return void 0;
  } else if (statusCode >= 400 && statusCode < 500) {
    return "warning";
  } else if (statusCode >= 500) {
    return "error";
  } else {
    return void 0;
  }
}

// node_modules/@sentry/core/build/esm/utils-hoist/node-stack-trace.js
function filenameIsInApp(filename, isNative = false) {
  const isInternal = isNative || filename && // It's not internal if it's an absolute linux path
  !filename.startsWith("/") && // It's not internal if it's an absolute windows path
  !filename.match(/^[A-Z]:/) && // It's not internal if the path is starting with a dot
  !filename.startsWith(".") && // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack
  !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
  return !isInternal && filename !== void 0 && !filename.includes("node_modules/");
}
function node(getModule) {
  const FILENAME_MATCH = /^\s*[-]{4,}$/;
  const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
  return (line) => {
    const lineMatch = line.match(FULL_MATCH);
    if (lineMatch) {
      let object;
      let method;
      let functionName;
      let typeName;
      let methodName;
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        let methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] === ".") {
          methodStart--;
        }
        if (methodStart > 0) {
          object = functionName.slice(0, methodStart);
          method = functionName.slice(methodStart + 1);
          const objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.slice(objectEnd + 1);
            object = object.slice(0, objectEnd);
          }
        }
        typeName = void 0;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = void 0;
        functionName = void 0;
      }
      if (functionName === void 0) {
        methodName = methodName || UNKNOWN_FUNCTION;
        functionName = typeName ? `${typeName}.${methodName}` : methodName;
      }
      let filename = lineMatch[2]?.startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
      const isNative = lineMatch[5] === "native";
      if (filename?.match(/\/[A-Z]:/)) {
        filename = filename.slice(1);
      }
      if (!filename && lineMatch[5] && !isNative) {
        filename = lineMatch[5];
      }
      return {
        filename: filename ? decodeURI(filename) : void 0,
        module: getModule ? getModule(filename) : void 0,
        function: functionName,
        lineno: _parseIntOrUndefined(lineMatch[3]),
        colno: _parseIntOrUndefined(lineMatch[4]),
        in_app: filenameIsInApp(filename || "", isNative)
      };
    }
    if (line.match(FILENAME_MATCH)) {
      return {
        filename: line
      };
    }
    return void 0;
  };
}
function nodeStackLineParser(getModule) {
  return [90, node(getModule)];
}
function _parseIntOrUndefined(input) {
  return parseInt(input || "", 10) || void 0;
}

// node_modules/@sentry/core/build/esm/utils-hoist/lru.js
var LRUMap = class {
  constructor(_maxSize) {
    this._maxSize = _maxSize;
    this._cache = /* @__PURE__ */ new Map();
  }
  /** Get the current size of the cache */
  get size() {
    return this._cache.size;
  }
  /** Get an entry or undefined if it was not in the cache. Re-inserts to update the recently used order */
  get(key) {
    const value = this._cache.get(key);
    if (value === void 0) {
      return void 0;
    }
    this._cache.delete(key);
    this._cache.set(key, value);
    return value;
  }
  /** Insert an entry and evict an older entry if we've reached maxSize */
  set(key, value) {
    if (this._cache.size >= this._maxSize) {
      this._cache.delete(this._cache.keys().next().value);
    }
    this._cache.set(key, value);
  }
  /** Remove an entry and return the entry if it was in the cache */
  remove(key) {
    const value = this._cache.get(key);
    if (value) {
      this._cache.delete(key);
    }
    return value;
  }
  /** Clear all entries */
  clear() {
    this._cache.clear();
  }
  /** Get all the keys */
  keys() {
    return Array.from(this._cache.keys());
  }
  /** Get all the values */
  values() {
    const values = [];
    this._cache.forEach((value) => values.push(value));
    return values;
  }
};

// node_modules/@sentry/core/build/esm/utils-hoist/vercelWaitUntil.js
function vercelWaitUntil(task) {
  const vercelRequestContextGlobal = (
    // @ts-expect-error This is not typed
    GLOBAL_OBJ[Symbol.for("@vercel/request-context")]
  );
  const ctx = vercelRequestContextGlobal?.get && vercelRequestContextGlobal.get() ? vercelRequestContextGlobal.get() : {};
  if (ctx?.waitUntil) {
    ctx.waitUntil(task);
  }
}

// node_modules/@sentry/node/build/esm/otel/instrument.js
var import_instrumentation = __toESM(require_src4(), 1);
var INSTRUMENTED = {};
function generateInstrumentOnce(name, creator) {
  return Object.assign(
    (options) => {
      const instrumented2 = INSTRUMENTED[name];
      if (instrumented2) {
        if (options) {
          instrumented2.setConfig(options);
        }
        return instrumented2;
      }
      const instrumentation = creator(options);
      INSTRUMENTED[name] = instrumentation;
      (0, import_instrumentation.registerInstrumentations)({
        instrumentations: [instrumentation]
      });
      return instrumentation;
    },
    { id: name }
  );
}
function instrumentWhenWrapped(instrumentation) {
  let isWrapped3 = false;
  let callbacks = [];
  if (!hasWrap(instrumentation)) {
    isWrapped3 = true;
  } else {
    const originalWrap = instrumentation["_wrap"];
    instrumentation["_wrap"] = (...args) => {
      isWrapped3 = true;
      callbacks.forEach((callback) => callback());
      callbacks = [];
      return originalWrap(...args);
    };
  }
  const registerCallback = (callback) => {
    if (isWrapped3) {
      callback();
    } else {
      callbacks.push(callback);
    }
  };
  return registerCallback;
}
function hasWrap(instrumentation) {
  return typeof instrumentation["_wrap"] === "function";
}

// node_modules/@sentry/node/build/esm/utils/addOriginToSpan.js
function addOriginToSpan(span, origin) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
}

// node_modules/@sentry/node/build/esm/utils/getRequestUrl.js
function getRequestUrl(requestOptions) {
  const protocol = requestOptions.protocol || "";
  const hostname2 = requestOptions.hostname || requestOptions.host || "";
  const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname2) ? "" : `:${requestOptions.port}`;
  const path = requestOptions.path ? requestOptions.path : "/";
  return `${protocol}//${hostname2}${port}${path}`;
}

// node_modules/@sentry/node/build/esm/integrations/http/SentryHttpInstrumentation.js
init_esm();
var import_core2 = __toESM(require_src(), 1);
var import_instrumentation2 = __toESM(require_src4(), 1);

// node_modules/@sentry/node/build/esm/debug-build.js
var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// node_modules/@sentry/node/build/esm/integrations/http/utils.js
function stealthWrap(nodule, name, wrapper) {
  const original = nodule[name];
  const wrapped = wrapper(original);
  defineProperty(nodule, name, wrapped);
  return wrapped;
}
function defineProperty(obj, name, value) {
  const enumerable = !!obj[name] && Object.prototype.propertyIsEnumerable.call(obj, name);
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable,
    writable: true,
    value
  });
}

// node_modules/@sentry/node/build/esm/integrations/http/vendor/getRequestInfo.js
var url = __toESM(require("url"), 1);
var getRequestInfo = (logger2, options, extraOptions) => {
  let pathname;
  let origin;
  let optionsParsed;
  let invalidUrl = false;
  if (typeof options === "string") {
    try {
      const convertedOptions = stringUrlToHttpOptions(options);
      optionsParsed = convertedOptions;
      pathname = convertedOptions.pathname || "/";
    } catch (e) {
      invalidUrl = true;
      logger2.verbose(
        "Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:",
        e
      );
      optionsParsed = {
        path: options
      };
      pathname = optionsParsed.path || "/";
    }
    origin = `${optionsParsed.protocol || "http:"}//${optionsParsed.host}`;
    if (extraOptions !== void 0) {
      Object.assign(optionsParsed, extraOptions);
    }
  } else if (options instanceof url.URL) {
    optionsParsed = {
      protocol: options.protocol,
      hostname: typeof options.hostname === "string" && options.hostname.startsWith("[") ? options.hostname.slice(1, -1) : options.hostname,
      path: `${options.pathname || ""}${options.search || ""}`
    };
    if (options.port !== "") {
      optionsParsed.port = Number(options.port);
    }
    if (options.username || options.password) {
      optionsParsed.auth = `${options.username}:${options.password}`;
    }
    pathname = options.pathname;
    origin = options.origin;
    if (extraOptions !== void 0) {
      Object.assign(optionsParsed, extraOptions);
    }
  } else {
    optionsParsed = Object.assign({ protocol: options.host ? "http:" : void 0 }, options);
    const hostname2 = optionsParsed.host || (optionsParsed.port != null ? `${optionsParsed.hostname}${optionsParsed.port}` : optionsParsed.hostname);
    origin = `${optionsParsed.protocol || "http:"}//${hostname2}`;
    pathname = options.pathname;
    if (!pathname && optionsParsed.path) {
      try {
        const parsedUrl = new URL(optionsParsed.path, origin);
        pathname = parsedUrl.pathname || "/";
      } catch (e) {
        pathname = "/";
      }
    }
  }
  const method = optionsParsed.method ? optionsParsed.method.toUpperCase() : "GET";
  return { origin, pathname, method, optionsParsed, invalidUrl };
};
function stringUrlToHttpOptions(stringUrl) {
  const { hostname: hostname2, pathname, port, username, password, search, protocol, hash, href, origin, host } = new URL(
    stringUrl
  );
  const options = {
    protocol,
    hostname: hostname2 && hostname2[0] === "[" ? hostname2.slice(1, -1) : hostname2,
    hash,
    search,
    pathname,
    path: `${pathname || ""}${search || ""}`,
    href,
    origin,
    host
  };
  if (port !== "") {
    options.port = Number(port);
  }
  if (username || password) {
    options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
  }
  return options;
}

// node_modules/@sentry/node/build/esm/integrations/http/SentryHttpInstrumentation.js
var MAX_BODY_BYTE_LENGTH = 1024 * 1024;
var SentryHttpInstrumentation = class extends import_instrumentation2.InstrumentationBase {
  constructor(config2 = {}) {
    super("@sentry/instrumentation-http", import_core2.VERSION, config2);
  }
  /** @inheritdoc */
  init() {
    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
  }
  /** Get the instrumentation for the http module. */
  _getHttpInstrumentation() {
    return new import_instrumentation2.InstrumentationNodeModuleDefinition(
      "http",
      ["*"],
      (moduleExports) => {
        stealthWrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction());
        const patchedRequest = stealthWrap(moduleExports, "request", this._getPatchOutgoingRequestFunction());
        stealthWrap(moduleExports, "get", this._getPatchOutgoingGetFunction(patchedRequest));
        return moduleExports;
      },
      () => {
      }
    );
  }
  /** Get the instrumentation for the https module. */
  _getHttpsInstrumentation() {
    return new import_instrumentation2.InstrumentationNodeModuleDefinition(
      "https",
      ["*"],
      (moduleExports) => {
        stealthWrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction());
        const patchedRequest = stealthWrap(moduleExports, "request", this._getPatchOutgoingRequestFunction());
        stealthWrap(moduleExports, "get", this._getPatchOutgoingGetFunction(patchedRequest));
        return moduleExports;
      },
      () => {
      }
    );
  }
  /**
   * Patch the incoming request function for request isolation.
   */
  _getPatchIncomingRequestFunction() {
    const instrumentation = this;
    const { ignoreIncomingRequestBody } = instrumentation.getConfig();
    return (original) => {
      return function incomingRequest(...args) {
        if (args[0] !== "request") {
          return original.apply(this, args);
        }
        instrumentation._diag.debug("http instrumentation for incoming request");
        const isolationScope = getIsolationScope().clone();
        const request = args[1];
        const response = args[2];
        const normalizedRequest = httpRequestToRequestData(request);
        const ipAddress = request.ip || request.socket?.remoteAddress;
        const url2 = request.url || "/";
        if (!ignoreIncomingRequestBody?.(url2, request)) {
          patchRequestToCaptureBody(request, isolationScope);
        }
        isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });
        const httpMethod = (request.method || "GET").toUpperCase();
        const httpTarget = stripUrlQueryAndFragment(url2);
        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;
        isolationScope.setTransactionName(bestEffortTransactionName);
        if (instrumentation.getConfig().trackIncomingRequestsAsSessions !== false) {
          recordRequestSession({
            requestIsolationScope: isolationScope,
            response,
            sessionFlushingDelayMS: instrumentation.getConfig().sessionFlushingDelayMS ?? 6e4
          });
        }
        return withIsolationScope2(isolationScope, () => {
          getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();
          if (!instrumentation.getConfig().extractIncomingTraceFromHeader) {
            return original.apply(this, args);
          }
          const ctx = propagation.extract(context.active(), normalizedRequest.headers);
          return context.with(ctx, () => {
            return original.apply(this, args);
          });
        });
      };
    };
  }
  /**
   * Patch the outgoing request function for breadcrumbs.
   */
  _getPatchOutgoingRequestFunction() {
    const instrumentation = this;
    return (original) => {
      return function outgoingRequest(...args) {
        instrumentation._diag.debug("http instrumentation for outgoing requests");
        const argsCopy = [...args];
        const options = argsCopy.shift();
        const extraOptions = typeof argsCopy[0] === "object" && (typeof options === "string" || options instanceof URL) ? argsCopy.shift() : void 0;
        const { optionsParsed } = getRequestInfo(instrumentation._diag, options, extraOptions);
        const request = original.apply(this, args);
        request.prependListener("response", (response) => {
          const _breadcrumbs = instrumentation.getConfig().breadcrumbs;
          const breadCrumbsEnabled = typeof _breadcrumbs === "undefined" ? true : _breadcrumbs;
          const _ignoreOutgoingRequests = instrumentation.getConfig().ignoreOutgoingRequests;
          const shouldCreateBreadcrumb = typeof _ignoreOutgoingRequests === "function" ? !_ignoreOutgoingRequests(getRequestUrl(request), optionsParsed) : true;
          if (breadCrumbsEnabled && shouldCreateBreadcrumb) {
            addRequestBreadcrumb(request, response);
          }
        });
        return request;
      };
    };
  }
  /** Path the outgoing get function for breadcrumbs. */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _getPatchOutgoingGetFunction(clientRequest) {
    return (_original) => {
      return function outgoingGetRequest(...args) {
        const req = clientRequest(...args);
        req.end();
        return req;
      };
    };
  }
};
function addRequestBreadcrumb(request, response) {
  const data = getBreadcrumbData(request);
  const statusCode = response.statusCode;
  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
  addBreadcrumb(
    {
      category: "http",
      data: {
        status_code: statusCode,
        ...data
      },
      type: "http",
      level
    },
    {
      event: "response",
      request,
      response
    }
  );
}
function getBreadcrumbData(request) {
  try {
    const host = request.getHeader("host") || request.host;
    const url2 = new URL(request.path, `${request.protocol}//${host}`);
    const parsedUrl = parseUrl(url2.toString());
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch {
    return {};
  }
}
function patchRequestToCaptureBody(req, isolationScope) {
  const chunks = [];
  function getChunksSize() {
    return chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);
  }
  const callbackMap = /* @__PURE__ */ new WeakMap();
  try {
    req.on = new Proxy(req.on, {
      apply: (target, thisArg, args) => {
        const [event, listener, ...restArgs] = args;
        if (event === "data") {
          const callback = new Proxy(listener, {
            apply: (target2, thisArg2, args2) => {
              if (getChunksSize() < MAX_BODY_BYTE_LENGTH) {
                const chunk = args2[0];
                chunks.push(chunk);
              } else if (DEBUG_BUILD3) {
                logger.log(
                  `Dropping request body chunk because it maximum body length of ${MAX_BODY_BYTE_LENGTH}b is exceeded.`
                );
              }
              return Reflect.apply(target2, thisArg2, args2);
            }
          });
          callbackMap.set(listener, callback);
          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);
        }
        if (event === "end") {
          const callback = new Proxy(listener, {
            apply: (target2, thisArg2, args2) => {
              try {
                const body = Buffer.concat(chunks).toString("utf-8");
                if (body) {
                  const normalizedRequest = { data: body };
                  isolationScope.setSDKProcessingMetadata({ normalizedRequest });
                }
              } catch {
              }
              return Reflect.apply(target2, thisArg2, args2);
            }
          });
          callbackMap.set(listener, callback);
          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);
        }
        return Reflect.apply(target, thisArg, args);
      }
    });
    req.off = new Proxy(req.off, {
      apply: (target, thisArg, args) => {
        const [, listener] = args;
        const callback = callbackMap.get(listener);
        if (callback) {
          callbackMap.delete(listener);
          const modifiedArgs = args.slice();
          modifiedArgs[1] = callback;
          return Reflect.apply(target, thisArg, modifiedArgs);
        }
        return Reflect.apply(target, thisArg, args);
      }
    });
  } catch {
  }
}
function recordRequestSession({
  requestIsolationScope,
  response,
  sessionFlushingDelayMS
}) {
  requestIsolationScope.setSDKProcessingMetadata({
    requestSession: { status: "ok" }
  });
  response.once("close", () => {
    const client = getClient();
    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;
    if (client && requestSession) {
      DEBUG_BUILD3 && logger.debug(`Recorded request session with status: ${requestSession.status}`);
      const roundedDate = /* @__PURE__ */ new Date();
      roundedDate.setSeconds(0, 0);
      const dateBucketKey = roundedDate.toISOString();
      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);
      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };
      bucket[{ ok: "exited", crashed: "crashed", errored: "errored" }[requestSession.status]]++;
      if (existingClientAggregate) {
        existingClientAggregate[dateBucketKey] = bucket;
      } else {
        DEBUG_BUILD3 && logger.debug("Opened new request session aggregate.");
        const newClientAggregate = { [dateBucketKey]: bucket };
        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);
        const flushPendingClientAggregates = () => {
          clearTimeout(timeout);
          unregisterClientFlushHook();
          clientToRequestSessionAggregatesMap.delete(client);
          const aggregatePayload = Object.entries(newClientAggregate).map(
            ([timestamp, value]) => ({
              started: timestamp,
              exited: value.exited,
              errored: value.errored,
              crashed: value.crashed
            })
          );
          client.sendSession({ aggregates: aggregatePayload });
        };
        const unregisterClientFlushHook = client.on("flush", () => {
          DEBUG_BUILD3 && logger.debug("Sending request session aggregate due to client flush");
          flushPendingClientAggregates();
        });
        const timeout = setTimeout(() => {
          DEBUG_BUILD3 && logger.debug("Sending request session aggregate due to flushing schedule");
          flushPendingClientAggregates();
        }, sessionFlushingDelayMS).unref();
      }
    }
  });
}
var clientToRequestSessionAggregatesMap = /* @__PURE__ */ new Map();

// node_modules/@sentry/node/build/esm/integrations/http/SentryHttpInstrumentationBeforeOtel.js
var import_core4 = __toESM(require_src(), 1);
var import_instrumentation3 = __toESM(require_src4(), 1);
var SentryHttpInstrumentationBeforeOtel = class extends import_instrumentation3.InstrumentationBase {
  constructor() {
    super("@sentry/instrumentation-http-before-otel", import_core4.VERSION, {});
  }
  // eslint-disable-next-line jsdoc/require-jsdoc
  init() {
    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
  }
  /** Get the instrumentation for the http module. */
  _getHttpInstrumentation() {
    return new import_instrumentation3.InstrumentationNodeModuleDefinition("http", ["*"], (moduleExports) => {
      stealthWrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction());
      return moduleExports;
    });
  }
  /** Get the instrumentation for the https module. */
  _getHttpsInstrumentation() {
    return new import_instrumentation3.InstrumentationNodeModuleDefinition("https", ["*"], (moduleExports) => {
      stealthWrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction());
      return moduleExports;
    });
  }
  /**
   * Patch the incoming request function for request isolation.
   */
  _getPatchIncomingRequestFunction() {
    return (original) => {
      return function incomingRequest(...args) {
        if (args[0] !== "request") {
          return original.apply(this, args);
        }
        const response = args[1];
        patchResponseToFlushOnServerlessPlatforms(response);
        return original.apply(this, args);
      };
    };
  }
};
function patchResponseToFlushOnServerlessPlatforms(res) {
  if (process.env.VERCEL) {
    if (typeof res.end === "function") {
      let markOnEndDone = () => void 0;
      const onEndDonePromise = new Promise((res2) => {
        markOnEndDone = res2;
      });
      res.on("close", () => {
        markOnEndDone();
      });
      res.end = new Proxy(res.end, {
        apply(target, thisArg, argArray) {
          vercelWaitUntil(
            new Promise((finishWaitUntil) => {
              const timeout = setTimeout(() => {
                finishWaitUntil();
              }, 2e3);
              onEndDonePromise.then(() => {
                DEBUG_BUILD3 && logger.log("Flushing events before Vercel Lambda freeze");
                return flush(2e3);
              }).then(
                () => {
                  clearTimeout(timeout);
                  finishWaitUntil();
                },
                (e) => {
                  clearTimeout(timeout);
                  DEBUG_BUILD3 && logger.log("Error while flushing events for Vercel:\n", e);
                  finishWaitUntil();
                }
              );
            })
          );
          return target.apply(thisArg, argArray);
        }
      });
    }
  }
}

// node_modules/@sentry/node/build/esm/integrations/http/index.js
var INTEGRATION_NAME5 = "Http";
var INSTRUMENTATION_NAME = "@opentelemetry_sentry-patched/instrumentation-http";
var instrumentSentryHttpBeforeOtel = generateInstrumentOnce(`${INTEGRATION_NAME5}.sentry-before-otel`, () => {
  return new SentryHttpInstrumentationBeforeOtel();
});
var instrumentSentryHttp = generateInstrumentOnce(
  `${INTEGRATION_NAME5}.sentry`,
  (options) => {
    return new SentryHttpInstrumentation(options);
  }
);
var instrumentOtelHttp = generateInstrumentOnce(INTEGRATION_NAME5, (config2) => {
  const instrumentation = new import_instrumentation_http.HttpInstrumentation(config2);
  try {
    instrumentation["_diag"] = diag2.createComponentLogger({
      namespace: INSTRUMENTATION_NAME
    });
    instrumentation.instrumentationName = INSTRUMENTATION_NAME;
  } catch {
  }
  return instrumentation;
});
function _shouldInstrumentSpans(options, clientOptions = {}) {
  return typeof options.spans === "boolean" ? options.spans : !clientOptions.skipOpenTelemetrySetup;
}
var httpIntegration = defineIntegration((options = {}) => {
  return {
    name: INTEGRATION_NAME5,
    setupOnce() {
      if (process.env.VERCEL) {
        instrumentSentryHttpBeforeOtel();
      }
      const instrumentSpans = _shouldInstrumentSpans(options, getClient()?.getOptions());
      if (instrumentSpans) {
        const instrumentationConfig = getConfigWithDefaults(options);
        instrumentOtelHttp(instrumentationConfig);
      }
      instrumentSentryHttp({
        ...options,
        // If spans are not instrumented, it means the HttpInstrumentation has not been added
        // In that case, we want to handle incoming trace extraction ourselves
        extractIncomingTraceFromHeader: !instrumentSpans
      });
    }
  };
});
function _isClientRequest(req) {
  return "outputData" in req && "outputSize" in req && !("client" in req) && !("statusCode" in req);
}
function isKnownPrefetchRequest(req) {
  return req.headers["next-router-prefetch"] === "1";
}
function getConfigWithDefaults(options = {}) {
  const instrumentationConfig = {
    ...options.instrumentation?._experimentalConfig,
    disableIncomingRequestInstrumentation: options.disableIncomingRequestSpans,
    ignoreOutgoingRequestHook: (request) => {
      const url2 = getRequestUrl(request);
      if (!url2) {
        return false;
      }
      const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
      if (_ignoreOutgoingRequests?.(url2, request)) {
        return true;
      }
      return false;
    },
    ignoreIncomingRequestHook: (request) => {
      const urlPath = request.url;
      const method = request.method?.toUpperCase();
      if (method === "OPTIONS" || method === "HEAD") {
        return true;
      }
      const _ignoreIncomingRequests = options.ignoreIncomingRequests;
      if (urlPath && _ignoreIncomingRequests?.(urlPath, request)) {
        return true;
      }
      return false;
    },
    requireParentforOutgoingSpans: false,
    requireParentforIncomingSpans: false,
    requestHook: (span, req) => {
      addOriginToSpan(span, "auto.http.otel.http");
      if (!_isClientRequest(req) && isKnownPrefetchRequest(req)) {
        span.setAttribute("sentry.http.prefetch", true);
      }
      options.instrumentation?.requestHook?.(span, req);
    },
    responseHook: (span, res) => {
      options.instrumentation?.responseHook?.(span, res);
    },
    applyCustomAttributesOnSpan: (span, request, response) => {
      options.instrumentation?.applyCustomAttributesOnSpan?.(span, request, response);
    }
  };
  return instrumentationConfig;
}

// node_modules/@sentry/node/build/esm/integrations/node-fetch/index.js
var import_instrumentation_undici = __toESM(require_src6(), 1);

// node_modules/@sentry/node/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
var import_core11 = __toESM(require_src(), 1);
var import_instrumentation4 = __toESM(require_src4(), 1);

// node_modules/@sentry/opentelemetry/build/esm/index.js
init_esm4();
init_esm();
init_esm();
var import_core8 = __toESM(require_src(), 1);
var import_sdk_trace_base = __toESM(require_src8(), 1);
var SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = "sentry.parentIsRemote";
var SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = "sentry.graphql.operation";
function spanHasAttributes(span) {
  const castSpan = span;
  return !!castSpan.attributes && typeof castSpan.attributes === "object";
}
function spanHasKind(span) {
  const castSpan = span;
  return typeof castSpan.kind === "number";
}
function spanHasStatus(span) {
  const castSpan = span;
  return !!castSpan.status;
}
function spanHasName(span) {
  const castSpan = span;
  return !!castSpan.name;
}
function getRequestSpanData(span) {
  if (!spanHasAttributes(span)) {
    return {};
  }
  const maybeUrlAttribute = span.attributes[ATTR_URL_FULL3] || span.attributes[SEMATTRS_HTTP_URL3];
  const data = {
    url: maybeUrlAttribute,
    // eslint-disable-next-line deprecation/deprecation
    "http.method": span.attributes[ATTR_HTTP_REQUEST_METHOD3] || span.attributes[SEMATTRS_HTTP_METHOD3]
  };
  if (!data["http.method"] && data.url) {
    data["http.method"] = "GET";
  }
  try {
    if (typeof maybeUrlAttribute === "string") {
      const url2 = parseUrl(maybeUrlAttribute);
      data.url = getSanitizedUrlString(url2);
      if (url2.search) {
        data["http.query"] = url2.search;
      }
      if (url2.hash) {
        data["http.fragment"] = url2.hash;
      }
    }
  } catch {
  }
  return data;
}
function getSpanKind(span) {
  if (spanHasKind(span)) {
    return span.kind;
  }
  return SpanKind.INTERNAL;
}
var SENTRY_TRACE_HEADER = "sentry-trace";
var SENTRY_BAGGAGE_HEADER = "baggage";
var SENTRY_TRACE_STATE_DSC = "sentry.dsc";
var SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = "sentry.sampled_not_recording";
var SENTRY_TRACE_STATE_URL = "sentry.url";
var SENTRY_TRACE_STATE_SAMPLE_RAND = "sentry.sample_rand";
var SENTRY_TRACE_STATE_SAMPLE_RATE = "sentry.sample_rate";
var SENTRY_SCOPES_CONTEXT_KEY = createContextKey("sentry_scopes");
var SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey("sentry_fork_isolation_scope");
var SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = createContextKey("sentry_fork_set_scope");
var SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey("sentry_fork_set_isolation_scope");
var SCOPE_CONTEXT_FIELD = "_scopeContext";
function getScopesFromContext(context3) {
  return context3.getValue(SENTRY_SCOPES_CONTEXT_KEY);
}
function setScopesOnContext(context3, scopes) {
  return context3.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);
}
function setContextOnScope(scope, context3) {
  addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context3);
}
function getContextFromScope(scope) {
  return scope[SCOPE_CONTEXT_FIELD];
}
function getSamplingDecision(spanContext) {
  const { traceFlags, traceState } = spanContext;
  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === "1" : false;
  if (traceFlags === TraceFlags.SAMPLED) {
    return true;
  }
  if (sampledNotRecording) {
    return false;
  }
  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : void 0;
  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : void 0;
  if (dsc?.sampled === "true") {
    return true;
  }
  if (dsc?.sampled === "false") {
    return false;
  }
  return void 0;
}
function inferSpanData(spanName, attributes, kind) {
  const httpMethod = attributes[ATTR_HTTP_REQUEST_METHOD3] || attributes[SEMATTRS_HTTP_METHOD3];
  if (httpMethod) {
    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);
  }
  const dbSystem = attributes[SEMATTRS_DB_SYSTEM3];
  const opIsCache = typeof attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] === "string" && attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith("cache.");
  if (dbSystem && !opIsCache) {
    return descriptionForDbSystem({ attributes, name: spanName });
  }
  const customSourceOrRoute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === "custom" ? "custom" : "route";
  const rpcService = attributes[SEMATTRS_RPC_SERVICE3];
  if (rpcService) {
    return {
      ...getUserUpdatedNameAndSource(spanName, attributes, "route"),
      op: "rpc"
    };
  }
  const messagingSystem = attributes[SEMATTRS_MESSAGING_SYSTEM3];
  if (messagingSystem) {
    return {
      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),
      op: "message"
    };
  }
  const faasTrigger = attributes[SEMATTRS_FAAS_TRIGGER3];
  if (faasTrigger) {
    return {
      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),
      op: faasTrigger.toString()
    };
  }
  return { op: void 0, description: spanName, source: "custom" };
}
function parseSpanDescription(span) {
  const attributes = spanHasAttributes(span) ? span.attributes : {};
  const name = spanHasName(span) ? span.name : "<unknown>";
  const kind = getSpanKind(span);
  return inferSpanData(name, attributes, kind);
}
function descriptionForDbSystem({ attributes, name }) {
  const userDefinedName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  if (typeof userDefinedName === "string") {
    return {
      op: "db",
      description: userDefinedName,
      source: attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] || "custom"
    };
  }
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === "custom") {
    return { op: "db", description: name, source: "custom" };
  }
  const statement = attributes[SEMATTRS_DB_STATEMENT3];
  const description = statement ? statement.toString() : name;
  return { op: "db", description, source: "task" };
}
function descriptionForHttpMethod({ name, kind, attributes }, httpMethod) {
  const opParts = ["http"];
  switch (kind) {
    case SpanKind.CLIENT:
      opParts.push("client");
      break;
    case SpanKind.SERVER:
      opParts.push("server");
      break;
  }
  if (attributes["sentry.http.prefetch"]) {
    opParts.push("prefetch");
  }
  const { urlPath, url: url2, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);
  if (!urlPath) {
    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join(".") };
  }
  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];
  const baseDescription = `${httpMethod} ${urlPath}`;
  const inferredDescription = graphqlOperationsAttribute ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})` : baseDescription;
  const inferredSource = hasRoute || urlPath === "/" ? "route" : "url";
  const data = {};
  if (url2) {
    data.url = url2;
  }
  if (query) {
    data["http.query"] = query;
  }
  if (fragment) {
    data["http.fragment"] = fragment;
  }
  const isClientOrServerKind = kind === SpanKind.CLIENT || kind === SpanKind.SERVER;
  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || "manual";
  const isManualSpan = !`${origin}`.startsWith("auto");
  const alreadyHasCustomSource = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === "custom";
  const customSpanName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  const useInferredDescription = !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);
  const { description, source } = useInferredDescription ? { description: inferredDescription, source: inferredSource } : getUserUpdatedNameAndSource(name, attributes);
  return {
    op: opParts.join("."),
    description,
    source,
    data
  };
}
function getGraphqlOperationNamesFromAttribute(attr) {
  if (Array.isArray(attr)) {
    const sorted = attr.slice().sort();
    if (sorted.length <= 5) {
      return sorted.join(", ");
    } else {
      return `${sorted.slice(0, 5).join(", ")}, +${sorted.length - 5}`;
    }
  }
  return `${attr}`;
}
function getSanitizedUrl(attributes, kind) {
  const httpTarget = attributes[SEMATTRS_HTTP_TARGET3];
  const httpUrl = attributes[SEMATTRS_HTTP_URL3] || attributes[ATTR_URL_FULL3];
  const httpRoute = attributes[ATTR_HTTP_ROUTE3];
  const parsedUrl = typeof httpUrl === "string" ? parseUrl(httpUrl) : void 0;
  const url2 = parsedUrl ? getSanitizedUrlString(parsedUrl) : void 0;
  const query = parsedUrl?.search || void 0;
  const fragment = parsedUrl?.hash || void 0;
  if (typeof httpRoute === "string") {
    return { urlPath: httpRoute, url: url2, query, fragment, hasRoute: true };
  }
  if (kind === SpanKind.SERVER && typeof httpTarget === "string") {
    return { urlPath: stripUrlQueryAndFragment(httpTarget), url: url2, query, fragment, hasRoute: false };
  }
  if (parsedUrl) {
    return { urlPath: url2, url: url2, query, fragment, hasRoute: false };
  }
  if (typeof httpTarget === "string") {
    return { urlPath: stripUrlQueryAndFragment(httpTarget), url: url2, query, fragment, hasRoute: false };
  }
  return { urlPath: void 0, url: url2, query, fragment, hasRoute: false };
}
function getUserUpdatedNameAndSource(originalName, attributes, fallbackSource = "custom") {
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] || fallbackSource;
  const description = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  if (description && typeof description === "string") {
    return {
      description,
      source
    };
  }
  return { description: originalName, source };
}
function enhanceDscWithOpenTelemetryRootSpanName(client) {
  client.on("createDsc", (dsc, rootSpan) => {
    if (!rootSpan) {
      return;
    }
    const jsonSpan = spanToJSON(rootSpan);
    const attributes = jsonSpan.data;
    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: void 0 };
    if (source !== "url" && description) {
      dsc.transaction = description;
    }
    if (hasSpansEnabled()) {
      const sampled = getSamplingDecision(rootSpan.spanContext());
      dsc.sampled = sampled == void 0 ? void 0 : String(sampled);
    }
  });
}
function getActiveSpan3() {
  return trace.getActiveSpan();
}
var DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
function makeTraceState({
  dsc,
  sampled
}) {
  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : void 0;
  const traceStateBase = new import_core8.TraceState();
  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;
  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") : traceStateWithDsc;
}
var setupElements = /* @__PURE__ */ new Set();
function openTelemetrySetupCheck() {
  return Array.from(setupElements);
}
function setIsSetup(element) {
  setupElements.add(element);
}
var SentryPropagator = class extends import_core8.W3CBaggagePropagator {
  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */
  constructor() {
    super();
    setIsSetup("SentryPropagator");
    this._urlMatchesTargetsMap = new LRUMap(100);
  }
  /**
   * @inheritDoc
   */
  inject(context3, carrier, setter) {
    if ((0, import_core8.isTracingSuppressed)(context3)) {
      DEBUG_BUILD4 && logger.log("[Tracing] Not injecting trace data for url because tracing is suppressed.");
      return;
    }
    const activeSpan = trace.getSpan(context3);
    const url2 = activeSpan && getCurrentURL(activeSpan);
    const tracePropagationTargets = getClient()?.getOptions()?.tracePropagationTargets;
    if (!shouldPropagateTraceForUrl(url2, tracePropagationTargets, this._urlMatchesTargetsMap)) {
      DEBUG_BUILD4 && logger.log(
        "[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:",
        url2
      );
      return;
    }
    const existingBaggageHeader = getExistingBaggage(carrier);
    let baggage = propagation.getBaggage(context3) || propagation.createBaggage({});
    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context3);
    if (existingBaggageHeader) {
      const baggageEntries = parseBaggageHeader(existingBaggageHeader);
      if (baggageEntries) {
        Object.entries(baggageEntries).forEach(([key, value]) => {
          baggage = baggage.setEntry(key, { value });
        });
      }
    }
    if (dynamicSamplingContext) {
      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {
        if (dscValue) {
          return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });
        }
        return b;
      }, baggage);
    }
    if (traceId && traceId !== INVALID_TRACEID) {
      setter.set(carrier, SENTRY_TRACE_HEADER, generateSentryTraceHeader(traceId, spanId, sampled));
    }
    super.inject(propagation.setBaggage(context3, baggage), carrier, setter);
  }
  /**
   * @inheritDoc
   */
  extract(context3, carrier, getter) {
    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);
    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);
    const sentryTrace = maybeSentryTraceHeader ? Array.isArray(maybeSentryTraceHeader) ? maybeSentryTraceHeader[0] : maybeSentryTraceHeader : void 0;
    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context3, { sentryTrace, baggage }));
  }
  /**
   * @inheritDoc
   */
  fields() {
    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];
  }
};
var NOT_PROPAGATED_MESSAGE = "[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:";
function shouldPropagateTraceForUrl(url2, tracePropagationTargets, decisionMap) {
  if (typeof url2 !== "string" || !tracePropagationTargets) {
    return true;
  }
  const cachedDecision = decisionMap?.get(url2);
  if (cachedDecision !== void 0) {
    DEBUG_BUILD4 && !cachedDecision && logger.log(NOT_PROPAGATED_MESSAGE, url2);
    return cachedDecision;
  }
  const decision = stringMatchesSomePattern(url2, tracePropagationTargets);
  decisionMap?.set(url2, decision);
  DEBUG_BUILD4 && !decision && logger.log(NOT_PROPAGATED_MESSAGE, url2);
  return decision;
}
function getInjectionData(context3) {
  const span = trace.getSpan(context3);
  if (span?.spanContext().isRemote) {
    const spanContext = span.spanContext();
    const dynamicSamplingContext2 = getDynamicSamplingContextFromSpan(span);
    return {
      dynamicSamplingContext: dynamicSamplingContext2,
      traceId: spanContext.traceId,
      spanId: void 0,
      sampled: getSamplingDecision(spanContext)
      // TODO: Do we need to change something here?
    };
  }
  if (span) {
    const spanContext = span.spanContext();
    const dynamicSamplingContext2 = getDynamicSamplingContextFromSpan(span);
    return {
      dynamicSamplingContext: dynamicSamplingContext2,
      traceId: spanContext.traceId,
      spanId: spanContext.spanId,
      sampled: getSamplingDecision(spanContext)
      // TODO: Do we need to change something here?
    };
  }
  const scope = getScopesFromContext(context3)?.scope || getCurrentScope();
  const client = getClient();
  const propagationContext = scope.getPropagationContext();
  const dynamicSamplingContext = client ? getDynamicSamplingContextFromScope(client, scope) : void 0;
  return {
    dynamicSamplingContext,
    traceId: propagationContext.traceId,
    spanId: propagationContext.propagationSpanId,
    sampled: propagationContext.sampled
  };
}
function getContextWithRemoteActiveSpan(ctx, { sentryTrace, baggage }) {
  const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);
  const { traceId, parentSpanId, sampled, dsc } = propagationContext;
  if (!parentSpanId) {
    return ctx;
  }
  const spanContext = generateRemoteSpanContext({
    traceId,
    spanId: parentSpanId,
    sampled,
    dsc
  });
  return trace.setSpanContext(ctx, spanContext);
}
function continueTraceAsRemoteSpan(ctx, options, callback) {
  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));
  return context.with(ctxWithSpanContext, callback);
}
function ensureScopesOnContext(ctx) {
  const scopes = getScopesFromContext(ctx);
  const newScopes = {
    // If we have no scope here, this is most likely either the root context or a context manually derived from it
    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope
    scope: scopes ? scopes.scope : getCurrentScope().clone(),
    isolationScope: scopes ? scopes.isolationScope : getIsolationScope()
  };
  return setScopesOnContext(ctx, newScopes);
}
function getExistingBaggage(carrier) {
  try {
    const baggage = carrier[SENTRY_BAGGAGE_HEADER];
    return Array.isArray(baggage) ? baggage.join(",") : baggage;
  } catch {
    return void 0;
  }
}
function getCurrentURL(span) {
  const spanData = spanToJSON(span).data;
  const urlAttribute = spanData[SEMATTRS_HTTP_URL3] || spanData[ATTR_URL_FULL3];
  if (typeof urlAttribute === "string") {
    return urlAttribute;
  }
  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);
  if (urlTraceState) {
    return urlTraceState;
  }
  return void 0;
}
function generateRemoteSpanContext({
  spanId,
  traceId,
  sampled,
  dsc
}) {
  const traceState = makeTraceState({
    dsc,
    sampled
  });
  const spanContext = {
    traceId,
    spanId,
    isRemote: true,
    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,
    traceState
  };
  return spanContext;
}
function startSpan2(options, callback) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? (0, import_core8.suppressTracing)(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    return tracer.startActiveSpan(name, spanOptions, ctx, (span) => {
      return handleCallbackErrors(
        () => callback(span),
        () => {
          if (spanToJSON(span).status === void 0) {
            span.setStatus({ code: SpanStatusCode.ERROR });
          }
        },
        () => span.end()
      );
    });
  });
}
function startSpanManual2(options, callback) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? (0, import_core8.suppressTracing)(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    return tracer.startActiveSpan(name, spanOptions, ctx, (span) => {
      return handleCallbackErrors(
        () => callback(span, () => span.end()),
        () => {
          if (spanToJSON(span).status === void 0) {
            span.setStatus({ code: SpanStatusCode.ERROR });
          }
        }
      );
    });
  });
}
function startInactiveSpan2(options) {
  const tracer = getTracer();
  const { name, parentSpan: customParentSpan } = options;
  const wrapper = getActiveSpanWrapper2(customParentSpan);
  return wrapper(() => {
    const activeCtx = getContext(options.scope, options.forceTransaction);
    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);
    const ctx = shouldSkipSpan ? (0, import_core8.suppressTracing)(activeCtx) : activeCtx;
    const spanOptions = getSpanOptions(options);
    const span = tracer.startSpan(name, spanOptions, ctx);
    return span;
  });
}
function withActiveSpan2(span, callback) {
  const newContextWithActiveSpan = span ? trace.setSpan(context.active(), span) : trace.deleteSpan(context.active());
  return context.with(newContextWithActiveSpan, () => callback(getCurrentScope()));
}
function getTracer() {
  const client = getClient();
  return client?.tracer || trace.getTracer("@sentry/opentelemetry", SDK_VERSION);
}
function getSpanOptions(options) {
  const { startTime, attributes, kind, op, links } = options;
  const fixedStartTime = typeof startTime === "number" ? ensureTimestampInMilliseconds(startTime) : startTime;
  return {
    attributes: op ? {
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
      ...attributes
    } : attributes,
    kind,
    links,
    startTime: fixedStartTime
  };
}
function ensureTimestampInMilliseconds(timestamp) {
  const isMs = timestamp < 9999999999;
  return isMs ? timestamp * 1e3 : timestamp;
}
function getContext(scope, forceTransaction) {
  const ctx = getContextForScope(scope);
  const parentSpan = trace.getSpan(ctx);
  if (!parentSpan) {
    return ctx;
  }
  if (!forceTransaction) {
    return ctx;
  }
  const ctxWithoutSpan = trace.deleteSpan(ctx);
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = getSamplingDecision(parentSpan.spanContext());
  const rootSpan = getRootSpan(parentSpan);
  const dsc = getDynamicSamplingContextFromSpan(rootSpan);
  const traceState = makeTraceState({
    dsc,
    sampled
  });
  const spanOptions = {
    traceId,
    spanId,
    isRemote: true,
    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,
    traceState
  };
  const ctxWithSpanContext = trace.setSpanContext(ctxWithoutSpan, spanOptions);
  return ctxWithSpanContext;
}
function getContextForScope(scope) {
  if (scope) {
    const ctx = getContextFromScope(scope);
    if (ctx) {
      return ctx;
    }
  }
  return context.active();
}
function continueTrace2(options, callback) {
  return continueTraceAsRemoteSpan(context.active(), options, callback);
}
function getTraceContextForScope(client, scope) {
  const ctx = getContextFromScope(scope);
  const span = ctx && trace.getSpan(ctx);
  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);
  const dynamicSamplingContext = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);
  return [dynamicSamplingContext, traceContext];
}
function getActiveSpanWrapper2(parentSpan) {
  return parentSpan !== void 0 ? (callback) => {
    return withActiveSpan2(parentSpan, callback);
  } : (callback) => callback();
}
function suppressTracing2(callback) {
  const ctx = (0, import_core8.suppressTracing)(context.active());
  return context.with(ctx, callback);
}
function setupEventContextTrace(client) {
  client.on("preprocessEvent", (event) => {
    const span = getActiveSpan3();
    if (!span || event.type === "transaction") {
      return;
    }
    event.contexts = {
      trace: spanToTraceContext(span),
      ...event.contexts
    };
    const rootSpan = getRootSpan(span);
    event.sdkProcessingMetadata = {
      dynamicSamplingContext: getDynamicSamplingContextFromSpan(rootSpan),
      ...event.sdkProcessingMetadata
    };
    return event;
  });
}
function getTraceData2({ span } = {}) {
  let ctx = context.active();
  if (span) {
    const { scope } = getCapturedScopesOnSpan(span);
    ctx = scope && getContextFromScope(scope) || trace.setSpan(context.active(), span);
  }
  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx);
  return {
    "sentry-trace": generateSentryTraceHeader(traceId, spanId, sampled),
    baggage: dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext)
  };
}
function setOpenTelemetryContextAsyncContextStrategy() {
  function getScopes() {
    const ctx = context.active();
    const scopes = getScopesFromContext(ctx);
    if (scopes) {
      return scopes;
    }
    return {
      scope: getDefaultCurrentScope(),
      isolationScope: getDefaultIsolationScope()
    };
  }
  function withScope3(callback) {
    const ctx = context.active();
    return context.with(ctx, () => {
      return callback(getCurrentScope2());
    });
  }
  function withSetScope2(scope, callback) {
    const ctx = context.active();
    return context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {
      return callback(scope);
    });
  }
  function withIsolationScope3(callback) {
    const ctx = context.active();
    return context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {
      return callback(getIsolationScope2());
    });
  }
  function withSetIsolationScope(isolationScope, callback) {
    const ctx = context.active();
    return context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {
      return callback(getIsolationScope2());
    });
  }
  function getCurrentScope2() {
    return getScopes().scope;
  }
  function getIsolationScope2() {
    return getScopes().isolationScope;
  }
  setAsyncContextStrategy({
    withScope: withScope3,
    withSetScope: withSetScope2,
    withSetIsolationScope,
    withIsolationScope: withIsolationScope3,
    getCurrentScope: getCurrentScope2,
    getIsolationScope: getIsolationScope2,
    startSpan: startSpan2,
    startSpanManual: startSpanManual2,
    startInactiveSpan: startInactiveSpan2,
    getActiveSpan: getActiveSpan3,
    suppressTracing: suppressTracing2,
    getTraceData: getTraceData2,
    continueTrace: continueTrace2,
    // The types here don't fully align, because our own `Span` type is narrower
    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around
    withActiveSpan: withActiveSpan2
  });
}
function wrapContextManagerClass(ContextManagerClass) {
  class SentryContextManager2 extends ContextManagerClass {
    constructor(...args) {
      super(...args);
      setIsSetup("SentryContextManager");
    }
    /**
     * Overwrite with() of the original AsyncLocalStorageContextManager
     * to ensure we also create new scopes per context.
     */
    with(context3, fn, thisArg, ...args) {
      const currentScopes = getScopesFromContext(context3);
      const currentScope = currentScopes?.scope || getCurrentScope();
      const currentIsolationScope = currentScopes?.isolationScope || getIsolationScope();
      const shouldForkIsolationScope = context3.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;
      const scope = context3.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY);
      const isolationScope = context3.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);
      const newCurrentScope = scope || currentScope.clone();
      const newIsolationScope = isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);
      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };
      const ctx1 = setScopesOnContext(context3, scopes);
      const ctx2 = ctx1.deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY).deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY).deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);
      setContextOnScope(newCurrentScope, ctx2);
      return super.with(ctx2, fn, thisArg, ...args);
    }
  }
  return SentryContextManager2;
}
function groupSpansWithParents(spans) {
  const nodeMap = /* @__PURE__ */ new Map();
  for (const span of spans) {
    createOrUpdateSpanNodeAndRefs(nodeMap, span);
  }
  return Array.from(nodeMap, function([_id, spanNode]) {
    return spanNode;
  });
}
function getLocalParentId(span) {
  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;
  return !parentIsRemote ? span.parentSpanId : void 0;
}
function createOrUpdateSpanNodeAndRefs(nodeMap, span) {
  const id = span.spanContext().spanId;
  const parentId = getLocalParentId(span);
  if (!parentId) {
    createOrUpdateNode(nodeMap, { id, span, children: [] });
    return;
  }
  const parentNode = createOrGetParentNode(nodeMap, parentId);
  const node2 = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });
  parentNode.children.push(node2);
}
function createOrGetParentNode(nodeMap, id) {
  const existing = nodeMap.get(id);
  if (existing) {
    return existing;
  }
  return createOrUpdateNode(nodeMap, { id, children: [] });
}
function createOrUpdateNode(nodeMap, spanNode) {
  const existing = nodeMap.get(spanNode.id);
  if (existing?.span) {
    return existing;
  }
  if (existing && !existing.span) {
    existing.span = spanNode.span;
    existing.parentNode = spanNode.parentNode;
    return existing;
  }
  nodeMap.set(spanNode.id, spanNode);
  return spanNode;
}
var canonicalGrpcErrorCodesMap = {
  "1": "cancelled",
  "2": "unknown_error",
  "3": "invalid_argument",
  "4": "deadline_exceeded",
  "5": "not_found",
  "6": "already_exists",
  "7": "permission_denied",
  "8": "resource_exhausted",
  "9": "failed_precondition",
  "10": "aborted",
  "11": "out_of_range",
  "12": "unimplemented",
  "13": "internal_error",
  "14": "unavailable",
  "15": "data_loss",
  "16": "unauthenticated"
};
var isStatusErrorMessageValid = (message) => {
  return Object.values(canonicalGrpcErrorCodesMap).includes(message);
};
function mapStatus(span) {
  const attributes = spanHasAttributes(span) ? span.attributes : {};
  const status = spanHasStatus(span) ? span.status : void 0;
  if (status) {
    if (status.code === SpanStatusCode.OK) {
      return { code: SPAN_STATUS_OK };
    } else if (status.code === SpanStatusCode.ERROR) {
      if (typeof status.message === "undefined") {
        const inferredStatus2 = inferStatusFromAttributes(attributes);
        if (inferredStatus2) {
          return inferredStatus2;
        }
      }
      if (status.message && isStatusErrorMessageValid(status.message)) {
        return { code: SPAN_STATUS_ERROR, message: status.message };
      } else {
        return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
      }
    }
  }
  const inferredStatus = inferStatusFromAttributes(attributes);
  if (inferredStatus) {
    return inferredStatus;
  }
  if (status?.code === SpanStatusCode.UNSET) {
    return { code: SPAN_STATUS_OK };
  } else {
    return { code: SPAN_STATUS_ERROR, message: "unknown_error" };
  }
}
function inferStatusFromAttributes(attributes) {
  const httpCodeAttribute = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE3] || attributes[SEMATTRS_HTTP_STATUS_CODE3];
  const grpcCodeAttribute = attributes[SEMATTRS_RPC_GRPC_STATUS_CODE3];
  const numberHttpCode = typeof httpCodeAttribute === "number" ? httpCodeAttribute : typeof httpCodeAttribute === "string" ? parseInt(httpCodeAttribute) : void 0;
  if (typeof numberHttpCode === "number") {
    return getSpanStatusFromHttpCode(numberHttpCode);
  }
  if (typeof grpcCodeAttribute === "string") {
    return { code: SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || "unknown_error" };
  }
  return void 0;
}
var MAX_SPAN_COUNT2 = 1e3;
var DEFAULT_TIMEOUT = 300;
var SentrySpanExporter = class {
  /*
   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is
   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that
   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't
   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply
   * store the spans in an array and each time a new span comes in we could iterate through the entire array and
   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because
   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large
   * bursts of computation.
   *
   * Instead we go for a bucketing approach and put spans into buckets, based on what second
   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can
   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more
   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the
   * bucket array, and letting garbage collection take care of the rest.
   */
  constructor(options) {
    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;
    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(void 0);
    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1e3);
    this._spansToBucketEntry = /* @__PURE__ */ new WeakMap();
  }
  /** Export a single span. */
  export(span) {
    const currentTimestampInS = Math.floor(Date.now() / 1e3);
    if (this._lastCleanupTimestampInS !== currentTimestampInS) {
      let droppedSpanCount = 0;
      this._finishedSpanBuckets.forEach((bucket, i) => {
        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {
          droppedSpanCount += bucket.spans.size;
          this._finishedSpanBuckets[i] = void 0;
        }
      });
      if (droppedSpanCount > 0) {
        DEBUG_BUILD4 && logger.log(
          `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`
        );
      }
      this._lastCleanupTimestampInS = currentTimestampInS;
    }
    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;
    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {
      timestampInS: currentTimestampInS,
      spans: /* @__PURE__ */ new Set()
    };
    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;
    currentBucket.spans.add(span);
    this._spansToBucketEntry.set(span, currentBucket);
    if (!getLocalParentId(span)) {
      this._clearTimeout();
      this._flushTimeout = setTimeout(() => {
        this.flush();
      }, 1);
    }
  }
  /** Try to flush any pending spans immediately. */
  flush() {
    this._clearTimeout();
    const finishedSpans = [];
    this._finishedSpanBuckets.forEach((bucket) => {
      if (bucket) {
        finishedSpans.push(...bucket.spans);
      }
    });
    const sentSpans = maybeSend(finishedSpans);
    const sentSpanCount = sentSpans.size;
    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;
    DEBUG_BUILD4 && logger.log(
      `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`
    );
    sentSpans.forEach((span) => {
      const bucketEntry = this._spansToBucketEntry.get(span);
      if (bucketEntry) {
        bucketEntry.spans.delete(span);
      }
    });
  }
  /** Clear the exporter. */
  clear() {
    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(void 0);
    this._clearTimeout();
  }
  /** Clear the flush timeout. */
  _clearTimeout() {
    if (this._flushTimeout) {
      clearTimeout(this._flushTimeout);
      this._flushTimeout = void 0;
    }
  }
};
function maybeSend(spans) {
  const grouped = groupSpansWithParents(spans);
  const sentSpans = /* @__PURE__ */ new Set();
  const rootNodes = getCompletedRootNodes(grouped);
  rootNodes.forEach((root) => {
    const span = root.span;
    sentSpans.add(span);
    const transactionEvent = createTransactionForOtelSpan(span);
    const spans2 = transactionEvent.spans || [];
    root.children.forEach((child) => {
      createAndFinishSpanForOtelSpan(child, spans2, sentSpans);
    });
    transactionEvent.spans = spans2.length > MAX_SPAN_COUNT2 ? spans2.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT2) : spans2;
    const measurements = timedEventsToMeasurements(span.events);
    if (measurements) {
      transactionEvent.measurements = measurements;
    }
    captureEvent(transactionEvent);
  });
  return sentSpans;
}
function nodeIsCompletedRootNode(node2) {
  return !!node2.span && !node2.parentNode;
}
function getCompletedRootNodes(nodes) {
  return nodes.filter(nodeIsCompletedRootNode);
}
function parseSpan(span) {
  const attributes = span.attributes;
  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
  const op = attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  return { origin, op, source };
}
function createTransactionForOtelSpan(span) {
  const { op, description, data, origin = "manual", source } = getSpanData(span);
  const capturedSpanScopes = getCapturedScopesOnSpan(span);
  const sampleRate = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  const attributes = {
    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
    [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,
    ...data,
    ...removeSentryAttributes(span.attributes)
  };
  const { links } = span;
  const { traceId: trace_id, spanId: span_id } = span.spanContext();
  const parent_span_id = span.parentSpanId;
  const status = mapStatus(span);
  const traceContext = {
    parent_span_id,
    span_id,
    trace_id,
    data: attributes,
    origin,
    op,
    status: getStatusMessage(status),
    // As per protocol, span status is allowed to be undefined
    links: convertSpanLinksForEnvelope(links)
  };
  const statusCode = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE3];
  const responseContext = typeof statusCode === "number" ? { response: { status_code: statusCode } } : void 0;
  const transactionEvent = {
    contexts: {
      trace: traceContext,
      otel: {
        resource: span.resource.attributes
      },
      ...responseContext
    },
    spans: [],
    start_timestamp: spanTimeInputToSeconds(span.startTime),
    timestamp: spanTimeInputToSeconds(span.endTime),
    transaction: description,
    type: "transaction",
    sdkProcessingMetadata: {
      capturedSpanScope: capturedSpanScopes.scope,
      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,
      sampleRate,
      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span)
    },
    ...source && {
      transaction_info: {
        source
      }
    }
  };
  return transactionEvent;
}
function createAndFinishSpanForOtelSpan(node2, spans, sentSpans) {
  const span = node2.span;
  if (span) {
    sentSpans.add(span);
  }
  const shouldDrop = !span;
  if (shouldDrop) {
    node2.children.forEach((child) => {
      createAndFinishSpanForOtelSpan(child, spans, sentSpans);
    });
    return;
  }
  const span_id = span.spanContext().spanId;
  const trace_id = span.spanContext().traceId;
  const { attributes, startTime, endTime, parentSpanId, links } = span;
  const { op, description, data, origin = "manual" } = getSpanData(span);
  const allData = {
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,
    ...removeSentryAttributes(attributes),
    ...data
  };
  const status = mapStatus(span);
  const spanJSON = {
    span_id,
    trace_id,
    data: allData,
    description,
    parent_span_id: parentSpanId,
    start_timestamp: spanTimeInputToSeconds(startTime),
    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
    timestamp: spanTimeInputToSeconds(endTime) || void 0,
    status: getStatusMessage(status),
    // As per protocol, span status is allowed to be undefined
    op,
    origin,
    measurements: timedEventsToMeasurements(span.events),
    links: convertSpanLinksForEnvelope(links)
  };
  spans.push(spanJSON);
  node2.children.forEach((child) => {
    createAndFinishSpanForOtelSpan(child, spans, sentSpans);
  });
}
function getSpanData(span) {
  const { op: definedOp, source: definedSource, origin } = parseSpan(span);
  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);
  const op = definedOp || inferredOp;
  const source = definedSource || inferredSource;
  const data = { ...inferredData, ...getData(span) };
  return {
    op,
    description,
    source,
    origin,
    data
  };
}
function removeSentryAttributes(data) {
  const cleanedData = { ...data };
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];
  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
  return cleanedData;
}
function getData(span) {
  const attributes = span.attributes;
  const data = {};
  if (span.kind !== SpanKind.INTERNAL) {
    data["otel.kind"] = SpanKind[span.kind];
  }
  const maybeHttpStatusCodeAttribute = attributes[SEMATTRS_HTTP_STATUS_CODE3];
  if (maybeHttpStatusCodeAttribute) {
    data[ATTR_HTTP_RESPONSE_STATUS_CODE3] = maybeHttpStatusCodeAttribute;
  }
  const requestData = getRequestSpanData(span);
  if (requestData.url) {
    data.url = requestData.url;
  }
  if (requestData["http.query"]) {
    data["http.query"] = requestData["http.query"].slice(1);
  }
  if (requestData["http.fragment"]) {
    data["http.fragment"] = requestData["http.fragment"].slice(1);
  }
  return data;
}
function onSpanStart(span, parentContext) {
  const parentSpan = trace.getSpan(parentContext);
  let scopes = getScopesFromContext(parentContext);
  if (parentSpan && !parentSpan.spanContext().isRemote) {
    addChildSpanToSpan(parentSpan, span);
  }
  if (parentSpan?.spanContext().isRemote) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);
  }
  if (parentContext === ROOT_CONTEXT) {
    scopes = {
      scope: getDefaultCurrentScope(),
      isolationScope: getDefaultIsolationScope()
    };
  }
  if (scopes) {
    setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);
  }
  logSpanStart(span);
  const client = getClient();
  client?.emit("spanStart", span);
}
function onSpanEnd(span) {
  logSpanEnd(span);
  const client = getClient();
  client?.emit("spanEnd", span);
}
var SentrySpanProcessor = class {
  constructor(options) {
    setIsSetup("SentrySpanProcessor");
    this._exporter = new SentrySpanExporter(options);
  }
  /**
   * @inheritDoc
   */
  async forceFlush() {
    this._exporter.flush();
  }
  /**
   * @inheritDoc
   */
  async shutdown() {
    this._exporter.clear();
  }
  /**
   * @inheritDoc
   */
  onStart(span, parentContext) {
    onSpanStart(span, parentContext);
  }
  /** @inheritDoc */
  onEnd(span) {
    onSpanEnd(span);
    this._exporter.export(span);
  }
};
var SentrySampler = class {
  constructor(client) {
    this._client = client;
    setIsSetup("SentrySampler");
  }
  /** @inheritDoc */
  shouldSample(context3, traceId, spanName, spanKind, spanAttributes, _links) {
    const options = this._client.getOptions();
    const parentSpan = getValidSpan(context3);
    const parentContext = parentSpan?.spanContext();
    if (!hasSpansEnabled(options)) {
      return wrapSamplingDecision({ decision: void 0, context: context3, spanAttributes });
    }
    const maybeSpanHttpMethod = spanAttributes[SEMATTRS_HTTP_METHOD3] || spanAttributes[ATTR_HTTP_REQUEST_METHOD3];
    if (spanKind === SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {
      return wrapSamplingDecision({ decision: void 0, context: context3, spanAttributes });
    }
    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : void 0;
    const isRootSpan = !parentSpan || parentContext?.isRemote;
    if (!isRootSpan) {
      return wrapSamplingDecision({
        decision: parentSampled ? import_sdk_trace_base.SamplingDecision.RECORD_AND_SAMPLED : import_sdk_trace_base.SamplingDecision.NOT_RECORD,
        context: context3,
        spanAttributes
      });
    }
    const {
      description: inferredSpanName,
      data: inferredAttributes,
      op
    } = inferSpanData(spanName, spanAttributes, spanKind);
    const mergedAttributes = {
      ...inferredAttributes,
      ...spanAttributes
    };
    if (op) {
      mergedAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;
    }
    const mutableSamplingDecision = { decision: true };
    this._client.emit(
      "beforeSampling",
      {
        spanAttributes: mergedAttributes,
        spanName: inferredSpanName,
        parentSampled,
        parentContext
      },
      mutableSamplingDecision
    );
    if (!mutableSamplingDecision.decision) {
      return wrapSamplingDecision({ decision: void 0, context: context3, spanAttributes });
    }
    const { isolationScope } = getScopesFromContext(context3) ?? {};
    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : void 0;
    const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : void 0;
    const sampleRand = parseSampleRate(dsc?.sample_rand) ?? Math.random();
    const [sampled, sampleRate, localSampleRateWasApplied] = sampleSpan(
      options,
      {
        name: inferredSpanName,
        attributes: mergedAttributes,
        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,
        parentSampled,
        parentSampleRate: parseSampleRate(dsc?.sample_rate)
      },
      sampleRand
    );
    const method = `${maybeSpanHttpMethod}`.toUpperCase();
    if (method === "OPTIONS" || method === "HEAD") {
      DEBUG_BUILD4 && logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);
      return wrapSamplingDecision({
        decision: import_sdk_trace_base.SamplingDecision.NOT_RECORD,
        context: context3,
        spanAttributes,
        sampleRand,
        downstreamTraceSampleRate: 0
        // we don't want to sample anything in the downstream trace either
      });
    }
    if (!sampled && // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)
    parentSampled === void 0) {
      DEBUG_BUILD4 && logger.log("[Tracing] Discarding root span because its trace was not chosen to be sampled.");
      this._client.recordDroppedEvent("sample_rate", "transaction");
    }
    return {
      ...wrapSamplingDecision({
        decision: sampled ? import_sdk_trace_base.SamplingDecision.RECORD_AND_SAMPLED : import_sdk_trace_base.SamplingDecision.NOT_RECORD,
        context: context3,
        spanAttributes,
        sampleRand,
        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : void 0
      }),
      attributes: {
        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry
        [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : void 0
      }
    };
  }
  /** Returns the sampler name or short description with the configuration. */
  toString() {
    return "SentrySampler";
  }
};
function getParentSampled(parentSpan, traceId, spanName) {
  const parentContext = parentSpan.spanContext();
  if (isSpanContextValid(parentContext) && parentContext.traceId === traceId) {
    if (parentContext.isRemote) {
      const parentSampled2 = getSamplingDecision(parentSpan.spanContext());
      DEBUG_BUILD4 && logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled2}`);
      return parentSampled2;
    }
    const parentSampled = getSamplingDecision(parentContext);
    DEBUG_BUILD4 && logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);
    return parentSampled;
  }
  return void 0;
}
function wrapSamplingDecision({
  decision,
  context: context3,
  spanAttributes,
  sampleRand,
  downstreamTraceSampleRate
}) {
  let traceState = getBaseTraceState(context3, spanAttributes);
  if (downstreamTraceSampleRate !== void 0) {
    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);
  }
  if (sampleRand !== void 0) {
    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);
  }
  if (decision == void 0) {
    return { decision: import_sdk_trace_base.SamplingDecision.NOT_RECORD, traceState };
  }
  if (decision === import_sdk_trace_base.SamplingDecision.NOT_RECORD) {
    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") };
  }
  return { decision, traceState };
}
function getBaseTraceState(context3, spanAttributes) {
  const parentSpan = trace.getSpan(context3);
  const parentContext = parentSpan?.spanContext();
  let traceState = parentContext?.traceState || new import_core8.TraceState();
  const url2 = spanAttributes[SEMATTRS_HTTP_URL3] || spanAttributes[ATTR_URL_FULL3];
  if (url2 && typeof url2 === "string") {
    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url2);
  }
  return traceState;
}
function getValidSpan(context3) {
  const span = trace.getSpan(context3);
  return span && isSpanContextValid(span.spanContext()) ? span : void 0;
}

// node_modules/@sentry/node/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
var diagch = __toESM(require("diagnostics_channel"), 1);

// node_modules/@sentry/node/build/esm/nodeVersion.js
var NODE_VERSION = parseSemver(process.versions.node);
var NODE_MAJOR = NODE_VERSION.major;
var NODE_MINOR = NODE_VERSION.minor;

// node_modules/@sentry/node/build/esm/utils/baggage.js
function mergeBaggageHeaders(existing, baggage) {
  if (!existing) {
    return baggage;
  }
  const existingBaggageEntries = parseBaggageHeader(existing);
  const newBaggageEntries = parseBaggageHeader(baggage);
  if (!newBaggageEntries) {
    return existing;
  }
  const mergedBaggageEntries = { ...existingBaggageEntries };
  Object.entries(newBaggageEntries).forEach(([key, value]) => {
    if (!mergedBaggageEntries[key]) {
      mergedBaggageEntries[key] = value;
    }
  });
  return objectToBaggageHeader(mergedBaggageEntries);
}

// node_modules/@sentry/node/build/esm/integrations/node-fetch/SentryNodeFetchInstrumentation.js
var SENTRY_TRACE_HEADER2 = "sentry-trace";
var SENTRY_BAGGAGE_HEADER2 = "baggage";
var BAGGAGE_HEADER_REGEX = /baggage: (.*)\r\n/;
var SentryNodeFetchInstrumentation = class extends import_instrumentation4.InstrumentationBase {
  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for
  // unsubscribing.
  constructor(config2 = {}) {
    super("@sentry/instrumentation-node-fetch", import_core11.VERSION, config2);
    this._channelSubs = [];
    this._propagationDecisionMap = new LRUMap(100);
  }
  /** No need to instrument files/modules. */
  init() {
    return void 0;
  }
  /** Disable the instrumentation. */
  disable() {
    super.disable();
    this._channelSubs.forEach((sub) => sub.unsubscribe());
    this._channelSubs = [];
  }
  /** Enable the instrumentation. */
  enable() {
    super.enable();
    this._channelSubs = this._channelSubs || [];
    if (this._channelSubs.length > 0) {
      return;
    }
    this._subscribeToChannel("undici:request:create", this._onRequestCreated.bind(this));
    this._subscribeToChannel("undici:request:headers", this._onResponseHeaders.bind(this));
  }
  /**
   * This method is called when a request is created.
   * You can still mutate the request here before it is sent.
   */
  _onRequestCreated({ request }) {
    const config2 = this.getConfig();
    const enabled = config2.enabled !== false;
    if (!enabled) {
      return;
    }
    const url2 = getAbsoluteUrl2(request.origin, request.path);
    const _ignoreOutgoingRequests = config2.ignoreOutgoingRequests;
    const shouldIgnore = _ignoreOutgoingRequests && url2 && _ignoreOutgoingRequests(url2);
    if (shouldIgnore) {
      return;
    }
    const tracePropagationTargets = getClient()?.getOptions().tracePropagationTargets;
    const addedHeaders = shouldPropagateTraceForUrl(url2, tracePropagationTargets, this._propagationDecisionMap) ? getTraceData() : void 0;
    if (!addedHeaders) {
      return;
    }
    const { "sentry-trace": sentryTrace, baggage } = addedHeaders;
    if (Array.isArray(request.headers)) {
      const requestHeaders = request.headers;
      if (sentryTrace && !requestHeaders.includes(SENTRY_TRACE_HEADER2)) {
        requestHeaders.push(SENTRY_TRACE_HEADER2, sentryTrace);
      }
      const existingBaggagePos = requestHeaders.findIndex((header) => header === SENTRY_BAGGAGE_HEADER2);
      if (baggage && existingBaggagePos === -1) {
        requestHeaders.push(SENTRY_BAGGAGE_HEADER2, baggage);
      } else if (baggage) {
        const existingBaggage = requestHeaders[existingBaggagePos + 1];
        const merged = mergeBaggageHeaders(existingBaggage, baggage);
        if (merged) {
          requestHeaders[existingBaggagePos + 1] = merged;
        }
      }
    } else {
      const requestHeaders = request.headers;
      if (sentryTrace && !requestHeaders.includes(`${SENTRY_TRACE_HEADER2}:`)) {
        request.headers += `${SENTRY_TRACE_HEADER2}: ${sentryTrace}\r
`;
      }
      const existingBaggage = request.headers.match(BAGGAGE_HEADER_REGEX)?.[1];
      if (baggage && !existingBaggage) {
        request.headers += `${SENTRY_BAGGAGE_HEADER2}: ${baggage}\r
`;
      } else if (baggage) {
        const merged = mergeBaggageHeaders(existingBaggage, baggage);
        if (merged) {
          request.headers = request.headers.replace(BAGGAGE_HEADER_REGEX, `baggage: ${merged}\r
`);
        }
      }
    }
  }
  /**
   * This method is called when a response is received.
   */
  _onResponseHeaders({ request, response }) {
    const config2 = this.getConfig();
    const enabled = config2.enabled !== false;
    if (!enabled) {
      return;
    }
    const _breadcrumbs = config2.breadcrumbs;
    const breadCrumbsEnabled = typeof _breadcrumbs === "undefined" ? true : _breadcrumbs;
    const _ignoreOutgoingRequests = config2.ignoreOutgoingRequests;
    const shouldCreateBreadcrumb = typeof _ignoreOutgoingRequests === "function" ? !_ignoreOutgoingRequests(getAbsoluteUrl2(request.origin, request.path)) : true;
    if (breadCrumbsEnabled && shouldCreateBreadcrumb) {
      addRequestBreadcrumb2(request, response);
    }
  }
  /** Subscribe to a diagnostics channel. */
  _subscribeToChannel(diagnosticChannel, onMessage) {
    const useNewSubscribe = NODE_MAJOR > 18 || NODE_MAJOR === 18 && NODE_MINOR >= 19;
    let unsubscribe2;
    if (useNewSubscribe) {
      diagch.subscribe?.(diagnosticChannel, onMessage);
      unsubscribe2 = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);
    } else {
      const channel3 = diagch.channel(diagnosticChannel);
      channel3.subscribe(onMessage);
      unsubscribe2 = () => channel3.unsubscribe(onMessage);
    }
    this._channelSubs.push({
      name: diagnosticChannel,
      unsubscribe: unsubscribe2
    });
  }
};
function addRequestBreadcrumb2(request, response) {
  const data = getBreadcrumbData2(request);
  const statusCode = response.statusCode;
  const level = getBreadcrumbLogLevelFromHttpStatusCode(statusCode);
  addBreadcrumb(
    {
      category: "http",
      data: {
        status_code: statusCode,
        ...data
      },
      type: "http",
      level
    },
    {
      event: "response",
      request,
      response
    }
  );
}
function getBreadcrumbData2(request) {
  try {
    const url2 = getAbsoluteUrl2(request.origin, request.path);
    const parsedUrl = parseUrl(url2);
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch {
    return {};
  }
}
function getAbsoluteUrl2(origin, path = "/") {
  try {
    const url2 = new URL(path, origin);
    return url2.toString();
  } catch {
    const url2 = `${origin}`;
    if (url2.endsWith("/") && path.startsWith("/")) {
      return `${url2}${path.slice(1)}`;
    }
    if (!url2.endsWith("/") && !path.startsWith("/")) {
      return `${url2}/${path.slice(1)}`;
    }
    return `${url2}${path}`;
  }
}

// node_modules/@sentry/node/build/esm/integrations/node-fetch/index.js
var INTEGRATION_NAME6 = "NodeFetch";
var instrumentOtelNodeFetch = generateInstrumentOnce(INTEGRATION_NAME6, (config2) => {
  return new import_instrumentation_undici.UndiciInstrumentation(config2);
});
var instrumentSentryNodeFetch = generateInstrumentOnce(
  `${INTEGRATION_NAME6}.sentry`,
  (config2) => {
    return new SentryNodeFetchInstrumentation(config2);
  }
);
var _nativeNodeFetchIntegration = (options = {}) => {
  return {
    name: "NodeFetch",
    setupOnce() {
      const instrumentSpans = _shouldInstrumentSpans2(options, getClient()?.getOptions());
      if (instrumentSpans) {
        const instrumentationConfig = getConfigWithDefaults2(options);
        instrumentOtelNodeFetch(instrumentationConfig);
      }
      instrumentSentryNodeFetch(options);
    }
  };
};
var nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);
function getAbsoluteUrl3(origin, path = "/") {
  const url2 = `${origin}`;
  if (url2.endsWith("/") && path.startsWith("/")) {
    return `${url2}${path.slice(1)}`;
  }
  if (!url2.endsWith("/") && !path.startsWith("/")) {
    return `${url2}/${path.slice(1)}`;
  }
  return `${url2}${path}`;
}
function _shouldInstrumentSpans2(options, clientOptions = {}) {
  return typeof options.spans === "boolean" ? options.spans : !clientOptions.skipOpenTelemetrySetup;
}
function getConfigWithDefaults2(options = {}) {
  const instrumentationConfig = {
    requireParentforSpans: false,
    ignoreRequestHook: (request) => {
      const url2 = getAbsoluteUrl3(request.origin, request.path);
      const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
      const shouldIgnore = _ignoreOutgoingRequests && url2 && _ignoreOutgoingRequests(url2);
      return !!shouldIgnore;
    },
    startSpanHook: () => {
      return {
        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.node_fetch"
      };
    }
  };
  return instrumentationConfig;
}

// node_modules/@sentry/node/build/esm/integrations/console.js
var util = __toESM(require("node:util"), 1);
var INTEGRATION_NAME7 = "Console";
var consoleIntegration = defineIntegration(() => {
  return {
    name: INTEGRATION_NAME7,
    setup(client) {
      addConsoleInstrumentationHandler(({ args, level }) => {
        if (getClient() !== client) {
          return;
        }
        addBreadcrumb(
          {
            category: "console",
            level: severityLevelFromString(level),
            message: util.format.apply(void 0, args)
          },
          {
            input: [...args],
            level
          }
        );
      });
    }
  };
});

// node_modules/@sentry/node/build/esm/integrations/context.js
var import_node_child_process = require("node:child_process");
var import_node_fs = require("node:fs");
var os = __toESM(require("node:os"), 1);
var import_node_path = require("node:path");
var import_node_util = require("node:util");
var readFileAsync = (0, import_node_util.promisify)(import_node_fs.readFile);
var readDirAsync = (0, import_node_util.promisify)(import_node_fs.readdir);
var INTEGRATION_NAME8 = "Context";
var _nodeContextIntegration = (options = {}) => {
  let cachedContext;
  const _options = {
    app: true,
    os: true,
    device: true,
    culture: true,
    cloudResource: true,
    ...options
  };
  async function addContext(event) {
    if (cachedContext === void 0) {
      cachedContext = _getContexts();
    }
    const updatedContext = _updateContext(await cachedContext);
    event.contexts = {
      ...event.contexts,
      app: { ...updatedContext.app, ...event.contexts?.app },
      os: { ...updatedContext.os, ...event.contexts?.os },
      device: { ...updatedContext.device, ...event.contexts?.device },
      culture: { ...updatedContext.culture, ...event.contexts?.culture },
      cloud_resource: { ...updatedContext.cloud_resource, ...event.contexts?.cloud_resource }
    };
    return event;
  }
  async function _getContexts() {
    const contexts = {};
    if (_options.os) {
      contexts.os = await getOsContext();
    }
    if (_options.app) {
      contexts.app = getAppContext();
    }
    if (_options.device) {
      contexts.device = getDeviceContext(_options.device);
    }
    if (_options.culture) {
      const culture = getCultureContext();
      if (culture) {
        contexts.culture = culture;
      }
    }
    if (_options.cloudResource) {
      contexts.cloud_resource = getCloudResourceContext();
    }
    return contexts;
  }
  return {
    name: INTEGRATION_NAME8,
    processEvent(event) {
      return addContext(event);
    }
  };
};
var nodeContextIntegration = defineIntegration(_nodeContextIntegration);
function _updateContext(contexts) {
  if (contexts.app?.app_memory) {
    contexts.app.app_memory = process.memoryUsage().rss;
  }
  if (contexts.app?.free_memory && typeof process.availableMemory === "function") {
    const freeMemory = process.availableMemory?.();
    if (freeMemory != null) {
      contexts.app.free_memory = freeMemory;
    }
  }
  if (contexts.device?.free_memory) {
    contexts.device.free_memory = os.freemem();
  }
  return contexts;
}
async function getOsContext() {
  const platformId = os.platform();
  switch (platformId) {
    case "darwin":
      return getDarwinInfo();
    case "linux":
      return getLinuxInfo();
    default:
      return {
        name: PLATFORM_NAMES[platformId] || platformId,
        version: os.release()
      };
  }
}
function getCultureContext() {
  try {
    if (typeof process.versions.icu !== "string") {
      return;
    }
    const january = /* @__PURE__ */ new Date(9e8);
    const spanish = new Intl.DateTimeFormat("es", { month: "long" });
    if (spanish.format(january) === "enero") {
      const options = Intl.DateTimeFormat().resolvedOptions();
      return {
        locale: options.locale,
        timezone: options.timeZone
      };
    }
  } catch (err) {
  }
  return;
}
function getAppContext() {
  const app_memory = process.memoryUsage().rss;
  const app_start_time = new Date(Date.now() - process.uptime() * 1e3).toISOString();
  const appContext = { app_start_time, app_memory };
  if (typeof process.availableMemory === "function") {
    const freeMemory = process.availableMemory?.();
    if (freeMemory != null) {
      appContext.free_memory = freeMemory;
    }
  }
  return appContext;
}
function getDeviceContext(deviceOpt) {
  const device = {};
  let uptime2;
  try {
    uptime2 = os.uptime();
  } catch (e) {
  }
  if (typeof uptime2 === "number") {
    device.boot_time = new Date(Date.now() - uptime2 * 1e3).toISOString();
  }
  device.arch = os.arch();
  if (deviceOpt === true || deviceOpt.memory) {
    device.memory_size = os.totalmem();
    device.free_memory = os.freemem();
  }
  if (deviceOpt === true || deviceOpt.cpu) {
    const cpuInfo = os.cpus();
    const firstCpu = cpuInfo?.[0];
    if (firstCpu) {
      device.processor_count = cpuInfo.length;
      device.cpu_description = firstCpu.model;
      device.processor_frequency = firstCpu.speed;
    }
  }
  return device;
}
var PLATFORM_NAMES = {
  aix: "IBM AIX",
  freebsd: "FreeBSD",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
var LINUX_DISTROS = [
  { name: "fedora-release", distros: ["Fedora"] },
  { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
  { name: "redhat_version", distros: ["Red Hat Linux"] },
  { name: "SuSE-release", distros: ["SUSE Linux"] },
  { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
  { name: "debian_version", distros: ["Debian"] },
  { name: "debian_release", distros: ["Debian"] },
  { name: "arch-release", distros: ["Arch Linux"] },
  { name: "gentoo-release", distros: ["Gentoo Linux"] },
  { name: "novell-release", distros: ["SUSE Linux"] },
  { name: "alpine-release", distros: ["Alpine Linux"] }
];
var LINUX_VERSIONS = {
  alpine: (content) => content,
  arch: (content) => matchFirst(/distrib_release=(.*)/, content),
  centos: (content) => matchFirst(/release ([^ ]+)/, content),
  debian: (content) => content,
  fedora: (content) => matchFirst(/release (..)/, content),
  mint: (content) => matchFirst(/distrib_release=(.*)/, content),
  red: (content) => matchFirst(/release ([^ ]+)/, content),
  suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
  ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
};
function matchFirst(regex, text) {
  const match = regex.exec(text);
  return match ? match[1] : void 0;
}
async function getDarwinInfo() {
  const darwinInfo = {
    kernel_version: os.release(),
    name: "Mac OS X",
    version: `10.${Number(os.release().split(".")[0]) - 4}`
  };
  try {
    const output = await new Promise((resolve2, reject) => {
      (0, import_node_child_process.execFile)("/usr/bin/sw_vers", (error, stdout) => {
        if (error) {
          reject(error);
          return;
        }
        resolve2(stdout);
      });
    });
    darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
    darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
    darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
  } catch (e) {
  }
  return darwinInfo;
}
function getLinuxDistroId(name) {
  return name.split(" ")[0].toLowerCase();
}
async function getLinuxInfo() {
  const linuxInfo = {
    kernel_version: os.release(),
    name: "Linux"
  };
  try {
    const etcFiles = await readDirAsync("/etc");
    const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
    if (!distroFile) {
      return linuxInfo;
    }
    const distroPath = (0, import_node_path.join)("/etc", distroFile.name);
    const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
    const { distros } = distroFile;
    linuxInfo.name = distros.find((d) => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];
    const id = getLinuxDistroId(linuxInfo.name);
    linuxInfo.version = LINUX_VERSIONS[id]?.(contents);
  } catch (e) {
  }
  return linuxInfo;
}
function getCloudResourceContext() {
  if (process.env.VERCEL) {
    return {
      "cloud.provider": "vercel",
      "cloud.region": process.env.VERCEL_REGION
    };
  } else if (process.env.AWS_REGION) {
    return {
      "cloud.provider": "aws",
      "cloud.region": process.env.AWS_REGION,
      "cloud.platform": process.env.AWS_EXECUTION_ENV
    };
  } else if (process.env.GCP_PROJECT) {
    return {
      "cloud.provider": "gcp"
    };
  } else if (process.env.ALIYUN_REGION_ID) {
    return {
      "cloud.provider": "alibaba_cloud",
      "cloud.region": process.env.ALIYUN_REGION_ID
    };
  } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
    return {
      "cloud.provider": "azure",
      "cloud.region": process.env.REGION_NAME
    };
  } else if (process.env.IBM_CLOUD_REGION) {
    return {
      "cloud.provider": "ibm_cloud",
      "cloud.region": process.env.IBM_CLOUD_REGION
    };
  } else if (process.env.TENCENTCLOUD_REGION) {
    return {
      "cloud.provider": "tencent_cloud",
      "cloud.region": process.env.TENCENTCLOUD_REGION,
      "cloud.account.id": process.env.TENCENTCLOUD_APPID,
      "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE
    };
  } else if (process.env.NETLIFY) {
    return {
      "cloud.provider": "netlify"
    };
  } else if (process.env.FLY_REGION) {
    return {
      "cloud.provider": "fly.io",
      "cloud.region": process.env.FLY_REGION
    };
  } else if (process.env.DYNO) {
    return {
      "cloud.provider": "heroku"
    };
  } else {
    return void 0;
  }
}

// node_modules/@sentry/node/build/esm/integrations/contextlines.js
var import_node_fs2 = require("node:fs");
var import_node_readline = require("node:readline");
var LRU_FILE_CONTENTS_CACHE = new LRUMap(10);
var LRU_FILE_CONTENTS_FS_READ_FAILED = new LRUMap(20);
var DEFAULT_LINES_OF_CONTEXT = 7;
var INTEGRATION_NAME9 = "ContextLines";
var MAX_CONTEXTLINES_COLNO = 1e3;
var MAX_CONTEXTLINES_LINENO = 1e4;
function emplace(map, key, contents) {
  const value = map.get(key);
  if (value === void 0) {
    map.set(key, contents);
    return contents;
  }
  return value;
}
function shouldSkipContextLinesForFile(path) {
  if (path.startsWith("node:")) return true;
  if (path.endsWith(".min.js")) return true;
  if (path.endsWith(".min.cjs")) return true;
  if (path.endsWith(".min.mjs")) return true;
  if (path.startsWith("data:")) return true;
  return false;
}
function shouldSkipContextLinesForFrame(frame) {
  if (frame.lineno !== void 0 && frame.lineno > MAX_CONTEXTLINES_LINENO) return true;
  if (frame.colno !== void 0 && frame.colno > MAX_CONTEXTLINES_COLNO) return true;
  return false;
}
function rangeExistsInContentCache(file, range) {
  const contents = LRU_FILE_CONTENTS_CACHE.get(file);
  if (contents === void 0) return false;
  for (let i = range[0]; i <= range[1]; i++) {
    if (contents[i] === void 0) {
      return false;
    }
  }
  return true;
}
function makeLineReaderRanges(lines, linecontext) {
  if (!lines.length) {
    return [];
  }
  let i = 0;
  const line = lines[0];
  if (typeof line !== "number") {
    return [];
  }
  let current = makeContextRange(line, linecontext);
  const out = [];
  while (true) {
    if (i === lines.length - 1) {
      out.push(current);
      break;
    }
    const next = lines[i + 1];
    if (typeof next !== "number") {
      break;
    }
    if (next <= current[1]) {
      current[1] = next + linecontext;
    } else {
      out.push(current);
      current = makeContextRange(next, linecontext);
    }
    i++;
  }
  return out;
}
function getContextLinesFromFile(path, ranges, output) {
  return new Promise((resolve2, _reject) => {
    const stream = (0, import_node_fs2.createReadStream)(path);
    const lineReaded = (0, import_node_readline.createInterface)({
      input: stream
    });
    function destroyStreamAndResolve() {
      stream.destroy();
      resolve2();
    }
    let lineNumber = 0;
    let currentRangeIndex = 0;
    const range = ranges[currentRangeIndex];
    if (range === void 0) {
      destroyStreamAndResolve();
      return;
    }
    let rangeStart = range[0];
    let rangeEnd = range[1];
    function onStreamError(e) {
      LRU_FILE_CONTENTS_FS_READ_FAILED.set(path, 1);
      DEBUG_BUILD3 && logger.error(`Failed to read file: ${path}. Error: ${e}`);
      lineReaded.close();
      lineReaded.removeAllListeners();
      destroyStreamAndResolve();
    }
    stream.on("error", onStreamError);
    lineReaded.on("error", onStreamError);
    lineReaded.on("close", destroyStreamAndResolve);
    lineReaded.on("line", (line) => {
      lineNumber++;
      if (lineNumber < rangeStart) return;
      output[lineNumber] = snipLine(line, 0);
      if (lineNumber >= rangeEnd) {
        if (currentRangeIndex === ranges.length - 1) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        currentRangeIndex++;
        const range2 = ranges[currentRangeIndex];
        if (range2 === void 0) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        rangeStart = range2[0];
        rangeEnd = range2[1];
      }
    });
  });
}
async function addSourceContext(event, contextLines) {
  const filesToLines = {};
  if (contextLines > 0 && event.exception?.values) {
    for (const exception of event.exception.values) {
      if (!exception.stacktrace?.frames?.length) {
        continue;
      }
      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        const filename = frame?.filename;
        if (!frame || typeof filename !== "string" || typeof frame.lineno !== "number" || shouldSkipContextLinesForFile(filename) || shouldSkipContextLinesForFrame(frame)) {
          continue;
        }
        const filesToLinesOutput = filesToLines[filename];
        if (!filesToLinesOutput) filesToLines[filename] = [];
        filesToLines[filename].push(frame.lineno);
      }
    }
  }
  const files = Object.keys(filesToLines);
  if (files.length == 0) {
    return event;
  }
  const readlinePromises = [];
  for (const file of files) {
    if (LRU_FILE_CONTENTS_FS_READ_FAILED.get(file)) {
      continue;
    }
    const filesToLineRanges = filesToLines[file];
    if (!filesToLineRanges) {
      continue;
    }
    filesToLineRanges.sort((a, b) => a - b);
    const ranges = makeLineReaderRanges(filesToLineRanges, contextLines);
    if (ranges.every((r) => rangeExistsInContentCache(file, r))) {
      continue;
    }
    const cache = emplace(LRU_FILE_CONTENTS_CACHE, file, {});
    readlinePromises.push(getContextLinesFromFile(file, ranges, cache));
  }
  await Promise.all(readlinePromises).catch(() => {
    DEBUG_BUILD3 && logger.log("Failed to read one or more source files and resolve context lines");
  });
  if (contextLines > 0 && event.exception?.values) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace?.frames && exception.stacktrace.frames.length > 0) {
        addSourceContextToFrames(exception.stacktrace.frames, contextLines, LRU_FILE_CONTENTS_CACHE);
      }
    }
  }
  return event;
}
function addSourceContextToFrames(frames, contextLines, cache) {
  for (const frame of frames) {
    if (frame.filename && frame.context_line === void 0 && typeof frame.lineno === "number") {
      const contents = cache.get(frame.filename);
      if (contents === void 0) {
        continue;
      }
      addContextToFrame2(frame.lineno, frame, contextLines, contents);
    }
  }
}
function clearLineContext(frame) {
  delete frame.pre_context;
  delete frame.context_line;
  delete frame.post_context;
}
function addContextToFrame2(lineno, frame, contextLines, contents) {
  if (frame.lineno === void 0 || contents === void 0) {
    DEBUG_BUILD3 && logger.error("Cannot resolve context for frame with no lineno or file contents");
    return;
  }
  frame.pre_context = [];
  for (let i = makeRangeStart(lineno, contextLines); i < lineno; i++) {
    const line = contents[i];
    if (line === void 0) {
      clearLineContext(frame);
      DEBUG_BUILD3 && logger.error(`Could not find line ${i} in file ${frame.filename}`);
      return;
    }
    frame.pre_context.push(line);
  }
  if (contents[lineno] === void 0) {
    clearLineContext(frame);
    DEBUG_BUILD3 && logger.error(`Could not find line ${lineno} in file ${frame.filename}`);
    return;
  }
  frame.context_line = contents[lineno];
  const end = makeRangeEnd(lineno, contextLines);
  frame.post_context = [];
  for (let i = lineno + 1; i <= end; i++) {
    const line = contents[i];
    if (line === void 0) {
      break;
    }
    frame.post_context.push(line);
  }
}
function makeRangeStart(line, linecontext) {
  return Math.max(1, line - linecontext);
}
function makeRangeEnd(line, linecontext) {
  return line + linecontext;
}
function makeContextRange(line, linecontext) {
  return [makeRangeStart(line, linecontext), makeRangeEnd(line, linecontext)];
}
var _contextLinesIntegration = (options = {}) => {
  const contextLines = options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  return {
    name: INTEGRATION_NAME9,
    processEvent(event) {
      return addSourceContext(event, contextLines);
    }
  };
};
var contextLinesIntegration = defineIntegration(_contextLinesIntegration);

// node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-async.js
var import_node_worker_threads = require("node:worker_threads");

// node_modules/@sentry/node/build/esm/utils/debug.js
var cachedDebuggerEnabled;
async function isDebuggerEnabled() {
  if (cachedDebuggerEnabled === void 0) {
    try {
      const inspector = await import("node:inspector");
      cachedDebuggerEnabled = !!inspector.url();
    } catch (_) {
      cachedDebuggerEnabled = false;
    }
  }
  return cachedDebuggerEnabled;
}

// node_modules/@sentry/node/build/esm/integrations/local-variables/common.js
var LOCAL_VARIABLES_KEY = "__SENTRY_ERROR_LOCAL_VARIABLES__";
function createRateLimiter(maxPerSecond, enable, disable) {
  let count = 0;
  let retrySeconds = 5;
  let disabledTimeout = 0;
  setInterval(() => {
    if (disabledTimeout === 0) {
      if (count > maxPerSecond) {
        retrySeconds *= 2;
        disable(retrySeconds);
        if (retrySeconds > 86400) {
          retrySeconds = 86400;
        }
        disabledTimeout = retrySeconds;
      }
    } else {
      disabledTimeout -= 1;
      if (disabledTimeout === 0) {
        enable();
      }
    }
    count = 0;
  }, 1e3).unref();
  return () => {
    count += 1;
  };
}
function isAnonymous(name) {
  return name !== void 0 && (name.length === 0 || name === "?" || name === "<anonymous>");
}
function functionNamesMatch(a, b) {
  return a === b || isAnonymous(a) && isAnonymous(b);
}

// node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-async.js
var base64WorkerScript = "LyohIEBzZW50cnkvbm9kZSA5LjEyLjAgKDRlYjc4ZTUpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsbz0idW5kZWZpbmVkIj09dHlwZW9mIF9fU0VOVFJZX0RFQlVHX198fF9fU0VOVFJZX0RFQlVHX18saT0iOS4xMi4wIjtjb25zdCBhPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxzPXt9O2Z1bmN0aW9uIGMoZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30saT1PYmplY3Qua2V5cyhzKTtpLmZvckVhY2goKGU9Pntjb25zdCBuPXNbZV07b1tlXT10W2VdLHRbZV09bn0pKTt0cnl7cmV0dXJuIGUoKX1maW5hbGx5e2kuZm9yRWFjaCgoZT0+e3RbZV09b1tlXX0pKX19IWZ1bmN0aW9uKGUsdCxvPW4pe2NvbnN0IGE9by5fX1NFTlRSWV9fPW8uX19TRU5UUllfX3x8e30scz1hW2ldPWFbaV18fHt9O3NbZV18fChzW2VdPXQoKSl9KCJsb2dnZXIiLChmdW5jdGlvbigpe2xldCBlPSExO2NvbnN0IHQ9e2VuYWJsZTooKT0+e2U9ITB9LGRpc2FibGU6KCk9PntlPSExfSxpc0VuYWJsZWQ6KCk9PmV9O3JldHVybiBvP2EuZm9yRWFjaCgobz0+e3Rbb109KC4uLnQpPT57ZSYmYygoKCk9PntuLmNvbnNvbGVbb10oYFNlbnRyeSBMb2dnZXIgWyR7b31dOmAsLi4udCl9KSl9fSkpOmEuZm9yRWFjaCgoZT0+e3RbZV09KCk9Pnt9fSkpLHR9KSk7Y29uc3Qgcj0iX19TRU5UUllfRVJST1JfTE9DQUxfVkFSSUFCTEVTX18iO2NvbnN0IHU9dDtmdW5jdGlvbiBsKC4uLmUpe3UuZGVidWcmJmMoKCgpPT5jb25zb2xlLmxvZygiW0xvY2FsVmFyaWFibGVzIFdvcmtlcl0iLC4uLmUpKSl9YXN5bmMgZnVuY3Rpb24gZihlLHQsbixvKXtjb25zdCBpPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6dCxvd25Qcm9wZXJ0aWVzOiEwfSk7b1tuXT1pLnJlc3VsdC5maWx0ZXIoKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpKS5zb3J0KCgoZSx0KT0+cGFyc2VJbnQoZS5uYW1lLDEwKS1wYXJzZUludCh0Lm5hbWUsMTApKSkubWFwKChlPT5lLnZhbHVlPy52YWx1ZSkpfWFzeW5jIGZ1bmN0aW9uIGcoZSx0LG4sbyl7Y29uc3QgaT1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO29bbl09aS5yZXN1bHQubWFwKChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkpLnJlZHVjZSgoKGUsW3Qsbl0pPT4oZVt0XT1uLGUpKSx7fSl9ZnVuY3Rpb24gZChlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBiKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLG89e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGYoZSxuLHQubmFtZSxvKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgZyhlLG4sdC5uYW1lLG8pfWVsc2UgdC52YWx1ZSYmZCh0LG8pO3JldHVybiBvfWxldCBwOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCksbCgiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCgpPT57bj0hMX0pKSx0Lm9uKCJEZWJ1Z2dlci5wYXVzZWQiLChlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOm99KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKHA/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGk9W107Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6YSx0aGlzOnN9PW9bdF0sYz1uLmZpbmQoKGU9PiJsb2NhbCI9PT1lLnR5cGUpKSxyPSJnbG9iYWwiIT09cy5jbGFzc05hbWUmJnMuY2xhc3NOYW1lP2Ake3MuY2xhc3NOYW1lfS4ke2F9YDphO2lmKHZvaWQgMD09PWM/Lm9iamVjdC5vYmplY3RJZClpW3RdPXtmdW5jdGlvbjpyfTtlbHNle2NvbnN0IG49YXdhaXQgYihlLGMub2JqZWN0Lm9iamVjdElkKTtpW3RdPXtmdW5jdGlvbjpyLHZhcnM6bn19fWF3YWl0IGUucG9zdCgiUnVudGltZS5jYWxsRnVuY3Rpb25PbiIse2Z1bmN0aW9uRGVjbGFyYXRpb246YGZ1bmN0aW9uKCkgeyB0aGlzLiR7cn0gPSB0aGlzLiR7cn0gfHwgJHtKU09OLnN0cmluZ2lmeShpKX07IH1gLHNpbGVudDohMCxvYmplY3RJZDpufSksYXdhaXQgZS5wb3N0KCJSdW50aW1lLnJlbGVhc2VPYmplY3QiLHtvYmplY3RJZDpufSl9KHQsZS5wYXJhbXMpLnRoZW4oKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSksKGFzeW5jIGU9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSkpfSkpLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuZW5hYmxlIik7Y29uc3Qgbz0hMSE9PXUuY2FwdHVyZUFsbEV4Y2VwdGlvbnM7aWYoYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOm8/ImFsbCI6InVuY2F1Z2h0In0pLG8pe2NvbnN0IGU9dS5tYXhFeGNlcHRpb25zUGVyU2Vjb25kfHw1MDtwPWZ1bmN0aW9uKGUsdCxuKXtsZXQgbz0wLGk9NSxhPTA7cmV0dXJuIHNldEludGVydmFsKCgoKT0+ezA9PT1hP28+ZSYmKGkqPTIsbihpKSxpPjg2NDAwJiYoaT04NjQwMCksYT1pKTooYS09MSwwPT09YSYmdCgpKSxvPTB9KSwxZTMpLnVucmVmKCksKCk9PntvKz0xfX0oZSwoYXN5bmMoKT0+e2woIlJhdGUtbGltaXQgbGlmdGVkLiIpLGF3YWl0IHQucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZToiYWxsIn0pfSksKGFzeW5jIGU9PntsKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pKX19KSgpLmNhdGNoKChlPT57bCgiRmFpbGVkIHRvIHN0YXJ0IGRlYnVnZ2VyIixlKX0pKSxzZXRJbnRlcnZhbCgoKCk9Pnt9KSwxZTQpOw==";
function log(...args) {
  logger.log("[LocalVariables]", ...args);
}
var localVariablesAsyncIntegration = defineIntegration((integrationOptions = {}) => {
  function addLocalVariablesToException(exception, localVariables) {
    const frames = (exception.stacktrace?.frames || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0; i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const frameLocalVariables = localVariables[i];
      const frame = frames[frameIndex];
      if (!frame || !frameLocalVariables) {
        break;
      }
      if (
        // We need to have vars to add
        frameLocalVariables.vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
        frame.in_app === false || // The function names need to match
        !functionNamesMatch(frame.function, frameLocalVariables.function)
      ) {
        continue;
      }
      frame.vars = frameLocalVariables.vars;
    }
  }
  function addLocalVariablesToEvent(event, hint) {
    if (hint.originalException && typeof hint.originalException === "object" && LOCAL_VARIABLES_KEY in hint.originalException && Array.isArray(hint.originalException[LOCAL_VARIABLES_KEY])) {
      for (const exception of event.exception?.values || []) {
        addLocalVariablesToException(exception, hint.originalException[LOCAL_VARIABLES_KEY]);
      }
      hint.originalException[LOCAL_VARIABLES_KEY] = void 0;
    }
    return event;
  }
  async function startInspector() {
    const inspector = await import("node:inspector");
    if (!inspector.url()) {
      inspector.open(0);
    }
  }
  function startWorker(options) {
    const worker = new import_node_worker_threads.Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {
      workerData: options,
      // We don't want any Node args to be passed to the worker
      execArgv: [],
      env: { ...process.env, NODE_OPTIONS: void 0 }
    });
    process.on("exit", () => {
      worker.terminate();
    });
    worker.once("error", (err) => {
      log("Worker error", err);
    });
    worker.once("exit", (code) => {
      log("Worker exit", code);
    });
    worker.unref();
  }
  return {
    name: "LocalVariablesAsync",
    async setup(client) {
      const clientOptions = client.getOptions();
      if (!clientOptions.includeLocalVariables) {
        return;
      }
      if (await isDebuggerEnabled()) {
        logger.warn("Local variables capture has been disabled because the debugger was already enabled");
        return;
      }
      const options = {
        ...integrationOptions,
        debug: logger.isEnabled()
      };
      startInspector().then(
        () => {
          try {
            startWorker(options);
          } catch (e) {
            logger.error("Failed to start worker", e);
          }
        },
        (e) => {
          logger.error("Failed to start inspector", e);
        }
      );
    },
    processEvent(event, hint) {
      return addLocalVariablesToEvent(event, hint);
    }
  };
});

// node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-sync.js
function hashFrames(frames) {
  if (frames === void 0) {
    return;
  }
  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
}
function hashFromStack(stackParser, stack) {
  if (stack === void 0) {
    return void 0;
  }
  return hashFrames(stackParser(stack, 1));
}
function createCallbackList(complete) {
  let callbacks = [];
  let completedCalled = false;
  function checkedComplete(result) {
    callbacks = [];
    if (completedCalled) {
      return;
    }
    completedCalled = true;
    complete(result);
  }
  callbacks.push(checkedComplete);
  function add(fn) {
    callbacks.push(fn);
  }
  function next(result) {
    const popped = callbacks.pop() || checkedComplete;
    try {
      popped(result);
    } catch (_) {
      checkedComplete(result);
    }
  }
  return { add, next };
}
var AsyncSession = class _AsyncSession {
  /** Throws if inspector API is not available */
  constructor(_session) {
    this._session = _session;
  }
  static async create(orDefault) {
    if (orDefault) {
      return orDefault;
    }
    const inspector = await import("node:inspector");
    return new _AsyncSession(new inspector.Session());
  }
  /** @inheritdoc */
  configureAndConnect(onPause, captureAll) {
    this._session.connect();
    this._session.on("Debugger.paused", (event) => {
      onPause(event, () => {
        this._session.post("Debugger.resume");
      });
    });
    this._session.post("Debugger.enable");
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  setPauseOnExceptions(captureAll) {
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  /** @inheritdoc */
  getLocalVariables(objectId, complete) {
    this._getProperties(objectId, (props) => {
      const { add, next } = createCallbackList(complete);
      for (const prop of props) {
        if (prop.value?.objectId && prop.value.className === "Array") {
          const id = prop.value.objectId;
          add((vars) => this._unrollArray(id, prop.name, vars, next));
        } else if (prop.value?.objectId && prop.value.className === "Object") {
          const id = prop.value.objectId;
          add((vars) => this._unrollObject(id, prop.name, vars, next));
        } else if (prop.value) {
          add((vars) => this._unrollOther(prop, vars, next));
        }
      }
      next({});
    });
  }
  /**
   * Gets all the PropertyDescriptors of an object
   */
  _getProperties(objectId, next) {
    this._session.post(
      "Runtime.getProperties",
      {
        objectId,
        ownProperties: true
      },
      (err, params) => {
        if (err) {
          next([]);
        } else {
          next(params.result);
        }
      }
    );
  }
  /**
   * Unrolls an array property
   */
  _unrollArray(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => v.value?.value);
      next(vars);
    });
  }
  /**
   * Unrolls an object property
   */
  _unrollObject(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.map((v) => [v.name, v.value?.value]).reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
      }, {});
      next(vars);
    });
  }
  /**
   * Unrolls other properties
   */
  _unrollOther(prop, vars, next) {
    if (prop.value) {
      if ("value" in prop.value) {
        if (prop.value.value === void 0 || prop.value.value === null) {
          vars[prop.name] = `<${prop.value.value}>`;
        } else {
          vars[prop.name] = prop.value.value;
        }
      } else if ("description" in prop.value && prop.value.type !== "function") {
        vars[prop.name] = `<${prop.value.description}>`;
      } else if (prop.value.type === "undefined") {
        vars[prop.name] = "<undefined>";
      }
    }
    next(vars);
  }
};
var INTEGRATION_NAME10 = "LocalVariables";
var _localVariablesSyncIntegration = (options = {}, sessionOverride) => {
  const cachedFrames = new LRUMap(20);
  let rateLimiter;
  let shouldProcessEvent = false;
  function addLocalVariablesToException(exception) {
    const hash = hashFrames(exception.stacktrace?.frames);
    if (hash === void 0) {
      return;
    }
    const cachedFrame = cachedFrames.remove(hash);
    if (cachedFrame === void 0) {
      return;
    }
    const frames = (exception.stacktrace?.frames || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0; i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const cachedFrameVariable = cachedFrame[i];
      const frameVariable = frames[frameIndex];
      if (!frameVariable || !cachedFrameVariable) {
        break;
      }
      if (
        // We need to have vars to add
        cachedFrameVariable.vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
        frameVariable.in_app === false || // The function names need to match
        !functionNamesMatch(frameVariable.function, cachedFrameVariable.function)
      ) {
        continue;
      }
      frameVariable.vars = cachedFrameVariable.vars;
    }
  }
  function addLocalVariablesToEvent(event) {
    for (const exception of event.exception?.values || []) {
      addLocalVariablesToException(exception);
    }
    return event;
  }
  return {
    name: INTEGRATION_NAME10,
    async setupOnce() {
      const client = getClient();
      const clientOptions = client?.getOptions();
      if (!clientOptions?.includeLocalVariables) {
        return;
      }
      const unsupportedNodeVersion = NODE_MAJOR < 18;
      if (unsupportedNodeVersion) {
        logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
        return;
      }
      if (await isDebuggerEnabled()) {
        logger.warn("Local variables capture has been disabled because the debugger was already enabled");
        return;
      }
      AsyncSession.create(sessionOverride).then(
        (session) => {
          function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
            if (reason !== "exception" && reason !== "promiseRejection") {
              complete();
              return;
            }
            rateLimiter?.();
            const exceptionHash = hashFromStack(stackParser, data.description);
            if (exceptionHash == void 0) {
              complete();
              return;
            }
            const { add, next } = createCallbackList((frames) => {
              cachedFrames.set(exceptionHash, frames);
              complete();
            });
            for (let i = 0; i < Math.min(callFrames.length, 5); i++) {
              const { scopeChain, functionName, this: obj } = callFrames[i];
              const localScope = scopeChain.find((scope) => scope.type === "local");
              const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
              if (localScope?.object.objectId === void 0) {
                add((frames) => {
                  frames[i] = { function: fn };
                  next(frames);
                });
              } else {
                const id = localScope.object.objectId;
                add(
                  (frames) => session.getLocalVariables(id, (vars) => {
                    frames[i] = { function: fn, vars };
                    next(frames);
                  })
                );
              }
            }
            next([]);
          }
          const captureAll = options.captureAllExceptions !== false;
          session.configureAndConnect(
            (ev, complete) => handlePaused(clientOptions.stackParser, ev, complete),
            captureAll
          );
          if (captureAll) {
            const max = options.maxExceptionsPerSecond || 50;
            rateLimiter = createRateLimiter(
              max,
              () => {
                logger.log("Local variables rate-limit lifted.");
                session.setPauseOnExceptions(true);
              },
              (seconds) => {
                logger.log(
                  `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`
                );
                session.setPauseOnExceptions(false);
              }
            );
          }
          shouldProcessEvent = true;
        },
        (error) => {
          logger.log("The `LocalVariables` integration failed to start.", error);
        }
      );
    },
    processEvent(event) {
      if (shouldProcessEvent) {
        return addLocalVariablesToEvent(event);
      }
      return event;
    },
    // These are entirely for testing
    _getCachedFramesCount() {
      return cachedFrames.size;
    },
    _getFirstCachedFrame() {
      return cachedFrames.values()[0];
    }
  };
};
var localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);

// node_modules/@sentry/node/build/esm/integrations/local-variables/index.js
var localVariablesIntegration = (options = {}) => {
  return NODE_VERSION.major < 19 ? localVariablesSyncIntegration(options) : localVariablesAsyncIntegration(options);
};

// node_modules/@sentry/node/build/esm/integrations/modules.js
var import_node_fs3 = require("node:fs");
var import_node_path2 = require("node:path");

// node_modules/@sentry/node/build/esm/utils/commonjs.js
function isCjs() {
  try {
    return typeof module !== "undefined" && typeof module.exports !== "undefined";
  } catch {
    return false;
  }
}

// node_modules/@sentry/node/build/esm/integrations/modules.js
var moduleCache;
var INTEGRATION_NAME11 = "Modules";
var _modulesIntegration = () => {
  if (!isCjs()) {
    DEBUG_BUILD3 && logger.warn(
      "modulesIntegration only works in CommonJS (CJS) environments. Remove this integration if you are using ESM."
    );
    return {
      name: INTEGRATION_NAME11
    };
  }
  return {
    name: INTEGRATION_NAME11,
    processEvent(event) {
      event.modules = {
        ...event.modules,
        ..._getModules()
      };
      return event;
    }
  };
};
var modulesIntegration = defineIntegration(_modulesIntegration);
function getPaths() {
  try {
    return require.cache ? Object.keys(require.cache) : [];
  } catch (e) {
    return [];
  }
}
function collectModules() {
  const mainPaths = require.main?.paths || [];
  const paths = getPaths();
  const infos = {};
  const seen = {};
  paths.forEach((path) => {
    let dir = path;
    const updir = () => {
      const orig = dir;
      dir = (0, import_node_path2.dirname)(orig);
      if (!dir || orig === dir || seen[orig]) {
        return void 0;
      }
      if (mainPaths.indexOf(dir) < 0) {
        return updir();
      }
      const pkgfile = (0, import_node_path2.join)(orig, "package.json");
      seen[orig] = true;
      if (!(0, import_node_fs3.existsSync)(pkgfile)) {
        return updir();
      }
      try {
        const info = JSON.parse((0, import_node_fs3.readFileSync)(pkgfile, "utf8"));
        infos[info.name] = info.version;
      } catch (_oO) {
      }
    };
    updir();
  });
  return infos;
}
function _getModules() {
  if (!moduleCache) {
    moduleCache = collectModules();
  }
  return moduleCache;
}

// node_modules/@sentry/node/build/esm/utils/errorhandling.js
var DEFAULT_SHUTDOWN_TIMEOUT = 2e3;
function logAndExitProcess(error) {
  consoleSandbox(() => {
    console.error(error);
  });
  const client = getClient();
  if (client === void 0) {
    DEBUG_BUILD3 && logger.warn("No NodeClient was defined, we are exiting the process now.");
    global.process.exit(1);
    return;
  }
  const options = client.getOptions();
  const timeout = options?.shutdownTimeout && options.shutdownTimeout > 0 ? options.shutdownTimeout : DEFAULT_SHUTDOWN_TIMEOUT;
  client.close(timeout).then(
    (result) => {
      if (!result) {
        DEBUG_BUILD3 && logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
      }
      global.process.exit(1);
    },
    (error2) => {
      DEBUG_BUILD3 && logger.error(error2);
    }
  );
}

// node_modules/@sentry/node/build/esm/integrations/onuncaughtexception.js
var INTEGRATION_NAME12 = "OnUncaughtException";
var onUncaughtExceptionIntegration = defineIntegration((options = {}) => {
  const optionsWithDefaults = {
    exitEvenIfOtherHandlersAreRegistered: false,
    ...options
  };
  return {
    name: INTEGRATION_NAME12,
    setup(client) {
      global.process.on("uncaughtException", makeErrorHandler(client, optionsWithDefaults));
    }
  };
});
function makeErrorHandler(client, options) {
  const timeout = 2e3;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;
  const clientOptions = client.getOptions();
  return Object.assign(
    (error) => {
      let onFatalError = logAndExitProcess;
      if (options.onFatalError) {
        onFatalError = options.onFatalError;
      } else if (clientOptions.onFatalError) {
        onFatalError = clientOptions.onFatalError;
      }
      const userProvidedListenersCount = global.process.listeners("uncaughtException").filter(
        (listener) => {
          return (
            // as soon as we're using domains this listener is attached by node itself
            listener.name !== "domainUncaughtExceptionClear" && // the handler we register for tracing
            listener.tag !== "sentry_tracingErrorCallback" && // the handler we register in this integration
            listener._errorHandler !== true
          );
        }
      ).length;
      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
      if (!caughtFirstError) {
        firstError = error;
        caughtFirstError = true;
        if (getClient() === client) {
          captureException(error, {
            originalException: error,
            captureContext: {
              level: "fatal"
            },
            mechanism: {
              handled: false,
              type: "onuncaughtexception"
            }
          });
        }
        if (!calledFatalError && shouldApplyFatalHandlingLogic) {
          calledFatalError = true;
          onFatalError(error);
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            DEBUG_BUILD3 && logger.warn(
              "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
            );
            logAndExitProcess(error);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout);
          }
        }
      }
    },
    { _errorHandler: true }
  );
}

// node_modules/@sentry/node/build/esm/integrations/onunhandledrejection.js
var INTEGRATION_NAME13 = "OnUnhandledRejection";
var _onUnhandledRejectionIntegration = (options = {}) => {
  const opts = {
    mode: "warn",
    ...options
  };
  return {
    name: INTEGRATION_NAME13,
    setup(client) {
      global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, opts));
    }
  };
};
var onUnhandledRejectionIntegration = defineIntegration(_onUnhandledRejectionIntegration);
function makeUnhandledPromiseHandler(client, options) {
  return function sendUnhandledPromise(reason, promise) {
    if (getClient() !== client) {
      return;
    }
    const level = options.mode === "strict" ? "fatal" : "error";
    captureException(reason, {
      originalException: promise,
      captureContext: {
        extra: { unhandledPromiseRejection: true },
        level
      },
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
    handleRejection(reason, options.mode);
  };
}
function handleRejection(reason, mode) {
  const rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
  if (mode === "warn") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
      console.error(reason && typeof reason === "object" && "stack" in reason ? reason.stack : reason);
    });
  } else if (mode === "strict") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
    });
    logAndExitProcess(reason);
  }
}

// node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var import_instrumentation_express = __toESM(require_src9(), 1);

// node_modules/@sentry/node/build/esm/integrations/tracing/express-v5/instrumentation.js
init_esm();
var import_core23 = __toESM(require_src(), 1);
var import_instrumentation5 = __toESM(require_src4(), 1);
init_esm4();

// node_modules/@sentry/node/build/esm/integrations/tracing/express-v5/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames2) {
  const EXPRESS_TYPE = "express.type";
  AttributeNames2["EXPRESS_TYPE"] = EXPRESS_TYPE;
  const EXPRESS_NAME = "express.name";
  AttributeNames2["EXPRESS_NAME"] = EXPRESS_NAME;
})(AttributeNames || (AttributeNames = {}));

// node_modules/@sentry/node/build/esm/integrations/tracing/express-v5/enums/ExpressLayerType.js
var ExpressLayerType;
(function(ExpressLayerType2) {
  const ROUTER = "router";
  ExpressLayerType2["ROUTER"] = ROUTER;
  const MIDDLEWARE = "middleware";
  ExpressLayerType2["MIDDLEWARE"] = MIDDLEWARE;
  const REQUEST_HANDLER = "request_handler";
  ExpressLayerType2["REQUEST_HANDLER"] = REQUEST_HANDLER;
})(ExpressLayerType || (ExpressLayerType = {}));

// node_modules/@sentry/node/build/esm/integrations/tracing/express-v5/internal-types.js
var kLayerPatched = Symbol("express-layer-patched");
var _LAYERS_STORE_PROPERTY = "__ot_middlewares";

// node_modules/@sentry/node/build/esm/integrations/tracing/express-v5/utils.js
var storeLayerPath = (request, value) => {
  if (Array.isArray(request[_LAYERS_STORE_PROPERTY]) === false) {
    Object.defineProperty(request, _LAYERS_STORE_PROPERTY, {
      enumerable: false,
      value: []
    });
  }
  if (value === void 0) return;
  request[_LAYERS_STORE_PROPERTY].push(value);
};
var getRouterPath = (path, layer) => {
  const stackLayer = layer.handle?.stack?.[0];
  if (stackLayer?.route?.path) {
    return `${path}${stackLayer.route.path}`;
  }
  if (stackLayer?.handle?.stack) {
    return getRouterPath(path, stackLayer);
  }
  return path;
};
var getLayerMetadata = (route, layer, layerPath) => {
  if (layer.name === "router") {
    const maybeRouterPath = getRouterPath("", layer);
    const extractedRouterPath = maybeRouterPath ? maybeRouterPath : layerPath || route || "/";
    return {
      attributes: {
        [AttributeNames.EXPRESS_NAME]: extractedRouterPath,
        [AttributeNames.EXPRESS_TYPE]: ExpressLayerType.ROUTER
      },
      name: `router - ${extractedRouterPath}`
    };
  } else if (layer.name === "bound dispatch" || layer.name === "handle") {
    return {
      attributes: {
        [AttributeNames.EXPRESS_NAME]: (route || layerPath) ?? "request handler",
        [AttributeNames.EXPRESS_TYPE]: ExpressLayerType.REQUEST_HANDLER
      },
      name: `request handler${layer.path ? ` - ${route || layerPath}` : ""}`
    };
  } else {
    return {
      attributes: {
        [AttributeNames.EXPRESS_NAME]: layer.name,
        [AttributeNames.EXPRESS_TYPE]: ExpressLayerType.MIDDLEWARE
      },
      name: `middleware - ${layer.name}`
    };
  }
};
var satisfiesPattern = (constant, pattern) => {
  if (typeof pattern === "string") {
    return pattern === constant;
  } else if (pattern instanceof RegExp) {
    return pattern.test(constant);
  } else if (typeof pattern === "function") {
    return pattern(constant);
  } else {
    throw new TypeError("Pattern is in unsupported datatype");
  }
};
var isLayerIgnored = (name, type, config2) => {
  if (Array.isArray(config2?.ignoreLayersType) && config2?.ignoreLayersType?.includes(type)) {
    return true;
  }
  if (Array.isArray(config2?.ignoreLayers) === false) return false;
  try {
    for (const pattern of config2.ignoreLayers) {
      if (satisfiesPattern(name, pattern)) {
        return true;
      }
    }
  } catch (e) {
  }
  return false;
};
var asErrorAndMessage = (error) => error instanceof Error ? [error, error.message] : [String(error), String(error)];
var getLayerPath = (args) => {
  const firstArg = args[0];
  if (Array.isArray(firstArg)) {
    return firstArg.map((arg) => extractLayerPathSegment(arg) || "").join(",");
  }
  return extractLayerPathSegment(firstArg);
};
var extractLayerPathSegment = (arg) => {
  if (typeof arg === "string") {
    return arg;
  }
  if (arg instanceof RegExp || typeof arg === "number") {
    return arg.toString();
  }
  return;
};

// node_modules/@sentry/node/build/esm/integrations/tracing/express-v5/instrumentation.js
var PACKAGE_VERSION = "0.1.0";
var PACKAGE_NAME = "@sentry/instrumentation-express-v5";
var ExpressInstrumentationV5 = class extends import_instrumentation5.InstrumentationBase {
  constructor(config2 = {}) {
    super(PACKAGE_NAME, PACKAGE_VERSION, config2);
  }
  init() {
    return [
      new import_instrumentation5.InstrumentationNodeModuleDefinition(
        "express",
        [">=5.0.0"],
        (moduleExports) => this._setup(moduleExports),
        (moduleExports) => this._tearDown(moduleExports)
      )
    ];
  }
  _setup(moduleExports) {
    const routerProto = moduleExports.Router.prototype;
    if ((0, import_instrumentation5.isWrapped)(routerProto.route)) {
      this._unwrap(routerProto, "route");
    }
    this._wrap(routerProto, "route", this._getRoutePatch());
    if ((0, import_instrumentation5.isWrapped)(routerProto.use)) {
      this._unwrap(routerProto, "use");
    }
    this._wrap(routerProto, "use", this._getRouterUsePatch());
    if ((0, import_instrumentation5.isWrapped)(moduleExports.application.use)) {
      this._unwrap(moduleExports.application, "use");
    }
    this._wrap(moduleExports.application, "use", this._getAppUsePatch());
    return moduleExports;
  }
  _tearDown(moduleExports) {
    if (moduleExports === void 0) return;
    const routerProto = moduleExports.Router.prototype;
    this._unwrap(routerProto, "route");
    this._unwrap(routerProto, "use");
    this._unwrap(moduleExports.application, "use");
  }
  /**
   * Get the patch for Router.route function
   */
  _getRoutePatch() {
    const instrumentation = this;
    return function(original) {
      return function route_trace(...args) {
        const route = original.apply(this, args);
        const layer = this.stack[this.stack.length - 1];
        instrumentation._applyPatch(layer, getLayerPath(args));
        return route;
      };
    };
  }
  /**
   * Get the patch for Router.use function
   */
  _getRouterUsePatch() {
    const instrumentation = this;
    return function(original) {
      return function use(...args) {
        const route = original.apply(this, args);
        const layer = this.stack[this.stack.length - 1];
        instrumentation._applyPatch(layer, getLayerPath(args));
        return route;
      };
    };
  }
  /**
   * Get the patch for Application.use function
   */
  _getAppUsePatch() {
    const instrumentation = this;
    return function(original) {
      return function use(...args) {
        const router = this.router;
        const route = original.apply(this, args);
        if (router) {
          const layer = router.stack[router.stack.length - 1];
          instrumentation._applyPatch(layer, getLayerPath(args));
        }
        return route;
      };
    };
  }
  /** Patch each express layer to create span and propagate context */
  _applyPatch(layer, layerPath) {
    const instrumentation = this;
    if (layer[kLayerPatched] === true) return;
    layer[kLayerPatched] = true;
    this._wrap(layer, "handle", (original) => {
      if (original.length === 4) return original;
      const patched = function(req, res) {
        storeLayerPath(req, layerPath);
        const route = req[_LAYERS_STORE_PROPERTY].filter((path) => path !== "/" && path !== "/*").join("").replace(/\/{2,}/g, "/");
        const attributes = {
          // eslint-disable-next-line deprecation/deprecation
          [SEMATTRS_HTTP_ROUTE3]: route.length > 0 ? route : "/"
        };
        const metadata = getLayerMetadata(route, layer, layerPath);
        const type = metadata.attributes[AttributeNames.EXPRESS_TYPE];
        const rpcMetadata = (0, import_core23.getRPCMetadata)(context.active());
        if (rpcMetadata?.type === import_core23.RPCType.HTTP) {
          rpcMetadata.route = route || "/";
        }
        if (isLayerIgnored(metadata.name, type, instrumentation.getConfig())) {
          if (type === ExpressLayerType.MIDDLEWARE) {
            req[_LAYERS_STORE_PROPERTY].pop();
          }
          return original.apply(this, arguments);
        }
        if (trace.getSpan(context.active()) === void 0) {
          return original.apply(this, arguments);
        }
        const spanName = instrumentation._getSpanName(
          {
            request: req,
            layerType: type,
            route
          },
          metadata.name
        );
        const span = instrumentation.tracer.startSpan(spanName, {
          attributes: Object.assign(attributes, metadata.attributes)
        });
        const { requestHook: requestHook2 } = instrumentation.getConfig();
        if (requestHook2) {
          (0, import_instrumentation5.safeExecuteInTheMiddle)(
            () => requestHook2(span, {
              request: req,
              layerType: type,
              route
            }),
            (e) => {
              if (e) {
                diag2.error("express instrumentation: request hook failed", e);
              }
            },
            true
          );
        }
        let spanHasEnded = false;
        if (metadata.attributes[AttributeNames.EXPRESS_TYPE] !== ExpressLayerType.MIDDLEWARE) {
          span.end();
          spanHasEnded = true;
        }
        const onResponseFinish = () => {
          if (spanHasEnded === false) {
            spanHasEnded = true;
            span.end();
          }
        };
        const args = Array.from(arguments);
        const callbackIdx = args.findIndex((arg) => typeof arg === "function");
        if (callbackIdx >= 0) {
          arguments[callbackIdx] = function() {
            const maybeError = arguments[0];
            const isError2 = ![void 0, null, "route", "router"].includes(maybeError);
            if (!spanHasEnded && isError2) {
              const [error, message] = asErrorAndMessage(maybeError);
              span.recordException(error);
              span.setStatus({
                code: SpanStatusCode.ERROR,
                message
              });
            }
            if (spanHasEnded === false) {
              spanHasEnded = true;
              req.res?.removeListener("finish", onResponseFinish);
              span.end();
            }
            if (!(req.route && isError2)) {
              req[_LAYERS_STORE_PROPERTY].pop();
            }
            const callback = args[callbackIdx];
            return callback.apply(this, arguments);
          };
        }
        try {
          return original.apply(this, arguments);
        } catch (anyError) {
          const [error, message] = asErrorAndMessage(anyError);
          span.recordException(error);
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message
          });
          throw anyError;
        } finally {
          if (!spanHasEnded) {
            res.once("finish", onResponseFinish);
          }
        }
      };
      for (const key in original) {
        Object.defineProperty(patched, key, {
          get() {
            return original[key];
          },
          set(value) {
            original[key] = value;
          }
        });
      }
      return patched;
    });
  }
  _getSpanName(info, defaultName) {
    const { spanNameHook: spanNameHook2 } = this.getConfig();
    if (!(spanNameHook2 instanceof Function)) {
      return defaultName;
    }
    try {
      return spanNameHook2(info, defaultName) ?? defaultName;
    } catch (err) {
      diag2.error("express instrumentation: error calling span name rewrite hook", err);
      return defaultName;
    }
  }
};

// node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var INTEGRATION_NAME14 = "Express";
var INTEGRATION_NAME_V5 = "Express-V5";
function requestHook(span) {
  addOriginToSpan(span, "auto.http.otel.express");
  const attributes = spanToJSON(span).data;
  const type = attributes["express.type"];
  if (type) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.express`);
  }
  const name = attributes["express.name"];
  if (typeof name === "string") {
    span.updateName(name);
  }
}
function spanNameHook(info, defaultName) {
  if (getIsolationScope() === getDefaultIsolationScope()) {
    DEBUG_BUILD3 && logger.warn("Isolation scope is still default isolation scope - skipping setting transactionName");
    return defaultName;
  }
  if (info.layerType === "request_handler") {
    const req = info.request;
    const method = req.method ? req.method.toUpperCase() : "GET";
    getIsolationScope().setTransactionName(`${method} ${info.route}`);
  }
  return defaultName;
}
var instrumentExpress = generateInstrumentOnce(
  INTEGRATION_NAME14,
  () => new import_instrumentation_express.ExpressInstrumentation({
    requestHook: (span) => requestHook(span),
    spanNameHook: (info, defaultName) => spanNameHook(info, defaultName)
  })
);
var instrumentExpressV5 = generateInstrumentOnce(
  INTEGRATION_NAME_V5,
  () => new ExpressInstrumentationV5({
    requestHook: (span) => requestHook(span),
    spanNameHook: (info, defaultName) => spanNameHook(info, defaultName)
  })
);
var _expressIntegration = () => {
  return {
    name: INTEGRATION_NAME14,
    setupOnce() {
      instrumentExpress();
      instrumentExpressV5();
    }
  };
};
var expressIntegration = defineIntegration(_expressIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/fastify.js
var import_instrumentation_fastify = __toESM(require_src10(), 1);
var INTEGRATION_NAME15 = "Fastify";
var instrumentFastify = generateInstrumentOnce(
  INTEGRATION_NAME15,
  () => (
    // eslint-disable-next-line deprecation/deprecation
    new import_instrumentation_fastify.FastifyInstrumentation({
      requestHook(span) {
        addFastifySpanAttributes(span);
      }
    })
  )
);
var _fastifyIntegration = () => {
  return {
    name: INTEGRATION_NAME15,
    setupOnce() {
      instrumentFastify();
    }
  };
};
var fastifyIntegration = defineIntegration(_fastifyIntegration);
function addFastifySpanAttributes(span) {
  const attributes = spanToJSON(span).data;
  const type = attributes["fastify.type"];
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {
    return;
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.fastify",
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.fastify`
  });
  const name = attributes["fastify.name"] || attributes["plugin.name"] || attributes["hook.name"];
  if (typeof name === "string") {
    span.updateName(name.replace(/^fastify -> /, ""));
  }
}

// node_modules/@sentry/node/build/esm/integrations/tracing/graphql.js
var import_instrumentation_graphql = __toESM(require_src11(), 1);
var INTEGRATION_NAME16 = "Graphql";
var instrumentGraphql = generateInstrumentOnce(
  INTEGRATION_NAME16,
  (_options = {}) => {
    const options = getOptionsWithDefaults(_options);
    return new import_instrumentation_graphql.GraphQLInstrumentation({
      ...options,
      responseHook(span) {
        addOriginToSpan(span, "auto.graphql.otel.graphql");
        const attributes = spanToJSON(span).data;
        const operationType = attributes["graphql.operation.type"];
        const operationName = attributes["graphql.operation.name"];
        if (options.useOperationNameForRootSpan && operationType) {
          const rootSpan = getRootSpan(span);
          const rootSpanAttributes = spanToJSON(rootSpan).data;
          const existingOperations = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION] || [];
          const newOperation = operationName ? `${operationType} ${operationName}` : `${operationType}`;
          if (Array.isArray(existingOperations)) {
            existingOperations.push(newOperation);
            rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, existingOperations);
          } else if (typeof existingOperations === "string") {
            rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, [existingOperations, newOperation]);
          } else {
            rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, newOperation);
          }
        }
      }
    });
  }
);
var _graphqlIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME16,
    setupOnce() {
      instrumentGraphql(getOptionsWithDefaults(options));
    }
  };
};
var graphqlIntegration = defineIntegration(_graphqlIntegration);
function getOptionsWithDefaults(options) {
  return {
    ignoreResolveSpans: true,
    ignoreTrivialResolveSpans: true,
    useOperationNameForRootSpan: true,
    ...options
  };
}

// node_modules/@sentry/node/build/esm/integrations/tracing/kafka.js
var import_instrumentation_kafkajs = __toESM(require_src12(), 1);
var INTEGRATION_NAME17 = "Kafka";
var instrumentKafka = generateInstrumentOnce(
  INTEGRATION_NAME17,
  () => new import_instrumentation_kafkajs.KafkaJsInstrumentation({
    consumerHook(span) {
      addOriginToSpan(span, "auto.kafkajs.otel.consumer");
    },
    producerHook(span) {
      addOriginToSpan(span, "auto.kafkajs.otel.producer");
    }
  })
);
var _kafkaIntegration = () => {
  return {
    name: INTEGRATION_NAME17,
    setupOnce() {
      instrumentKafka();
    }
  };
};
var kafkaIntegration = defineIntegration(_kafkaIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/lrumemoizer.js
var import_instrumentation_lru_memoizer = __toESM(require_src13(), 1);
var INTEGRATION_NAME18 = "LruMemoizer";
var instrumentLruMemoizer = generateInstrumentOnce(INTEGRATION_NAME18, () => new import_instrumentation_lru_memoizer.LruMemoizerInstrumentation());
var _lruMemoizerIntegration = () => {
  return {
    name: INTEGRATION_NAME18,
    setupOnce() {
      instrumentLruMemoizer();
    }
  };
};
var lruMemoizerIntegration = defineIntegration(_lruMemoizerIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/mongo.js
var import_instrumentation_mongodb = __toESM(require_src14(), 1);
var INTEGRATION_NAME19 = "Mongo";
var instrumentMongo = generateInstrumentOnce(
  INTEGRATION_NAME19,
  () => new import_instrumentation_mongodb.MongoDBInstrumentation({
    dbStatementSerializer: _defaultDbStatementSerializer,
    responseHook(span) {
      addOriginToSpan(span, "auto.db.otel.mongo");
    }
  })
);
function _defaultDbStatementSerializer(commandObj) {
  const resultObj = _scrubStatement(commandObj);
  return JSON.stringify(resultObj);
}
function _scrubStatement(value) {
  if (Array.isArray(value)) {
    return value.map((element) => _scrubStatement(element));
  }
  if (isCommandObj(value)) {
    const initial = {};
    return Object.entries(value).map(([key, element]) => [key, _scrubStatement(element)]).reduce((prev, current) => {
      if (isCommandEntry(current)) {
        prev[current[0]] = current[1];
      }
      return prev;
    }, initial);
  }
  return "?";
}
function isCommandObj(value) {
  return typeof value === "object" && value !== null && !isBuffer(value);
}
function isBuffer(value) {
  let isBuffer2 = false;
  if (typeof Buffer !== "undefined") {
    isBuffer2 = Buffer.isBuffer(value);
  }
  return isBuffer2;
}
function isCommandEntry(value) {
  return Array.isArray(value);
}
var _mongoIntegration = () => {
  return {
    name: INTEGRATION_NAME19,
    setupOnce() {
      instrumentMongo();
    }
  };
};
var mongoIntegration = defineIntegration(_mongoIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/mongoose.js
var import_instrumentation_mongoose = __toESM(require_src15(), 1);
var INTEGRATION_NAME20 = "Mongoose";
var instrumentMongoose = generateInstrumentOnce(
  INTEGRATION_NAME20,
  () => new import_instrumentation_mongoose.MongooseInstrumentation({
    responseHook(span) {
      addOriginToSpan(span, "auto.db.otel.mongoose");
    }
  })
);
var _mongooseIntegration = () => {
  return {
    name: INTEGRATION_NAME20,
    setupOnce() {
      instrumentMongoose();
    }
  };
};
var mongooseIntegration = defineIntegration(_mongooseIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/mysql.js
var import_instrumentation_mysql = __toESM(require_src16(), 1);
var INTEGRATION_NAME21 = "Mysql";
var instrumentMysql = generateInstrumentOnce(INTEGRATION_NAME21, () => new import_instrumentation_mysql.MySQLInstrumentation({}));
var _mysqlIntegration = () => {
  return {
    name: INTEGRATION_NAME21,
    setupOnce() {
      instrumentMysql();
    }
  };
};
var mysqlIntegration = defineIntegration(_mysqlIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/mysql2.js
var import_instrumentation_mysql2 = __toESM(require_src18(), 1);
var INTEGRATION_NAME22 = "Mysql2";
var instrumentMysql2 = generateInstrumentOnce(
  INTEGRATION_NAME22,
  () => new import_instrumentation_mysql2.MySQL2Instrumentation({
    responseHook(span) {
      addOriginToSpan(span, "auto.db.otel.mysql2");
    }
  })
);
var _mysql2Integration = () => {
  return {
    name: INTEGRATION_NAME22,
    setupOnce() {
      instrumentMysql2();
    }
  };
};
var mysql2Integration = defineIntegration(_mysql2Integration);

// node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var import_instrumentation_ioredis = __toESM(require_src20(), 1);
var import_instrumentation_redis_4 = __toESM(require_src21(), 1);

// node_modules/@sentry/node/build/esm/utils/redisCache.js
var SINGLE_ARG_COMMANDS = ["get", "set", "setex"];
var GET_COMMANDS = ["get", "mget"];
var SET_COMMANDS = ["set", "setex"];
function isInCommands(redisCommands, command) {
  return redisCommands.includes(command.toLowerCase());
}
function getCacheOperation(command) {
  if (isInCommands(GET_COMMANDS, command)) {
    return "cache.get";
  } else if (isInCommands(SET_COMMANDS, command)) {
    return "cache.put";
  } else {
    return void 0;
  }
}
function keyHasPrefix(key, prefixes) {
  return prefixes.some((prefix) => key.startsWith(prefix));
}
function getCacheKeySafely(redisCommand, cmdArgs) {
  try {
    if (cmdArgs.length === 0) {
      return void 0;
    }
    const processArg = (arg) => {
      if (typeof arg === "string" || typeof arg === "number" || Buffer.isBuffer(arg)) {
        return [arg.toString()];
      } else if (Array.isArray(arg)) {
        return flatten(arg.map((arg2) => processArg(arg2)));
      } else {
        return ["<unknown>"];
      }
    };
    const firstArg = cmdArgs[0];
    if (isInCommands(SINGLE_ARG_COMMANDS, redisCommand) && firstArg != null) {
      return processArg(firstArg);
    }
    return flatten(cmdArgs.map((arg) => processArg(arg)));
  } catch (e) {
    return void 0;
  }
}
function shouldConsiderForCache(redisCommand, keys, prefixes) {
  if (!getCacheOperation(redisCommand)) {
    return false;
  }
  for (const key of keys) {
    if (keyHasPrefix(key, prefixes)) {
      return true;
    }
  }
  return false;
}
function calculateCacheItemSize(response) {
  const getSize = (value) => {
    try {
      if (Buffer.isBuffer(value)) return value.byteLength;
      else if (typeof value === "string") return value.length;
      else if (typeof value === "number") return value.toString().length;
      else if (value === null || value === void 0) return 0;
      return JSON.stringify(value).length;
    } catch (e) {
      return void 0;
    }
  };
  return Array.isArray(response) ? response.reduce((acc, curr) => {
    const size = getSize(curr);
    return typeof size === "number" ? acc !== void 0 ? acc + size : size : acc;
  }, 0) : getSize(response);
}
function flatten(input) {
  const result = [];
  const flattenHelper = (input2) => {
    input2.forEach((el) => {
      if (Array.isArray(el)) {
        flattenHelper(el);
      } else {
        result.push(el);
      }
    });
  };
  flattenHelper(input);
  return result;
}

// node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var INTEGRATION_NAME23 = "Redis";
var _redisOptions = {};
var cacheResponseHook = (span, redisCommand, cmdArgs, response) => {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.redis");
  const safeKey = getCacheKeySafely(redisCommand, cmdArgs);
  const cacheOperation = getCacheOperation(redisCommand);
  if (!safeKey || !cacheOperation || !_redisOptions.cachePrefixes || !shouldConsiderForCache(redisCommand, safeKey, _redisOptions.cachePrefixes)) {
    return;
  }
  const networkPeerAddress = spanToJSON(span).data["net.peer.name"];
  const networkPeerPort = spanToJSON(span).data["net.peer.port"];
  if (networkPeerPort && networkPeerAddress) {
    span.setAttributes({ "network.peer.address": networkPeerAddress, "network.peer.port": networkPeerPort });
  }
  const cacheItemSize = calculateCacheItemSize(response);
  if (cacheItemSize) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, cacheItemSize);
  }
  if (isInCommands(GET_COMMANDS, redisCommand) && cacheItemSize !== void 0) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_HIT, cacheItemSize > 0);
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: cacheOperation,
    [SEMANTIC_ATTRIBUTE_CACHE_KEY]: safeKey
  });
  const spanDescription = safeKey.join(", ");
  span.updateName(truncate(spanDescription, 1024));
};
var instrumentIORedis = generateInstrumentOnce("IORedis", () => {
  return new import_instrumentation_ioredis.IORedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis4 = generateInstrumentOnce("Redis-4", () => {
  return new import_instrumentation_redis_4.RedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis = Object.assign(
  () => {
    instrumentIORedis();
    instrumentRedis4();
  },
  { id: INTEGRATION_NAME23 }
);
var _redisIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME23,
    setupOnce() {
      _redisOptions = options;
      instrumentRedis();
    }
  };
};
var redisIntegration = defineIntegration(_redisIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/postgres.js
var import_instrumentation_pg = __toESM(require_src22(), 1);
var INTEGRATION_NAME24 = "Postgres";
var instrumentPostgres = generateInstrumentOnce(
  INTEGRATION_NAME24,
  () => new import_instrumentation_pg.PgInstrumentation({
    requireParentSpan: true,
    requestHook(span) {
      addOriginToSpan(span, "auto.db.otel.postgres");
    }
  })
);
var _postgresIntegration = () => {
  return {
    name: INTEGRATION_NAME24,
    setupOnce() {
      instrumentPostgres();
    }
  };
};
var postgresIntegration = defineIntegration(_postgresIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/hapi/index.js
var import_instrumentation_hapi = __toESM(require_src23(), 1);
var INTEGRATION_NAME25 = "Hapi";
var instrumentHapi = generateInstrumentOnce(INTEGRATION_NAME25, () => new import_instrumentation_hapi.HapiInstrumentation());
var _hapiIntegration = () => {
  return {
    name: INTEGRATION_NAME25,
    setupOnce() {
      instrumentHapi();
    }
  };
};
var hapiIntegration = defineIntegration(_hapiIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/koa.js
var import_instrumentation_koa = __toESM(require_src24(), 1);
init_esm4();
var INTEGRATION_NAME26 = "Koa";
var instrumentKoa = generateInstrumentOnce(
  INTEGRATION_NAME26,
  () => new import_instrumentation_koa.KoaInstrumentation({
    requestHook(span, info) {
      addKoaSpanAttributes(span);
      if (getIsolationScope() === getDefaultIsolationScope()) {
        DEBUG_BUILD3 && logger.warn("Isolation scope is default isolation scope - skipping setting transactionName");
        return;
      }
      const attributes = spanToJSON(span).data;
      const route = attributes[ATTR_HTTP_ROUTE3];
      const method = info.context?.request?.method?.toUpperCase() || "GET";
      if (route) {
        getIsolationScope().setTransactionName(`${method} ${route}`);
      }
    }
  })
);
var _koaIntegration = () => {
  return {
    name: INTEGRATION_NAME26,
    setupOnce() {
      instrumentKoa();
    }
  };
};
var koaIntegration = defineIntegration(_koaIntegration);
function addKoaSpanAttributes(span) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.http.otel.koa");
  const attributes = spanToJSON(span).data;
  const type = attributes["koa.type"];
  if (type) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.koa`);
  }
  const name = attributes["koa.name"];
  if (typeof name === "string") {
    span.updateName(name || "< unknown >");
  }
}

// node_modules/@sentry/node/build/esm/integrations/tracing/connect.js
var import_instrumentation_connect = __toESM(require_src25(), 1);
var INTEGRATION_NAME27 = "Connect";
var instrumentConnect = generateInstrumentOnce(INTEGRATION_NAME27, () => new import_instrumentation_connect.ConnectInstrumentation());
var _connectIntegration = () => {
  return {
    name: INTEGRATION_NAME27,
    setupOnce() {
      instrumentConnect();
    }
  };
};
var connectIntegration = defineIntegration(_connectIntegration);

// node_modules/@sentry/node/build/esm/integrations/spotlight.js
var http = __toESM(require("node:http"), 1);
var INTEGRATION_NAME28 = "Spotlight";
var _spotlightIntegration = (options = {}) => {
  const _options = {
    sidecarUrl: options.sidecarUrl || "http://localhost:8969/stream"
  };
  return {
    name: INTEGRATION_NAME28,
    setup(client) {
      if (typeof process === "object" && process.env && process.env.NODE_ENV !== "development") {
        logger.warn("[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?");
      }
      connectToSpotlight(client, _options);
    }
  };
};
var spotlightIntegration = defineIntegration(_spotlightIntegration);
function connectToSpotlight(client, options) {
  const spotlightUrl = parseSidecarUrl(options.sidecarUrl);
  if (!spotlightUrl) {
    return;
  }
  let failedRequests = 0;
  client.on("beforeEnvelope", (envelope) => {
    if (failedRequests > 3) {
      logger.warn("[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests");
      return;
    }
    const serializedEnvelope = serializeEnvelope(envelope);
    const request = getNativeHttpRequest();
    const req = request(
      {
        method: "POST",
        path: spotlightUrl.pathname,
        hostname: spotlightUrl.hostname,
        port: spotlightUrl.port,
        headers: {
          "Content-Type": "application/x-sentry-envelope"
        }
      },
      (res) => {
        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 400) {
          failedRequests = 0;
        }
        res.on("data", () => {
        });
        res.on("end", () => {
        });
        res.setEncoding("utf8");
      }
    );
    req.on("error", () => {
      failedRequests++;
      logger.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar");
    });
    req.write(serializedEnvelope);
    req.end();
  });
}
function parseSidecarUrl(url2) {
  try {
    return new URL(`${url2}`);
  } catch {
    logger.warn(`[Spotlight] Invalid sidecar URL: ${url2}`);
    return void 0;
  }
}
function getNativeHttpRequest() {
  const { request } = http;
  if (isWrapped2(request)) {
    return request.__sentry_original__;
  }
  return request;
}
function isWrapped2(impl) {
  return "__sentry_original__" in impl;
}

// node_modules/@sentry/node/build/esm/integrations/tracing/tedious.js
var import_instrumentation_tedious = __toESM(require_src26(), 1);
var TEDIUS_INSTRUMENTED_METHODS = /* @__PURE__ */ new Set([
  "callProcedure",
  "execSql",
  "execSqlBatch",
  "execBulkLoad",
  "prepare",
  "execute"
]);
var INTEGRATION_NAME29 = "Tedious";
var instrumentTedious = generateInstrumentOnce(INTEGRATION_NAME29, () => new import_instrumentation_tedious.TediousInstrumentation({}));
var _tediousIntegration = () => {
  let instrumentationWrappedCallback;
  return {
    name: INTEGRATION_NAME29,
    setupOnce() {
      const instrumentation = instrumentTedious();
      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);
    },
    setup(client) {
      instrumentationWrappedCallback?.(
        () => client.on("spanStart", (span) => {
          const { description, data } = spanToJSON(span);
          if (!description || data["db.system"] !== "mssql") {
            return;
          }
          const operation = description.split(" ")[0] || "";
          if (TEDIUS_INSTRUMENTED_METHODS.has(operation)) {
            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.tedious");
          }
        })
      );
    }
  };
};
var tediousIntegration = defineIntegration(_tediousIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/genericPool.js
var import_instrumentation_generic_pool = __toESM(require_src27(), 1);
var INTEGRATION_NAME30 = "GenericPool";
var instrumentGenericPool = generateInstrumentOnce(INTEGRATION_NAME30, () => new import_instrumentation_generic_pool.GenericPoolInstrumentation({}));
var _genericPoolIntegration = () => {
  let instrumentationWrappedCallback;
  return {
    name: INTEGRATION_NAME30,
    setupOnce() {
      const instrumentation = instrumentGenericPool();
      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);
    },
    setup(client) {
      instrumentationWrappedCallback?.(
        () => client.on("spanStart", (span) => {
          const spanJSON = spanToJSON(span);
          const spanDescription = spanJSON.description;
          const isGenericPoolSpan = spanDescription === "generic-pool.aquire" || spanDescription === "generic-pool.acquire";
          if (isGenericPoolSpan) {
            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.generic_pool");
          }
        })
      );
    }
  };
};
var genericPoolIntegration = defineIntegration(_genericPoolIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/amqplib.js
var import_instrumentation_amqplib = __toESM(require_src28(), 1);
var INTEGRATION_NAME31 = "Amqplib";
var config = {
  consumeEndHook: (span) => {
    addOriginToSpan(span, "auto.amqplib.otel.consumer");
  },
  publishHook: (span) => {
    addOriginToSpan(span, "auto.amqplib.otel.publisher");
  }
};
var instrumentAmqplib = generateInstrumentOnce(INTEGRATION_NAME31, () => new import_instrumentation_amqplib.AmqplibInstrumentation(config));
var _amqplibIntegration = () => {
  return {
    name: INTEGRATION_NAME31,
    setupOnce() {
      instrumentAmqplib();
    }
  };
};
var amqplibIntegration = defineIntegration(_amqplibIntegration);

// node_modules/@sentry/node/build/esm/integrations/tracing/vercelai/instrumentation.js
var import_instrumentation7 = __toESM(require_src4(), 1);
var INSTRUMENTED_METHODS = [
  "generateText",
  "streamText",
  "generateObject",
  "streamObject",
  "embed",
  "embedMany"
];
var SentryVercelAiInstrumentation = class _SentryVercelAiInstrumentation extends import_instrumentation7.InstrumentationBase {
  __init() {
    this._isPatched = false;
  }
  __init2() {
    this._callbacks = [];
  }
  constructor(config2 = {}) {
    super("@sentry/instrumentation-vercel-ai", SDK_VERSION, config2);
    _SentryVercelAiInstrumentation.prototype.__init.call(this);
    _SentryVercelAiInstrumentation.prototype.__init2.call(this);
  }
  /**
   * Initializes the instrumentation by defining the modules to be patched.
   */
  init() {
    const module2 = new import_instrumentation7.InstrumentationNodeModuleDefinition("ai", [">=3.0.0 <5"], this._patch.bind(this));
    return module2;
  }
  /**
   * Call the provided callback when the module is patched.
   * If it has already been patched, the callback will be called immediately.
   */
  callWhenPatched(callback) {
    if (this._isPatched) {
      callback();
    } else {
      this._callbacks.push(callback);
    }
  }
  /**
   * Patches module exports to enable Vercel AI telemetry.
   */
  _patch(moduleExports) {
    this._isPatched = true;
    this._callbacks.forEach((callback) => callback());
    this._callbacks = [];
    function generatePatch(name) {
      return (...args) => {
        const existingExperimentalTelemetry = args[0].experimental_telemetry || {};
        const isEnabled2 = existingExperimentalTelemetry.isEnabled;
        if (isEnabled2 === void 0) {
          args[0].experimental_telemetry = {
            isEnabled: true,
            recordInputs: false,
            recordOutputs: false,
            ...existingExperimentalTelemetry
          };
        }
        return moduleExports[name].apply(this, args);
      };
    }
    const patchedModuleExports = INSTRUMENTED_METHODS.reduce((acc, curr) => {
      acc[curr] = generatePatch(curr);
      return acc;
    }, {});
    return { ...moduleExports, ...patchedModuleExports };
  }
};

// node_modules/@sentry/node/build/esm/integrations/tracing/vercelai/index.js
var INTEGRATION_NAME32 = "VercelAI";
var instrumentVercelAi = generateInstrumentOnce(INTEGRATION_NAME32, () => new SentryVercelAiInstrumentation({}));
var _vercelAIIntegration = () => {
  let instrumentation;
  return {
    name: INTEGRATION_NAME32,
    setupOnce() {
      instrumentation = instrumentVercelAi();
    },
    setup(client) {
      instrumentation?.callWhenPatched(() => {
        client.on("spanStart", (span) => {
          const { data: attributes, description: name } = spanToJSON(span);
          if (!name) {
            return;
          }
          const aiModelId = attributes["ai.model.id"];
          const aiModelProvider = attributes["ai.model.provider"];
          if (typeof aiModelId !== "string" || typeof aiModelProvider !== "string" || !aiModelId || !aiModelProvider) {
            return;
          }
          let isPipelineSpan = false;
          switch (name) {
            case "ai.generateText": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.pipeline.generateText");
              isPipelineSpan = true;
              break;
            }
            case "ai.generateText.doGenerate": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.run.doGenerate");
              break;
            }
            case "ai.streamText": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.pipeline.streamText");
              isPipelineSpan = true;
              break;
            }
            case "ai.streamText.doStream": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.run.doStream");
              break;
            }
            case "ai.generateObject": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.pipeline.generateObject");
              isPipelineSpan = true;
              break;
            }
            case "ai.generateObject.doGenerate": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.run.doGenerate");
              break;
            }
            case "ai.streamObject": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.pipeline.streamObject");
              isPipelineSpan = true;
              break;
            }
            case "ai.streamObject.doStream": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.run.doStream");
              break;
            }
            case "ai.embed": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.pipeline.embed");
              isPipelineSpan = true;
              break;
            }
            case "ai.embed.doEmbed": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.embeddings");
              break;
            }
            case "ai.embedMany": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.pipeline.embedMany");
              isPipelineSpan = true;
              break;
            }
            case "ai.embedMany.doEmbed": {
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.embeddings");
              break;
            }
            case "ai.toolCall":
            case "ai.stream.firstChunk":
            case "ai.stream.finish":
              span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, "ai.run");
              break;
          }
          addOriginToSpan(span, "auto.vercelai.otel");
          const nameWthoutAi = name.replace("ai.", "");
          span.setAttribute("ai.pipeline.name", nameWthoutAi);
          span.updateName(nameWthoutAi);
          const functionId = attributes["ai.telemetry.functionId"];
          if (functionId && typeof functionId === "string" && isPipelineSpan) {
            span.updateName(functionId);
            span.setAttribute("ai.pipeline.name", functionId);
          }
          if (attributes["ai.prompt"]) {
            span.setAttribute("ai.input_messages", attributes["ai.prompt"]);
          }
          if (attributes["ai.model.id"]) {
            span.setAttribute("ai.model_id", attributes["ai.model.id"]);
          }
          span.setAttribute("ai.streaming", name.includes("stream"));
        });
        client.addEventProcessor((event) => {
          if (event.type === "transaction" && event.spans?.length) {
            for (const span of event.spans) {
              const { data: attributes, description: name } = span;
              if (!name || span.origin !== "auto.vercelai.otel") {
                continue;
              }
              if (attributes["ai.usage.completionTokens"] != void 0) {
                attributes["ai.completion_tokens.used"] = attributes["ai.usage.completionTokens"];
              }
              if (attributes["ai.usage.promptTokens"] != void 0) {
                attributes["ai.prompt_tokens.used"] = attributes["ai.usage.promptTokens"];
              }
              if (typeof attributes["ai.usage.completionTokens"] == "number" && typeof attributes["ai.usage.promptTokens"] == "number") {
                attributes["ai.total_tokens.used"] = attributes["ai.usage.completionTokens"] + attributes["ai.usage.promptTokens"];
              }
            }
          }
          return event;
        });
      });
    }
  };
};
var vercelAIIntegration = defineIntegration(_vercelAIIntegration);

// node_modules/@sentry/node/build/esm/integrations/childProcess.js
var diagnosticsChannel = __toESM(require("node:diagnostics_channel"), 1);
var INTEGRATION_NAME33 = "ChildProcess";
var childProcessIntegration = defineIntegration((options = {}) => {
  return {
    name: INTEGRATION_NAME33,
    setup() {
      diagnosticsChannel.channel("child_process").subscribe((event) => {
        if (event && typeof event === "object" && "process" in event) {
          captureChildProcessEvents(event.process, options);
        }
      });
      diagnosticsChannel.channel("worker_threads").subscribe((event) => {
        if (event && typeof event === "object" && "worker" in event) {
          captureWorkerThreadEvents(event.worker, options);
        }
      });
    }
  };
});
function captureChildProcessEvents(child, options) {
  let hasExited = false;
  let data;
  child.on("spawn", () => {
    if (child.spawnfile === "/usr/bin/sw_vers") {
      hasExited = true;
      return;
    }
    data = { spawnfile: child.spawnfile };
    if (options.includeChildProcessArgs) {
      data.spawnargs = child.spawnargs;
    }
  }).on("exit", (code) => {
    if (!hasExited) {
      hasExited = true;
      if (code !== null && code !== 0) {
        addBreadcrumb({
          category: "child_process",
          message: `Child process exited with code '${code}'`,
          level: code === 0 ? "info" : "warning",
          data
        });
      }
    }
  }).on("error", (error) => {
    if (!hasExited) {
      hasExited = true;
      addBreadcrumb({
        category: "child_process",
        message: `Child process errored with '${error.message}'`,
        level: "error",
        data
      });
    }
  });
}
function captureWorkerThreadEvents(worker, options) {
  let threadId2;
  worker.on("online", () => {
    threadId2 = worker.threadId;
  }).on("error", (error) => {
    if (options.captureWorkerErrors !== false) {
      captureException(error, {
        mechanism: { type: "instrument", handled: false, data: { threadId: String(threadId2) } }
      });
    } else {
      addBreadcrumb({
        category: "worker_thread",
        message: `Worker thread errored with '${error.message}'`,
        level: "error",
        data: { threadId: threadId2 }
      });
    }
  });
}

// node_modules/@sentry/node/build/esm/otel/contextManager.js
var import_context_async_hooks = __toESM(require_src29(), 1);
var SentryContextManager = wrapContextManagerClass(import_context_async_hooks.AsyncLocalStorageContextManager);

// node_modules/@sentry/node/build/esm/integrations/processSession.js
var INTEGRATION_NAME34 = "ProcessSession";
var processSessionIntegration = defineIntegration(() => {
  return {
    name: INTEGRATION_NAME34,
    setupOnce() {
      startSession();
      process.on("beforeExit", () => {
        const session = getIsolationScope().getSession();
        if (session?.status !== "ok") {
          endSession();
        }
      });
    }
  };
});

// node_modules/@sentry/node/build/esm/integrations/tracing/index.js
function getAutoPerformanceIntegrations() {
  return [
    expressIntegration(),
    fastifyIntegration(),
    graphqlIntegration(),
    mongoIntegration(),
    mongooseIntegration(),
    mysqlIntegration(),
    mysql2Integration(),
    redisIntegration(),
    postgresIntegration(),
    // For now, we do not include prisma by default because it has ESM issues
    // See https://github.com/prisma/prisma/issues/23410
    // TODO v8: Figure out a better solution for this, maybe only disable in ESM mode?
    // prismaIntegration(),
    hapiIntegration(),
    koaIntegration(),
    connectIntegration(),
    tediousIntegration(),
    genericPoolIntegration(),
    kafkaIntegration(),
    amqplibIntegration(),
    lruMemoizerIntegration(),
    vercelAIIntegration()
  ];
}

// node_modules/@sentry/node/build/esm/transports/http.js
var http3 = __toESM(require("node:http"), 1);
var https = __toESM(require("node:https"), 1);
var import_node_stream = require("node:stream");
var import_node_zlib = require("node:zlib");

// node_modules/@sentry/node/build/esm/proxy/index.js
var net = __toESM(require("node:net"), 1);
var tls = __toESM(require("node:tls"), 1);

// node_modules/@sentry/node/build/esm/proxy/base.js
var http2 = __toESM(require("node:http"), 1);
var INTERNAL = Symbol("AgentBaseInternalState");
var Agent2 = class extends http2.Agent {
  // Set by `http.Agent` - missing from `@types/node`
  constructor(opts) {
    super(opts);
    this[INTERNAL] = {};
  }
  /**
   * Determine whether this is an `http` or `https` request.
   */
  isSecureEndpoint(options) {
    if (options) {
      if (typeof options.secureEndpoint === "boolean") {
        return options.secureEndpoint;
      }
      if (typeof options.protocol === "string") {
        return options.protocol === "https:";
      }
    }
    const { stack } = new Error();
    if (typeof stack !== "string") return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  createSocket(req, options, cb) {
    const connectOpts = {
      ...options,
      secureEndpoint: this.isSecureEndpoint(options)
    };
    Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
      if (socket instanceof http2.Agent) {
        return socket.addRequest(req, connectOpts);
      }
      this[INTERNAL].currentSocket = socket;
      super.createSocket(req, options, cb);
    }, cb);
  }
  createConnection() {
    const socket = this[INTERNAL].currentSocket;
    this[INTERNAL].currentSocket = void 0;
    if (!socket) {
      throw new Error("No socket was returned in the `connect()` function");
    }
    return socket;
  }
  get defaultPort() {
    return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
  }
  set defaultPort(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].defaultPort = v;
    }
  }
  get protocol() {
    return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
  }
  set protocol(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].protocol = v;
    }
  }
};

// node_modules/@sentry/node/build/esm/proxy/parse-proxy-response.js
function debug(...args) {
  logger.log("[https-proxy-agent:parse-proxy-response]", ...args);
}
function parseProxyResponse(socket) {
  return new Promise((resolve2, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b) ondata(b);
      else socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.subarray(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +(firstLineParts[1] || 0);
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header) continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debug("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve2({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}

// node_modules/@sentry/node/build/esm/proxy/index.js
function debug2(...args) {
  logger.log("[https-proxy-agent]", ...args);
}
var HttpsProxyAgent = class extends Agent2 {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(proxy, opts) {
    super(opts);
    this.options = {};
    this.proxy = typeof proxy === "string" ? new URL(proxy) : proxy;
    this.proxyHeaders = opts?.headers ?? {};
    debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug2("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls.connect({
        ...this.connectOpts,
        servername: servername && net.isIP(servername) ? void 0 : servername
      });
    } else {
      debug2("Creating `net.Socket`: %o", this.connectOpts);
      socket = net.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers)) {
      payload += `${name}: ${headers[name]}\r
`;
    }
    const proxyResponsePromise = parseProxyResponse(socket);
    socket.write(`${payload}\r
`);
    const { connect: connect3, buffered } = await proxyResponsePromise;
    req.emit("proxyConnect", connect3);
    this.emit("proxyConnect", connect3, req);
    if (connect3.statusCode === 200) {
      req.once("socket", resume);
      if (opts.secureEndpoint) {
        debug2("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls.connect({
          ...omit(opts, "host", "path", "port"),
          socket,
          servername: net.isIP(servername) ? void 0 : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net.Socket({ writable: false });
    fakeSocket.readable = true;
    req.once("socket", (s) => {
      debug2("Replaying proxy buffer for failed request");
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
};
HttpsProxyAgent.__initStatic();
function resume(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}

// node_modules/@sentry/node/build/esm/transports/http.js
var GZIP_THRESHOLD = 1024 * 32;
function streamFromBody(body) {
  return new import_node_stream.Readable({
    read() {
      this.push(body);
      this.push(null);
    }
  });
}
function makeNodeTransport(options) {
  let urlSegments;
  try {
    urlSegments = new URL(options.url);
  } catch (e) {
    consoleSandbox(() => {
      console.warn(
        "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used."
      );
    });
    return createTransport(options, () => Promise.resolve({}));
  }
  const isHttps = urlSegments.protocol === "https:";
  const proxy = applyNoProxyOption(
    urlSegments,
    options.proxy || (isHttps ? process.env.https_proxy : void 0) || process.env.http_proxy
  );
  const nativeHttpModule = isHttps ? https : http3;
  const keepAlive = options.keepAlive === void 0 ? false : options.keepAlive;
  const agent = proxy ? new HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2e3 });
  const requestExecutor = createRequestExecutor(options, options.httpModule ?? nativeHttpModule, agent);
  return createTransport(options, requestExecutor);
}
function applyNoProxyOption(transportUrlSegments, proxy) {
  const { no_proxy } = process.env;
  const urlIsExemptFromProxy = no_proxy?.split(",").some(
    (exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption)
  );
  if (urlIsExemptFromProxy) {
    return void 0;
  } else {
    return proxy;
  }
}
function createRequestExecutor(options, httpModule, agent) {
  const { hostname: hostname2, pathname, port, protocol, search } = new URL(options.url);
  return function makeRequest(request) {
    return new Promise((resolve2, reject) => {
      suppressTracing(() => {
        let body = streamFromBody(request.body);
        const headers = { ...options.headers };
        if (request.body.length > GZIP_THRESHOLD) {
          headers["content-encoding"] = "gzip";
          body = body.pipe((0, import_node_zlib.createGzip)());
        }
        const req = httpModule.request(
          {
            method: "POST",
            agent,
            headers,
            hostname: hostname2,
            path: `${pathname}${search}`,
            port,
            protocol,
            ca: options.caCerts
          },
          (res) => {
            res.on("data", () => {
            });
            res.on("end", () => {
            });
            res.setEncoding("utf8");
            const retryAfterHeader = res.headers["retry-after"] ?? null;
            const rateLimitsHeader = res.headers["x-sentry-rate-limits"] ?? null;
            resolve2({
              statusCode: res.statusCode,
              headers: {
                "retry-after": retryAfterHeader,
                "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] || null : rateLimitsHeader
              }
            });
          }
        );
        req.on("error", reject);
        body.pipe(req);
      });
    });
  };
}

// node_modules/@sentry/node/build/esm/utils/envToBool.js
var FALSY_ENV_VALUES = /* @__PURE__ */ new Set(["false", "f", "n", "no", "off", "0"]);
var TRUTHY_ENV_VALUES = /* @__PURE__ */ new Set(["true", "t", "y", "yes", "on", "1"]);
function envToBool(value, options) {
  const normalized = String(value).toLowerCase();
  if (FALSY_ENV_VALUES.has(normalized)) {
    return false;
  }
  if (TRUTHY_ENV_VALUES.has(normalized)) {
    return true;
  }
  return options?.strict ? null : Boolean(value);
}

// node_modules/@sentry/node/build/esm/utils/module.js
var import_node_path3 = require("node:path");
function normalizeWindowsPath(path) {
  return path.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
}
function createGetModuleFromFilename(basePath = process.argv[1] ? dirname(process.argv[1]) : process.cwd(), isWindows = import_node_path3.sep === "\\") {
  const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;
  return (filename) => {
    if (!filename) {
      return;
    }
    const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;
    let { dir, base: file, ext } = import_node_path3.posix.parse(normalizedFilename);
    if (ext === ".js" || ext === ".mjs" || ext === ".cjs") {
      file = file.slice(0, ext.length * -1);
    }
    const decodedFile = decodeURIComponent(file);
    if (!dir) {
      dir = ".";
    }
    const n = dir.lastIndexOf("/node_modules");
    if (n > -1) {
      return `${dir.slice(n + 14).replace(/\//g, ".")}:${decodedFile}`;
    }
    if (dir.startsWith(normalizedBase)) {
      const moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, ".");
      return moduleName ? `${moduleName}:${decodedFile}` : decodedFile;
    }
    return decodedFile;
  };
}

// node_modules/@sentry/node/build/esm/sdk/api.js
function getSentryRelease(fallback) {
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }
  if (GLOBAL_OBJ.SENTRY_RELEASE?.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }
  const possibleReleaseNameOfGitProvider = (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env["GITHUB_SHA"] || // GitLab CI - https://docs.gitlab.com/ee/ci/variables/predefined_variables.html
    process.env["CI_MERGE_REQUEST_SOURCE_BRANCH_SHA"] || process.env["CI_BUILD_REF"] || process.env["CI_COMMIT_SHA"] || // Bitbucket - https://support.atlassian.com/bitbucket-cloud/docs/variables-and-secrets/
    process.env["BITBUCKET_COMMIT"]
  );
  const possibleReleaseNameOfCiProvidersWithSpecificEnvVar = (
    // AppVeyor - https://www.appveyor.com/docs/environment-variables/
    process.env["APPVEYOR_PULL_REQUEST_HEAD_COMMIT"] || process.env["APPVEYOR_REPO_COMMIT"] || // AWS CodeBuild - https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html
    process.env["CODEBUILD_RESOLVED_SOURCE_VERSION"] || // AWS Amplify - https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html
    process.env["AWS_COMMIT_ID"] || // Azure Pipelines - https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml
    process.env["BUILD_SOURCEVERSION"] || // Bitrise - https://devcenter.bitrise.io/builds/available-environment-variables/
    process.env["GIT_CLONE_COMMIT_HASH"] || // Buddy CI - https://buddy.works/docs/pipelines/environment-variables#default-environment-variables
    process.env["BUDDY_EXECUTION_REVISION"] || // Builtkite - https://buildkite.com/docs/pipelines/environment-variables
    process.env["BUILDKITE_COMMIT"] || // CircleCI - https://circleci.com/docs/variables/
    process.env["CIRCLE_SHA1"] || // Cirrus CI - https://cirrus-ci.org/guide/writing-tasks/#environment-variables
    process.env["CIRRUS_CHANGE_IN_REPO"] || // Codefresh - https://codefresh.io/docs/docs/codefresh-yaml/variables/
    process.env["CF_REVISION"] || // Codemagic - https://docs.codemagic.io/yaml-basic-configuration/environment-variables/
    process.env["CM_COMMIT"] || // Cloudflare Pages - https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables
    process.env["CF_PAGES_COMMIT_SHA"] || // Drone - https://docs.drone.io/pipeline/environment/reference/
    process.env["DRONE_COMMIT_SHA"] || // Flightcontrol - https://www.flightcontrol.dev/docs/guides/flightcontrol/environment-variables#built-in-environment-variables
    process.env["FC_GIT_COMMIT_SHA"] || // Heroku #1 https://devcenter.heroku.com/articles/heroku-ci
    process.env["HEROKU_TEST_RUN_COMMIT_VERSION"] || // Heroku #2 https://docs.sentry.io/product/integrations/deployment/heroku/#configure-releases
    process.env["HEROKU_SLUG_COMMIT"] || // Railway - https://docs.railway.app/reference/variables#git-variables
    process.env["RAILWAY_GIT_COMMIT_SHA"] || // Render - https://render.com/docs/environment-variables
    process.env["RENDER_GIT_COMMIT"] || // Semaphore CI - https://docs.semaphoreci.com/ci-cd-environment/environment-variables
    process.env["SEMAPHORE_GIT_SHA"] || // TravisCI - https://docs.travis-ci.com/user/environment-variables/#default-environment-variables
    process.env["TRAVIS_PULL_REQUEST_SHA"] || // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
    process.env["VERCEL_GIT_COMMIT_SHA"] || process.env["VERCEL_GITHUB_COMMIT_SHA"] || process.env["VERCEL_GITLAB_COMMIT_SHA"] || process.env["VERCEL_BITBUCKET_COMMIT_SHA"] || // Zeit (now known as Vercel)
    process.env["ZEIT_GITHUB_COMMIT_SHA"] || process.env["ZEIT_GITLAB_COMMIT_SHA"] || process.env["ZEIT_BITBUCKET_COMMIT_SHA"]
  );
  const possibleReleaseNameOfCiProvidersWithGenericEnvVar = (
    // CloudBees CodeShip - https://docs.cloudbees.com/docs/cloudbees-codeship/latest/pro-builds-and-configuration/environment-variables
    process.env["CI_COMMIT_ID"] || // Coolify - https://coolify.io/docs/knowledge-base/environment-variables
    process.env["SOURCE_COMMIT"] || // Heroku #3 https://devcenter.heroku.com/changelog-items/630
    process.env["SOURCE_VERSION"] || // Jenkins - https://plugins.jenkins.io/git/#environment-variables
    process.env["GIT_COMMIT"] || // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
    process.env["COMMIT_REF"] || // TeamCity - https://www.jetbrains.com/help/teamcity/predefined-build-parameters.html
    process.env["BUILD_VCS_NUMBER"] || // Woodpecker CI - https://woodpecker-ci.org/docs/usage/environment
    process.env["CI_COMMIT_SHA"]
  );
  return possibleReleaseNameOfGitProvider || possibleReleaseNameOfCiProvidersWithSpecificEnvVar || possibleReleaseNameOfCiProvidersWithGenericEnvVar || fallback;
}
var defaultStackParser = createStackParser(nodeStackLineParser(createGetModuleFromFilename()));

// node_modules/@sentry/node/build/esm/sdk/client.js
var os2 = __toESM(require("node:os"), 1);
init_esm();
var import_instrumentation9 = __toESM(require_src4(), 1);
var import_worker_threads = require("worker_threads");
var DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 6e4;
var NodeClient = class extends ServerRuntimeClient {
  constructor(options) {
    const serverName = options.serverName || global.process.env.SENTRY_NAME || os2.hostname();
    const clientOptions = {
      ...options,
      platform: "node",
      runtime: { name: "node", version: global.process.version },
      serverName
    };
    if (options.openTelemetryInstrumentations) {
      (0, import_instrumentation9.registerInstrumentations)({
        instrumentations: options.openTelemetryInstrumentations
      });
    }
    applySdkMetadata(clientOptions, "node");
    logger.log(
      `Initializing Sentry: process: ${process.pid}, thread: ${import_worker_threads.isMainThread ? "main" : `worker-${import_worker_threads.threadId}`}.`
    );
    super(clientOptions);
    if (this.getOptions()._experiments?.enableLogs) {
      this._logOnExitFlushListener = () => {
        _INTERNAL_flushLogsBuffer(this);
      };
      if (serverName) {
        this.on("beforeCaptureLog", (log2) => {
          log2.attributes = {
            ...log2.attributes,
            "server.address": serverName
          };
        });
      }
      process.on("beforeExit", this._logOnExitFlushListener);
    }
  }
  /** Get the OTEL tracer. */
  get tracer() {
    if (this._tracer) {
      return this._tracer;
    }
    const name = "@sentry/node";
    const version = SDK_VERSION;
    const tracer = trace.getTracer(name, version);
    this._tracer = tracer;
    return tracer;
  }
  // Eslint ignore explanation: This is already documented in super.
  // eslint-disable-next-line jsdoc/require-jsdoc
  async flush(timeout) {
    const provider = this.traceProvider;
    const spanProcessor = provider?.activeSpanProcessor;
    if (spanProcessor) {
      await spanProcessor.forceFlush();
    }
    if (this.getOptions().sendClientReports) {
      this._flushOutcomes();
    }
    return super.flush(timeout);
  }
  // Eslint ignore explanation: This is already documented in super.
  // eslint-disable-next-line jsdoc/require-jsdoc
  close(timeout) {
    if (this._clientReportInterval) {
      clearInterval(this._clientReportInterval);
    }
    if (this._clientReportOnExitFlushListener) {
      process.off("beforeExit", this._clientReportOnExitFlushListener);
    }
    if (this._logOnExitFlushListener) {
      process.off("beforeExit", this._logOnExitFlushListener);
    }
    return super.close(timeout);
  }
  /**
   * Will start tracking client reports for this client.
   *
   * NOTICE: This method will create an interval that is periodically called and attach a `process.on('beforeExit')`
   * hook. To clean up these resources, call `.close()` when you no longer intend to use the client. Not doing so will
   * result in a memory leak.
   */
  // The reason client reports need to be manually activated with this method instead of just enabling them in a
  // constructor, is that if users periodically and unboundedly create new clients, we will create more and more
  // intervals and beforeExit listeners, thus leaking memory. In these situations, users are required to call
  // `client.close()` in order to dispose of the acquired resources.
  // We assume that calling this method in Sentry.init() is a sensible default, because calling Sentry.init() over and
  // over again would also result in memory leaks.
  // Note: We have experimented with using `FinalizationRegisty` to clear the interval when the client is garbage
  // collected, but it did not work, because the cleanup function never got called.
  startClientReportTracking() {
    const clientOptions = this.getOptions();
    if (clientOptions.sendClientReports) {
      this._clientReportOnExitFlushListener = () => {
        this._flushOutcomes();
      };
      this._clientReportInterval = setInterval(() => {
        DEBUG_BUILD3 && logger.log("Flushing client reports based on interval.");
        this._flushOutcomes();
      }, clientOptions.clientReportFlushInterval ?? DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS).unref();
      process.on("beforeExit", this._clientReportOnExitFlushListener);
    }
  }
  /** Custom implementation for OTEL, so we can handle scope-span linking. */
  _getTraceInfoFromScope(scope) {
    if (!scope) {
      return [void 0, void 0];
    }
    return getTraceContextForScope(this, scope);
  }
};

// node_modules/@sentry/node/build/esm/sdk/initOtel.js
var import_module2 = __toESM(require("module"), 1);
init_esm();
var import_resources = __toESM(require_src7(), 1);
var import_sdk_trace_base2 = __toESM(require_src8(), 1);
init_esm4();
var import_import_in_the_middle = __toESM(require_import_in_the_middle(), 1);
var import_meta = {};
var MAX_MAX_SPAN_WAIT_DURATION = 1e6;
function initOpenTelemetry(client, options = {}) {
  if (client.getOptions().debug) {
    setupOpenTelemetryLogger();
  }
  const provider = setupOtel(client, options);
  client.traceProvider = provider;
}
function maybeInitializeEsmLoader() {
  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split(".").map(Number);
  if (nodeMajor >= 22 || nodeMajor === 20 && nodeMinor >= 6 || nodeMajor === 18 && nodeMinor >= 19) {
    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {
      try {
        const { addHookMessagePort } = (0, import_import_in_the_middle.createAddHookMessageChannel)();
        import_module2.default.register("import-in-the-middle/hook.mjs", import_meta.url, {
          data: { addHookMessagePort, include: [] },
          transferList: [addHookMessagePort]
        });
      } catch (error) {
        logger.warn("Failed to register ESM hook", error);
      }
    }
  } else {
    consoleSandbox(() => {
      console.warn(
        '[Sentry] You are using Node.js in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or upgrade your Node.js version.'
      );
    });
  }
}
function setupOtel(client, options = {}) {
  const provider = new import_sdk_trace_base2.BasicTracerProvider({
    sampler: new SentrySampler(client),
    resource: new import_resources.Resource({
      [ATTR_SERVICE_NAME3]: "node",
      // eslint-disable-next-line deprecation/deprecation
      [SEMRESATTRS_SERVICE_NAMESPACE3]: "sentry",
      [ATTR_SERVICE_VERSION3]: SDK_VERSION
    }),
    forceFlushTimeoutMillis: 500,
    spanProcessors: [
      new SentrySpanProcessor({
        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration)
      }),
      ...options.spanProcessors || []
    ]
  });
  trace.setGlobalTracerProvider(provider);
  propagation.setGlobalPropagator(new SentryPropagator());
  context.setGlobalContextManager(new SentryContextManager());
  return provider;
}
function _clampSpanProcessorTimeout(maxSpanWaitDuration) {
  if (maxSpanWaitDuration == null) {
    return void 0;
  }
  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {
    DEBUG_BUILD3 && logger.warn(`\`maxSpanWaitDuration\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);
    return MAX_MAX_SPAN_WAIT_DURATION;
  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {
    DEBUG_BUILD3 && logger.warn("`maxSpanWaitDuration` must be a positive number, using default value instead.");
    return void 0;
  }
  return maxSpanWaitDuration;
}
function setupOpenTelemetryLogger() {
  const otelLogger = new Proxy(logger, {
    get(target, prop, receiver) {
      const actualProp = prop === "verbose" ? "debug" : prop;
      return Reflect.get(target, actualProp, receiver);
    }
  });
  diag2.disable();
  diag2.setLogger(otelLogger, DiagLogLevel.DEBUG);
}

// node_modules/@sentry/node/build/esm/sdk/index.js
function getCjsOnlyIntegrations() {
  return isCjs() ? [modulesIntegration()] : [];
}
function getDefaultIntegrationsWithoutPerformance() {
  return [
    // Common
    // TODO(v10): Replace with `eventFiltersIntegration` once we remove the deprecated `inboundFiltersIntegration`
    // eslint-disable-next-line deprecation/deprecation
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    linkedErrorsIntegration(),
    requestDataIntegration(),
    // Native Wrappers
    consoleIntegration(),
    httpIntegration(),
    nativeNodeFetchIntegration(),
    // Global Handlers
    onUncaughtExceptionIntegration(),
    onUnhandledRejectionIntegration(),
    // Event Info
    contextLinesIntegration(),
    localVariablesIntegration(),
    nodeContextIntegration(),
    childProcessIntegration(),
    processSessionIntegration(),
    ...getCjsOnlyIntegrations()
  ];
}
function getDefaultIntegrations(options) {
  return [
    ...getDefaultIntegrationsWithoutPerformance(),
    // We only add performance integrations if tracing is enabled
    // Note that this means that without tracing enabled, e.g. `expressIntegration()` will not be added
    // This means that generally request isolation will work (because that is done by httpIntegration)
    // But `transactionName` will not be set automatically
    ...hasSpansEnabled(options) ? getAutoPerformanceIntegrations() : []
  ];
}
function init(options = {}) {
  return _init(options, getDefaultIntegrations);
}
function _init(_options = {}, getDefaultIntegrationsImpl) {
  const options = getClientOptions(_options, getDefaultIntegrationsImpl);
  if (options.debug === true) {
    if (DEBUG_BUILD3) {
      logger.enable();
    } else {
      consoleSandbox(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      });
    }
  }
  if (!isCjs() && options.registerEsmLoaderHooks !== false) {
    maybeInitializeEsmLoader();
  }
  setOpenTelemetryContextAsyncContextStrategy();
  const scope = getCurrentScope();
  scope.update(options.initialScope);
  if (options.spotlight && !options.integrations.some(({ name }) => name === INTEGRATION_NAME28)) {
    options.integrations.push(
      spotlightIntegration({
        sidecarUrl: typeof options.spotlight === "string" ? options.spotlight : void 0
      })
    );
  }
  const client = new NodeClient(options);
  getCurrentScope().setClient(client);
  client.init();
  logger.log(`Running in ${isCjs() ? "CommonJS" : "ESM"} mode.`);
  client.startClientReportTracking();
  updateScopeFromEnvVariables();
  if (!options.skipOpenTelemetrySetup) {
    initOpenTelemetry(client, {
      spanProcessors: options.openTelemetrySpanProcessors
    });
    validateOpenTelemetrySetup();
  }
  enhanceDscWithOpenTelemetryRootSpanName(client);
  setupEventContextTrace(client);
  return client;
}
function validateOpenTelemetrySetup() {
  if (!DEBUG_BUILD3) {
    return;
  }
  const setup = openTelemetrySetupCheck();
  const required = ["SentryContextManager", "SentryPropagator"];
  if (hasSpansEnabled()) {
    required.push("SentrySpanProcessor");
  }
  for (const k of required) {
    if (!setup.includes(k)) {
      logger.error(
        `You have to set up the ${k}. Without this, the OpenTelemetry & Sentry integration will not work properly.`
      );
    }
  }
  if (!setup.includes("SentrySampler")) {
    logger.warn(
      "You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected. If you use a custom sampler, make sure to use `wrapSamplingDecision`."
    );
  }
}
function getClientOptions(options, getDefaultIntegrationsImpl) {
  const release2 = getRelease(options.release);
  const spotlight = options.spotlight ?? envToBool(process.env.SENTRY_SPOTLIGHT, { strict: true }) ?? process.env.SENTRY_SPOTLIGHT;
  const tracesSampleRate = getTracesSampleRate(options.tracesSampleRate);
  const mergedOptions = {
    ...options,
    dsn: options.dsn ?? process.env.SENTRY_DSN,
    environment: options.environment ?? process.env.SENTRY_ENVIRONMENT,
    sendClientReports: options.sendClientReports ?? true,
    transport: options.transport ?? makeNodeTransport,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    release: release2,
    tracesSampleRate,
    spotlight,
    debug: envToBool(options.debug ?? process.env.SENTRY_DEBUG)
  };
  const integrations = options.integrations;
  const defaultIntegrations = options.defaultIntegrations ?? getDefaultIntegrationsImpl(mergedOptions);
  return {
    ...mergedOptions,
    integrations: getIntegrationsToSetup({
      defaultIntegrations,
      integrations
    })
  };
}
function getRelease(release2) {
  if (release2 !== void 0) {
    return release2;
  }
  const detectedRelease = getSentryRelease();
  if (detectedRelease !== void 0) {
    return detectedRelease;
  }
  return void 0;
}
function getTracesSampleRate(tracesSampleRate) {
  if (tracesSampleRate !== void 0) {
    return tracesSampleRate;
  }
  const sampleRateFromEnv = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (!sampleRateFromEnv) {
    return void 0;
  }
  const parsed = parseFloat(sampleRateFromEnv);
  return isFinite(parsed) ? parsed : void 0;
}
function updateScopeFromEnvVariables() {
  if (envToBool(process.env.SENTRY_USE_ENVIRONMENT) !== false) {
    const sentryTraceEnv = process.env.SENTRY_TRACE;
    const baggageEnv = process.env.SENTRY_BAGGAGE;
    const propagationContext = propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
    getCurrentScope().setPropagationContext(propagationContext);
  }
}

// src/index.ts
var core3 = __toESM(require_core4());

// src/installer.ts
var tc = __toESM(require_tool_cache());
var core = __toESM(require_core4());
var import_os = __toESM(require("os"));
var import_node_events = __toESM(require("node:events"));

// src/util/output_tracker.ts
var OutputTracker = class _OutputTracker {
  constructor(emitter, event) {
    __publicField(this, "_emitter");
    __publicField(this, "_event");
    __publicField(this, "_trackerFn");
    __publicField(this, "_data");
    this._emitter = emitter;
    this._event = event;
    this._data = [];
    this._trackerFn = (datum) => this._data.push(datum);
    this._emitter.on(this._event, this._trackerFn);
  }
  static create(emitter, event) {
    return new _OutputTracker(emitter, event);
  }
  clear() {
    const result = [...this._data];
    this._data.length = 0;
    return result;
  }
};

// src/util/output.ts
var StubbedOutput = class {
  constructor() {
    __publicField(this, "secrets", []);
    __publicField(this, "paths", []);
    __publicField(this, "failures", []);
    __publicField(this, "infos", []);
    __publicField(this, "warnings", []);
  }
  addPath(path) {
    this.paths.push(path);
  }
  setSecret(secret) {
    this.secrets.push(secret);
  }
  setFailed(message) {
    this.failures.push(message);
  }
  info(message) {
    this.infos.push(message);
  }
  warning(message) {
    this.warnings.push(message);
  }
};

// src/installer.ts
var DOWNLOAD_EVENT = "download";
var Installer = class _Installer {
  constructor(os4, output, toolCache, version) {
    __publicField(this, "_os");
    __publicField(this, "_output");
    __publicField(this, "_tc");
    __publicField(this, "_emitter", new import_node_events.default());
    __publicField(this, "_version");
    this._os = os4;
    this._output = output;
    this._tc = toolCache;
    this._version = version;
  }
  static create(version) {
    return new _Installer(import_os.default, core, tc, version);
  }
  static createNull(version, raiseDownloadError) {
    return new _Installer(
      new StubbedOperatingSystem(),
      new StubbedOutput(),
      new StubbedToolCache(raiseDownloadError),
      version
    );
  }
  trackOutput() {
    return OutputTracker.create(this._emitter, DOWNLOAD_EVENT);
  }
  async install() {
    const platform2 = this._os.platform();
    const arch2 = this._os.arch();
    let platformArch;
    if (platform2 === "linux" && arch2 === "x64") {
      platformArch = "x86_64-unknown-linux-gnu";
    } else if (platform2 === "linux" && arch2 === "arm64") {
      platformArch = "aarch64-unknown-linux-gnu";
    } else if (platform2 === "darwin" && arch2 === "x64") {
      platformArch = "x86_64-apple-darwin";
    } else if (platform2 === "darwin" && arch2 === "arm64") {
      platformArch = "aarch64-apple-darwin";
    } else {
      this._output.setFailed(
        `Unsupported platform/architecture: ${platform2}/${arch2}`
      );
      return;
    }
    const versionPath = this._version ? `v${this._version}` : "latest";
    const downloadUrl = `https://qlty-releases.s3.amazonaws.com/qlty/${versionPath}/qlty-${platformArch}.tar.xz`;
    const tarPath = await this._tc.downloadTool(downloadUrl);
    const extractedFolder = await this._tc.extractTar(tarPath, void 0, "x");
    const cachedPath = await this._tc.cacheDir(
      extractedFolder,
      "qlty",
      versionPath
    );
    this._emitter.emit(DOWNLOAD_EVENT, downloadUrl);
    const binPath = `${cachedPath}/qlty-${platformArch}`;
    this._output.addPath(binPath);
  }
};
var StubbedOperatingSystem = class {
  constructor(platform2 = "linux", arch2 = "x64") {
    __publicField(this, "_platform");
    __publicField(this, "_arch");
    this._platform = platform2;
    this._arch = arch2;
  }
  platform() {
    return this._platform;
  }
  arch() {
    return this._arch;
  }
};
var StubbedToolCache = class {
  constructor(raiseError) {
    __publicField(this, "downloads", []);
    __publicField(this, "raiseError", false);
    this.raiseError = raiseError || false;
  }
  async downloadTool(url2) {
    if (this.raiseError) {
      throw new Error("download error");
    } else {
      this.downloads.push(url2);
      return `downloaded[${url2}]`;
    }
  }
  async extractTar(file, _dest, _options) {
    return `extracted[${file} dest=${_dest} options=${_options}]`;
  }
  async cacheDir(folder, _tool, _version) {
    return `cached[${folder}]`;
  }
};

// node_modules/zod/lib/index.mjs
var util2;
(function(util3) {
  util3.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util3.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util3.assertNever = assertNever;
  util3.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util3.getValidEnumValues = (obj) => {
    const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util3.objectValues(filtered);
  };
  util3.objectValues = (obj) => {
    return util3.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util3.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util3.joinValues = joinValues;
  util3.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util2 || (util2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util2.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util2.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util2.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util2.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util2.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util2.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util2.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util2.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util2.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util2.objectKeys(b);
    const sharedKeys = util2.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util2.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util2.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util2;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/settings.ts
var core2 = __toESM(require_core4());
var glob = __toESM(require_glob());
var optionalNormalizedString = z.string().transform((val) => val === "" ? void 0 : val);
var formatEnum = z.enum([
  "clover",
  "cobertura",
  "coverprofile",
  "jacoco",
  "lcov",
  "qlty",
  "simplecov"
]);
var settingsParser = z.object({
  token: optionalNormalizedString,
  coverageToken: optionalNormalizedString,
  files: z.string().trim(),
  addPrefix: optionalNormalizedString,
  stripPrefix: optionalNormalizedString,
  skipErrors: z.boolean(),
  skipMissingFiles: z.boolean(),
  tag: optionalNormalizedString,
  totalPartsCount: z.string().transform((val) => {
    if (val === "") return void 0;
    const num = Number(val);
    return isNaN(num) ? void 0 : num;
  }),
  oidc: z.boolean(),
  verbose: z.boolean(),
  cliVersion: optionalNormalizedString,
  format: z.union([formatEnum, z.literal("")]).transform((val) => val === "" ? void 0 : val).optional()
});
var OIDC_AUDIENCE = "https://qlty.sh";
var COVERAGE_TOKEN_REGEX = /^(qltcp_|qltcw_)[a-zA-Z0-9]{10,}$/;
var Settings = class _Settings {
  constructor(data, input, fs) {
    __publicField(this, "_data");
    __publicField(this, "_input");
    __publicField(this, "_fs");
    this._data = data;
    this._input = input;
    this._fs = fs;
  }
  static create(input = core2, fs = FileSystem.create()) {
    return new _Settings(
      settingsParser.parse({
        files: input.getInput("files", { required: true }).trim(),
        addPrefix: input.getInput("add-prefix"),
        stripPrefix: input.getInput("strip-prefix"),
        skipErrors: input.getBooleanInput("skip-errors"),
        skipMissingFiles: input.getBooleanInput("skip-missing-files"),
        tag: input.getInput("tag"),
        totalPartsCount: input.getInput("total-parts-count"),
        oidc: input.getBooleanInput("oidc"),
        coverageToken: input.getInput("coverage-token"),
        token: input.getInput("token"),
        verbose: input.getBooleanInput("verbose"),
        cliVersion: input.getInput("cli-version"),
        format: input.getInput("format")
      }),
      input,
      fs
    );
  }
  static createNull(input = {}, fs = FileSystem.createNull()) {
    return _Settings.create(new StubbedInputProvider(input), fs);
  }
  validate() {
    const errors = [];
    const coverageToken = this.getCoverageToken();
    if (!this._data.oidc && !coverageToken) {
      errors.push("Either 'oidc' or 'token' must be provided.");
    }
    if (this._data.oidc && coverageToken) {
      errors.push(
        "Both 'oidc' and 'token' cannot be provided at the same time."
      );
    }
    if (coverageToken && !COVERAGE_TOKEN_REGEX.test(coverageToken)) {
      errors.push(
        "The provided token is invalid. It should begin with 'qltcp_' or 'qltcw_' followed by alphanumerics."
      );
    }
    return errors;
  }
  async getToken() {
    if (this._data.oidc) {
      return await this._input.getIDToken(OIDC_AUDIENCE);
    } else {
      const coverageToken = this.getCoverageToken();
      if (!coverageToken) {
        throw new Error("'token' is required when 'oidc' is false.");
      } else {
        return coverageToken;
      }
    }
  }
  getVersion() {
    if (!this._data.cliVersion) {
      return void 0;
    }
    return this._data.cliVersion.startsWith("v") ? this._data.cliVersion.substring(1) : this._data.cliVersion;
  }
  async getFiles() {
    const patterns = this._data.files.split(",").map((file) => file.trim()).filter(Boolean);
    const expandedFiles = await this._fs.globPatterns(patterns.join("\n"));
    return this.sortedUnique(expandedFiles);
  }
  get input() {
    return this._data;
  }
  // Handles getting the coverage token
  // from the `token` or deprecated `coverage-token` input
  getCoverageToken() {
    if (this._data.token) {
      return this._data.token;
    } else {
      return this._data.coverageToken;
    }
  }
  sortedUnique(files) {
    return Array.from(new Set(files)).sort();
  }
};
var FileSystem = class _FileSystem {
  static create() {
    return new _FileSystem();
  }
  static createNull(results) {
    return new StubbedFileSystem(results);
  }
  async globPatterns(patterns) {
    const globber = await glob.create(patterns);
    return await globber.glob();
  }
};
var StubbedFileSystem = class {
  constructor(results = void 0) {
    __publicField(this, "results", []);
    this.results = results;
  }
  async globPatterns(patterns) {
    if (this.results) {
      return this.results;
    } else {
      return patterns.split("\n").map((pattern) => pattern.trim()).filter(Boolean);
    }
  }
};
var StubbedInputProvider = class {
  constructor(data) {
    __publicField(this, "_data");
    this._data = {
      files: data.files || "",
      "add-prefix": data["add-prefix"] || "",
      "strip-prefix": data["strip-prefix"] || "",
      "skip-errors": data["skip-errors"] || false,
      "skip-missing-files": data["skip-missing-files"] || false,
      tag: data.tag || "",
      "total-parts-count": data["total-parts-count"] || "",
      oidc: data.oidc || false,
      "coverage-token": data["coverage-token"] || "",
      token: data.token || "",
      verbose: data.verbose || false,
      "cli-version": data["cli-version"] || "",
      format: data["format"] || ""
    };
  }
  getInput(name, _options) {
    return (this._data[name] || "").toString();
  }
  getBooleanInput(name, _options) {
    return this._data[name] === true;
  }
  async getIDToken(audience) {
    return `oidc-token:audience=${audience}`;
  }
};

// src/action.ts
var actionsExec = __toESM(require_exec());
var actionsCore = __toESM(require_core4());
var actionsGithub = __toESM(require_github());

// src/util/exec.ts
var StubbedCommandExecutor = class {
  constructor({ throwError } = {}) {
    __publicField(this, "throwError");
    this.throwError = !!throwError;
  }
  async exec(_command, _args, _options) {
    if (this.throwError) {
      throw new Error("Command execution failed");
    } else {
      return 0;
    }
  }
};

// src/action.ts
var import_node_events2 = __toESM(require("node:events"));
var EXEC_EVENT = "exec";
var CoverageAction = class _CoverageAction {
  constructor({
    output = actionsCore,
    context: context3 = actionsGithub.context,
    executor = actionsExec,
    installer,
    settings = Settings.create()
  } = {}) {
    __publicField(this, "_output");
    __publicField(this, "_context");
    __publicField(this, "_executor");
    __publicField(this, "_installer");
    __publicField(this, "_settings");
    __publicField(this, "_emitter", new import_node_events2.default());
    this._output = output;
    this._context = context3;
    this._executor = executor;
    this._installer = installer || Installer.create(settings.getVersion());
    this._settings = settings;
  }
  static createNull({
    output = new StubbedOutput(),
    context: context3 = new StubbedActionContext(),
    executor = new StubbedCommandExecutor(),
    installer,
    settings = Settings.createNull()
  } = {}) {
    return new _CoverageAction({
      output,
      context: context3,
      executor,
      installer: installer || Installer.createNull(settings.getVersion()),
      settings
    });
  }
  async run() {
    if (!this.validate()) {
      return;
    }
    try {
      await this._installer.install();
    } catch (error) {
      const errorMessage = error instanceof Error ? `: ${error.message}.` : ".";
      this.warnOrThrow([
        `Error installing Qlty CLI${errorMessage} Please check the action's inputs. If you are using a 'cli-version', make sure it is correct.`
      ]);
      return;
    }
    let uploadArgs = await this.buildArgs();
    const files = await this._settings.getFiles();
    if (files.length === 0) {
      if (this._settings.input.files.includes(" ")) {
        this.warnOrThrow([
          "No code coverage data files were found. Please check the action's inputs.",
          "NOTE: To specify multiple files, use a comma or newline separated list NOT spaces.",
          "If you are using a pattern, make sure it is correct.",
          "If you are using a file, make sure it exists."
        ]);
      } else {
        this.warnOrThrow([
          "No code coverage data files were found. Please check the action's inputs.",
          "If you are using a pattern, make sure it is correct.",
          "If you are using a file, make sure it exists."
        ]);
      }
      return;
    }
    uploadArgs = uploadArgs.concat(files);
    const token = await this._settings.getToken();
    this._output.setSecret(token);
    let qlytOutput = "";
    try {
      const env = {
        ...process.env,
        QLTY_COVERAGE_TOKEN: token
      };
      this._emitter.emit(EXEC_EVENT, { command: ["qlty", ...uploadArgs], env });
      this._output.info(`Running: ${["qlty", ...uploadArgs].join(" ")}`);
      await this._executor.exec("qlty", uploadArgs, {
        env,
        listeners: {
          stdout: (data) => {
            qlytOutput += data.toString();
          },
          stderr: (data) => {
            qlytOutput += data.toString();
          }
        }
      });
    } catch {
      this.warnOrThrow([
        "Error uploading coverage. Output from the Qlty CLI follows:",
        qlytOutput
      ]);
    }
  }
  validate() {
    const errors = this._settings.validate();
    if (errors.length > 0) {
      this.warnOrThrow([
        "Error validating action input:",
        ...errors,
        "Please check the action's inputs."
      ]);
      return false;
    }
    return true;
  }
  warnOrThrow(messages) {
    if (this._settings.input.skipErrors) {
      for (const message of messages) {
        this._output.warning(message);
      }
    } else {
      throw new CoverageError(messages.join("; "));
    }
  }
  async buildArgs() {
    const uploadArgs = ["coverage", "publish"];
    if (this._settings.input.verbose) {
      uploadArgs.push("--print");
    }
    if (this._settings.input.addPrefix) {
      uploadArgs.push("--add-prefix", this._settings.input.addPrefix);
    }
    if (this._settings.input.stripPrefix) {
      uploadArgs.push("--strip-prefix", this._settings.input.stripPrefix);
    }
    if (this._settings.input.format) {
      uploadArgs.push("--format", this._settings.input.format);
    }
    if (this._settings.input.tag) {
      uploadArgs.push("--tag", this._settings.input.tag);
    }
    if (this._settings.input.totalPartsCount) {
      uploadArgs.push(
        "--total-parts-count",
        this._settings.input.totalPartsCount.toString()
      );
    }
    const payload = this._context.payload;
    if (payload.pull_request) {
      uploadArgs.push(
        "--override-commit-sha",
        payload.pull_request["head"].sha
      );
      uploadArgs.push("--override-branch", payload.pull_request["head"].ref);
    }
    if (this._settings.input.skipMissingFiles) {
      uploadArgs.push("--skip-missing-files");
    }
    return uploadArgs;
  }
  trackOutput() {
    return OutputTracker.create(this._emitter, EXEC_EVENT);
  }
};
var CoverageError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CoverageError";
  }
};
var StubbedActionContext = class {
  get payload() {
    return {
      pull_request: {
        number: 1,
        head: {
          sha: "test-sha",
          ref: "test-ref"
        }
      }
    };
  }
};

// src/index.ts
init({
  dsn: "https://76f58a921c9d8561646a586e7d9df772@o4506826106929152.ingest.us.sentry.io/4506826142646272",
  tracesSampleRate: 1
});
runWithTracing(async () => {
  const action = new CoverageAction();
  await action.run();
});
async function runWithTracing(main) {
  return await startSpan(
    {
      op: "execute",
      name: "qlty-action/coverage"
    },
    async () => {
      setTag("provider", "github");
      setTag(
        "repository.full_name",
        process.env["GITHUB_REPOSITORY"] || "unknown"
      );
      setContext("CI", {
        run_id: process.env["GITHUB_RUN_ID"],
        run_url: `${process.env["GITHUB_SERVER_URL"]}/${process.env["GITHUB_REPOSITORY"]}/actions/runs/${process.env["GITHUB_RUN_ID"]}`
      });
      main().then(() => {
        close(2e3).then(function() {
          process.exit(0);
        });
      }).catch((error) => {
        core3.setFailed(
          `Action failed with error: ${error.name}: ${error.message}`
        );
        addBreadcrumb({
          category: "qlty-coverage.log",
          level: "log",
          type: "error",
          message: error.message
        });
        captureException(error);
        close(2e3).then(function() {
          process.exit(1);
        });
      });
    }
  );
}
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
